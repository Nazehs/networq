
          window.__NEXT_REGISTER_PAGE('/', function() {
            var comp = module.exports =
webpackJsonp([5],[
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (true) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyFunction = __webpack_require__(23);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (true) {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(5);
var core = __webpack_require__(2);
var ctx = __webpack_require__(12);
var hide = __webpack_require__(13);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(51)('wks');
var uid = __webpack_require__(38);
var Symbol = __webpack_require__(5).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 5 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(11);
var IE8_DOM_DEFINE = __webpack_require__(75);
var toPrimitive = __webpack_require__(48);
var dP = Object.defineProperty;

exports.f = __webpack_require__(8) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(14)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 10 */,
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(9);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(35);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(6);
var createDesc = __webpack_require__(26);
module.exports = __webpack_require__(8) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 15 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(7);

var ReactCurrentOwner = __webpack_require__(21);

var warning = __webpack_require__(1);
var canDefineProperty = __webpack_require__(41);
var hasOwnProperty = Object.prototype.hasOwnProperty;

var REACT_ELEMENT_TYPE = __webpack_require__(87);

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown, specialPropRefWarningShown;

function hasValidRef(config) {
  if (true) {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  if (true) {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
       true ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
       true ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  if (true) {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    if (canDefineProperty) {
      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      });
      // self and source are DEV only properties.
      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      });
      // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.
      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });
    } else {
      element._store.validated = false;
      element._self = self;
      element._source = source;
    }
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
 */
ReactElement.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    if (true) {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  if (true) {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
};

/**
 * Return a function that produces ReactElements of a given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
 */
ReactElement.createFactory = function (type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
};

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
 */
ReactElement.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
};

/**
 * Verifies the object is a ReactElement.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function (object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
};

module.exports = ReactElement;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(20);

var ReactCurrentOwner = __webpack_require__(21);

var invariant = __webpack_require__(0);
var warning = __webpack_require__(1);

function isNative(fn) {
  // Based on isNative() from Lodash
  var funcToString = Function.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var reIsNative = RegExp('^' + funcToString
  // Take an example native function source for comparison
  .call(hasOwnProperty
  // Strip regex characters so we can use it for regex
  ).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&'
  // Remove hasOwnProperty from the template to make it generic
  ).replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  try {
    var source = funcToString.call(fn);
    return reIsNative.test(source);
  } catch (err) {
    return false;
  }
}

var canUseCollections =
// Array.from
typeof Array.from === 'function' &&
// Map
typeof Map === 'function' && isNative(Map) &&
// Map.prototype.keys
Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
// Set
typeof Set === 'function' && isNative(Set) &&
// Set.prototype.keys
Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);

var setItem;
var getItem;
var removeItem;
var getItemIDs;
var addRoot;
var removeRoot;
var getRootIDs;

if (canUseCollections) {
  var itemMap = new Map();
  var rootIDSet = new Set();

  setItem = function (id, item) {
    itemMap.set(id, item);
  };
  getItem = function (id) {
    return itemMap.get(id);
  };
  removeItem = function (id) {
    itemMap['delete'](id);
  };
  getItemIDs = function () {
    return Array.from(itemMap.keys());
  };

  addRoot = function (id) {
    rootIDSet.add(id);
  };
  removeRoot = function (id) {
    rootIDSet['delete'](id);
  };
  getRootIDs = function () {
    return Array.from(rootIDSet.keys());
  };
} else {
  var itemByKey = {};
  var rootByKey = {};

  // Use non-numeric keys to prevent V8 performance issues:
  // https://github.com/facebook/react/pull/7232
  var getKeyFromID = function (id) {
    return '.' + id;
  };
  var getIDFromKey = function (key) {
    return parseInt(key.substr(1), 10);
  };

  setItem = function (id, item) {
    var key = getKeyFromID(id);
    itemByKey[key] = item;
  };
  getItem = function (id) {
    var key = getKeyFromID(id);
    return itemByKey[key];
  };
  removeItem = function (id) {
    var key = getKeyFromID(id);
    delete itemByKey[key];
  };
  getItemIDs = function () {
    return Object.keys(itemByKey).map(getIDFromKey);
  };

  addRoot = function (id) {
    var key = getKeyFromID(id);
    rootByKey[key] = true;
  };
  removeRoot = function (id) {
    var key = getKeyFromID(id);
    delete rootByKey[key];
  };
  getRootIDs = function () {
    return Object.keys(rootByKey).map(getIDFromKey);
  };
}

var unmountedIDs = [];

function purgeDeep(id) {
  var item = getItem(id);
  if (item) {
    var childIDs = item.childIDs;

    removeItem(id);
    childIDs.forEach(purgeDeep);
  }
}

function describeComponentFrame(name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
}

function getDisplayName(element) {
  if (element == null) {
    return '#empty';
  } else if (typeof element === 'string' || typeof element === 'number') {
    return '#text';
  } else if (typeof element.type === 'string') {
    return element.type;
  } else {
    return element.type.displayName || element.type.name || 'Unknown';
  }
}

function describeID(id) {
  var name = ReactComponentTreeHook.getDisplayName(id);
  var element = ReactComponentTreeHook.getElement(id);
  var ownerID = ReactComponentTreeHook.getOwnerID(id);
  var ownerName;
  if (ownerID) {
    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
  }
   true ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
  return describeComponentFrame(name, element && element._source, ownerName);
}

var ReactComponentTreeHook = {
  onSetChildren: function (id, nextChildIDs) {
    var item = getItem(id);
    !item ?  true ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.childIDs = nextChildIDs;

    for (var i = 0; i < nextChildIDs.length; i++) {
      var nextChildID = nextChildIDs[i];
      var nextChild = getItem(nextChildID);
      !nextChild ?  true ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ?  true ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
      !nextChild.isMounted ?  true ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
      if (nextChild.parentID == null) {
        nextChild.parentID = id;
        // TODO: This shouldn't be necessary but mounting a new root during in
        // componentWillMount currently causes not-yet-mounted components to
        // be purged from our tree data so their parent id is missing.
      }
      !(nextChild.parentID === id) ?  true ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
    }
  },
  onBeforeMountComponent: function (id, element, parentID) {
    var item = {
      element: element,
      parentID: parentID,
      text: null,
      childIDs: [],
      isMounted: false,
      updateCount: 0
    };
    setItem(id, item);
  },
  onBeforeUpdateComponent: function (id, element) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.element = element;
  },
  onMountComponent: function (id) {
    var item = getItem(id);
    !item ?  true ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.isMounted = true;
    var isRoot = item.parentID === 0;
    if (isRoot) {
      addRoot(id);
    }
  },
  onUpdateComponent: function (id) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.updateCount++;
  },
  onUnmountComponent: function (id) {
    var item = getItem(id);
    if (item) {
      // We need to check if it exists.
      // `item` might not exist if it is inside an error boundary, and a sibling
      // error boundary child threw while mounting. Then this instance never
      // got a chance to mount, but it still gets an unmounting event during
      // the error boundary cleanup.
      item.isMounted = false;
      var isRoot = item.parentID === 0;
      if (isRoot) {
        removeRoot(id);
      }
    }
    unmountedIDs.push(id);
  },
  purgeUnmountedComponents: function () {
    if (ReactComponentTreeHook._preventPurging) {
      // Should only be used for testing.
      return;
    }

    for (var i = 0; i < unmountedIDs.length; i++) {
      var id = unmountedIDs[i];
      purgeDeep(id);
    }
    unmountedIDs.length = 0;
  },
  isMounted: function (id) {
    var item = getItem(id);
    return item ? item.isMounted : false;
  },
  getCurrentStackAddendum: function (topElement) {
    var info = '';
    if (topElement) {
      var name = getDisplayName(topElement);
      var owner = topElement._owner;
      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
    }

    var currentOwner = ReactCurrentOwner.current;
    var id = currentOwner && currentOwner._debugID;

    info += ReactComponentTreeHook.getStackAddendumByID(id);
    return info;
  },
  getStackAddendumByID: function (id) {
    var info = '';
    while (id) {
      info += describeID(id);
      id = ReactComponentTreeHook.getParentID(id);
    }
    return info;
  },
  getChildIDs: function (id) {
    var item = getItem(id);
    return item ? item.childIDs : [];
  },
  getDisplayName: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element) {
      return null;
    }
    return getDisplayName(element);
  },
  getElement: function (id) {
    var item = getItem(id);
    return item ? item.element : null;
  },
  getOwnerID: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element || !element._owner) {
      return null;
    }
    return element._owner._debugID;
  },
  getParentID: function (id) {
    var item = getItem(id);
    return item ? item.parentID : null;
  },
  getSource: function (id) {
    var item = getItem(id);
    var element = item ? item.element : null;
    var source = element != null ? element._source : null;
    return source;
  },
  getText: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (typeof element === 'string') {
      return element;
    } else if (typeof element === 'number') {
      return '' + element;
    } else {
      return null;
    }
  },
  getUpdateCount: function (id) {
    var item = getItem(id);
    return item ? item.updateCount : 0;
  },


  getRootIDs: getRootIDs,
  getRegisteredIDs: getItemIDs,

  pushNonStandardWarningStack: function (isCreatingElement, currentSource) {
    if (typeof console.reactStack !== 'function') {
      return;
    }

    var stack = [];
    var currentOwner = ReactCurrentOwner.current;
    var id = currentOwner && currentOwner._debugID;

    try {
      if (isCreatingElement) {
        stack.push({
          name: id ? ReactComponentTreeHook.getDisplayName(id) : null,
          fileName: currentSource ? currentSource.fileName : null,
          lineNumber: currentSource ? currentSource.lineNumber : null
        });
      }

      while (id) {
        var element = ReactComponentTreeHook.getElement(id);
        var parentID = ReactComponentTreeHook.getParentID(id);
        var ownerID = ReactComponentTreeHook.getOwnerID(id);
        var ownerName = ownerID ? ReactComponentTreeHook.getDisplayName(ownerID) : null;
        var source = element && element._source;
        stack.push({
          name: ownerName,
          fileName: source ? source.fileName : null,
          lineNumber: source ? source.lineNumber : null
        });
        id = parentID;
      }
    } catch (err) {
      // Internal state is messed up.
      // Stop building the stack (it's just a nice to have).
    }

    console.reactStack(stack);
  },
  popNonStandardWarningStack: function () {
    if (typeof console.reactStackEnd !== 'function') {
      return;
    }
    console.reactStackEnd();
  }
};

module.exports = ReactComponentTreeHook;

/***/ }),
/* 18 */,
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(49);
var defined = __webpack_require__(46);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */


/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

function reactProdInvariant(code) {
  var argCount = arguments.length - 1;

  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

  for (var argIdx = 0; argIdx < argCount; argIdx++) {
    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
  }

  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

  var error = new Error(message);
  error.name = 'Invariant Violation';
  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

  throw error;
}

module.exports = reactProdInvariant;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

module.exports = ReactCurrentOwner;

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(46);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(122)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(47)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(64);


/***/ }),
/* 28 */,
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(6).f;
var has = __webpack_require__(15);
var TAG = __webpack_require__(4)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 30 */,
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(77);
var enumBugKeys = __webpack_require__(52);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 32 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(109);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(11);
var dPs = __webpack_require__(124);
var enumBugKeys = __webpack_require__(52);
var IE_PROTO = __webpack_require__(50)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(58)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(96).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(45);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 38 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(129);
var global = __webpack_require__(5);
var hide = __webpack_require__(13);
var Iterators = __webpack_require__(22);
var TO_STRING_TAG = __webpack_require__(4)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),
/* 40 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var canDefineProperty = false;
if (true) {
  try {
    // $FlowFixMe https://github.com/facebook/flow/issues/285
    Object.defineProperty({}, 'x', { get: function () {} });
    canDefineProperty = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

module.exports = canDefineProperty;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),
/* 43 */,
/* 44 */,
/* 45 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 46 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(42);
var $export = __webpack_require__(3);
var redefine = __webpack_require__(76);
var hide = __webpack_require__(13);
var has = __webpack_require__(15);
var Iterators = __webpack_require__(22);
var $iterCreate = __webpack_require__(123);
var setToStringTag = __webpack_require__(29);
var getPrototypeOf = __webpack_require__(78);
var ITERATOR = __webpack_require__(4)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(9);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(32);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(51)('keys');
var uid = __webpack_require__(38);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(5);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};


/***/ }),
/* 52 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 53 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(4);


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(38)('meta');
var isObject = __webpack_require__(9);
var has = __webpack_require__(15);
var setDesc = __webpack_require__(6).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(14)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(5);
var core = __webpack_require__(2);
var LIBRARY = __webpack_require__(42);
var wksExt = __webpack_require__(54);
var defineProperty = __webpack_require__(6).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

if (true) {
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = lowPriorityWarning;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(9);
var document = __webpack_require__(5).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 59 */,
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(111), __esModule: true };

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof2 = __webpack_require__(70);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};

/***/ }),
/* 62 */
/***/ (function(module, exports) {



/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _setPrototypeOf = __webpack_require__(148);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(151);

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __webpack_require__(70);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(7);

var ReactBaseClasses = __webpack_require__(85);
var ReactChildren = __webpack_require__(153);
var ReactDOMFactories = __webpack_require__(157);
var ReactElement = __webpack_require__(16);
var ReactPropTypes = __webpack_require__(161);
var ReactVersion = __webpack_require__(163);

var createReactClass = __webpack_require__(164);
var onlyChild = __webpack_require__(166);

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

if (true) {
  var lowPriorityWarning = __webpack_require__(57);
  var canDefineProperty = __webpack_require__(41);
  var ReactElementValidator = __webpack_require__(89);
  var didWarnPropTypesDeprecated = false;
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}

var __spread = _assign;
var createMixin = function (mixin) {
  return mixin;
};

if (true) {
  var warnedForSpread = false;
  var warnedForCreateMixin = false;
  __spread = function () {
    lowPriorityWarning(warnedForSpread, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.');
    warnedForSpread = true;
    return _assign.apply(null, arguments);
  };

  createMixin = function (mixin) {
    lowPriorityWarning(warnedForCreateMixin, 'React.createMixin is deprecated and should not be used. ' + 'In React v16.0, it will be removed. ' + 'You can use this mixin directly instead. ' + 'See https://fb.me/createmixin-was-never-implemented for more info.');
    warnedForCreateMixin = true;
    return mixin;
  };
}

var React = {
  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    toArray: ReactChildren.toArray,
    only: onlyChild
  },

  Component: ReactBaseClasses.Component,
  PureComponent: ReactBaseClasses.PureComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: createReactClass,
  createFactory: createFactory,
  createMixin: createMixin,

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOMFactories,

  version: ReactVersion,

  // Deprecated hook for JSX spread, don't use this for anything.
  __spread: __spread
};

if (true) {
  var warnedForCreateClass = false;
  if (canDefineProperty) {
    Object.defineProperty(React, 'PropTypes', {
      get: function () {
        lowPriorityWarning(didWarnPropTypesDeprecated, 'Accessing PropTypes via the main React package is deprecated,' + ' and will be removed in  React v16.0.' + ' Use the latest available v15.* prop-types package from npm instead.' + ' For info on usage, compatibility, migration and more, see ' + 'https://fb.me/prop-types-docs');
        didWarnPropTypesDeprecated = true;
        return ReactPropTypes;
      }
    });

    Object.defineProperty(React, 'createClass', {
      get: function () {
        lowPriorityWarning(warnedForCreateClass, 'Accessing createClass via the main React package is deprecated,' + ' and will be removed in React v16.0.' + " Use a plain JavaScript class instead. If you're not yet " + 'ready to migrate, create-react-class v15.* is available ' + 'on npm as a temporary, drop-in replacement. ' + 'For more info see https://fb.me/react-create-class');
        warnedForCreateClass = true;
        return createReactClass;
      }
    });
  }

  // React.DOM factories are deprecated. Wrap these methods so that
  // invocations of the React.DOM namespace and alert users to switch
  // to the `react-dom-factories` package.
  React.DOM = {};
  var warnedForFactories = false;
  Object.keys(ReactDOMFactories).forEach(function (factory) {
    React.DOM[factory] = function () {
      if (!warnedForFactories) {
        lowPriorityWarning(false, 'Accessing factories like React.DOM.%s has been deprecated ' + 'and will be removed in v16.0+. Use the ' + 'react-dom-factories package instead. ' + ' Version 1.0 provides a drop-in replacement.' + ' For more info, see https://fb.me/react-dom-factories', factory);
        warnedForFactories = true;
      }
      return ReactDOMFactories[factory].apply(ReactDOMFactories, arguments);
    };
  });
}

module.exports = React;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyObject = {};

if (true) {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;

/***/ }),
/* 66 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(141);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(142);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(8) && !__webpack_require__(14)(function () {
  return Object.defineProperty(__webpack_require__(58)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(13);


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(15);
var toIObject = __webpack_require__(19);
var arrayIndexOf = __webpack_require__(125)(false);
var IE_PROTO = __webpack_require__(50)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(15);
var toObject = __webpack_require__(24);
var IE_PROTO = __webpack_require__(50)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 79 */,
/* 80 */,
/* 81 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(32);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(77);
var hiddenKeys = __webpack_require__(52).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(40);
var createDesc = __webpack_require__(26);
var toIObject = __webpack_require__(19);
var toPrimitive = __webpack_require__(48);
var has = __webpack_require__(15);
var IE8_DOM_DEFINE = __webpack_require__(75);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(8) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(20),
    _assign = __webpack_require__(7);

var ReactNoopUpdateQueue = __webpack_require__(86);

var canDefineProperty = __webpack_require__(41);
var emptyObject = __webpack_require__(65);
var invariant = __webpack_require__(0);
var lowPriorityWarning = __webpack_require__(57);

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

ReactComponent.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ?  true ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'forceUpdate');
  }
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
if (true) {
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    if (canDefineProperty) {
      Object.defineProperty(ReactComponent.prototype, methodName, {
        get: function () {
          lowPriorityWarning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
          return undefined;
        }
      });
    }
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

/**
 * Base class helpers for the updating state of a component.
 */
function ReactPureComponent(props, context, updater) {
  // Duplicated from ReactComponent.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

function ComponentDummy() {}
ComponentDummy.prototype = ReactComponent.prototype;
ReactPureComponent.prototype = new ComponentDummy();
ReactPureComponent.prototype.constructor = ReactPureComponent;
// Avoid an extra prototype jump for these methods.
_assign(ReactPureComponent.prototype, ReactComponent.prototype);
ReactPureComponent.prototype.isPureReactComponent = true;

module.exports = {
  Component: ReactComponent,
  PureComponent: ReactPureComponent
};

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var warning = __webpack_require__(1);

function warnNoop(publicInstance, callerName) {
  if (true) {
    var constructor = publicInstance.constructor;
     true ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {},

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    warnNoop(publicInstance, 'setState');
  }
};

module.exports = ReactNoopUpdateQueue;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.

var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

module.exports = REACT_ELEMENT_TYPE;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/* global Symbol */

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */



var ReactCurrentOwner = __webpack_require__(21);
var ReactComponentTreeHook = __webpack_require__(17);
var ReactElement = __webpack_require__(16);

var checkReactTypeSpec = __webpack_require__(158);

var canDefineProperty = __webpack_require__(41);
var getIteratorFn = __webpack_require__(88);
var warning = __webpack_require__(1);
var lowPriorityWarning = __webpack_require__(57);

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = ReactCurrentOwner.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

function getSourceInfoErrorAddendum(elementProps) {
  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
    var source = elementProps.__source;
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return ' Check your code at ' + fileName + ':' + lineNumber + '.';
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = ' Check the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (memoizer[currentComponentErrorInfo]) {
    return;
  }
  memoizer[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
  }

   true ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement.isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
     true ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
  }
}

var ReactElementValidator = {
  createElement: function (type, props, children) {
    var validType = typeof type === 'string' || typeof type === 'function';
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    if (!validType) {
      if (typeof type !== 'function' && typeof type !== 'string') {
        var info = '';
        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in.";
        }

        var sourceInfo = getSourceInfoErrorAddendum(props);
        if (sourceInfo) {
          info += sourceInfo;
        } else {
          info += getDeclarationErrorAddendum();
        }

        info += ReactComponentTreeHook.getCurrentStackAddendum();

        var currentSource = props !== null && props !== undefined && props.__source !== undefined ? props.__source : null;
        ReactComponentTreeHook.pushNonStandardWarningStack(true, currentSource);
         true ? warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info) : void 0;
        ReactComponentTreeHook.popNonStandardWarningStack();
      }
    }

    var element = ReactElement.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)
    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    validatePropTypes(element);

    return element;
  },

  createFactory: function (type) {
    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    if (true) {
      if (canDefineProperty) {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function () {
            lowPriorityWarning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
    }

    return validatedFactory;
  },

  cloneElement: function (element, props, children) {
    var newElement = ReactElement.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }
};

module.exports = ReactElementValidator;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(23);
var invariant = __webpack_require__(0);
var warning = __webpack_require__(1);

var ReactPropTypesSecret = __webpack_require__(91);
var checkPropTypes = __webpack_require__(162);

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(
            false,
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
        } else if ("development" !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            warning(
              false,
              'You are manually calling a React.PropTypes validation ' +
              'function for the `%s` prop on `%s`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
              propFullName,
              componentName
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
       true ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(
          false,
          'Invalid argument supplid to oneOfType. Expected an array of check functions, but ' +
          'received %s at index %s.',
          getPostfixForTypeWarning(checker),
          i
        );
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 92 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(5).document;
module.exports = document && document.documentElement;


/***/ }),
/* 97 */,
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(137), __esModule: true };

/***/ }),
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(3);
var core = __webpack_require__(2);
var fails = __webpack_require__(14);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(132);
exports.encode = exports.stringify = __webpack_require__(133);


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(110), __esModule: true };

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(135);
var $Object = __webpack_require__(2).Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(140);
module.exports = __webpack_require__(2).Object.getPrototypeOf;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(25);
__webpack_require__(39);
module.exports = __webpack_require__(54).f('iterator');


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(143);
__webpack_require__(62);
__webpack_require__(146);
__webpack_require__(147);
module.exports = __webpack_require__(2).Symbol;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(149);
module.exports = __webpack_require__(2).Object.setPrototypeOf;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(152);
var $Object = __webpack_require__(2).Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



// React 15.5 references this module, and assumes PropTypes are still callable in production.
// Therefore we re-export development-only version with all the PropTypes checks here.
// However if one is migrating to the `prop-types` npm library, they will go through the
// `index.js` entry point, and it will branch depending on the environment.
var factory = __webpack_require__(90);
module.exports = function(isValidElement) {
  // It is still allowed in 15.5.
  var throwOnDirectAccess = false;
  return factory(isValidElement, throwOnDirectAccess);
};


/***/ }),
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(45);
var defined = __webpack_require__(46);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(36);
var descriptor = __webpack_require__(26);
var setToStringTag = __webpack_require__(29);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(13)(IteratorPrototype, __webpack_require__(4)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(6);
var anObject = __webpack_require__(11);
var getKeys = __webpack_require__(31);

module.exports = __webpack_require__(8) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(19);
var toLength = __webpack_require__(37);
var toAbsoluteIndex = __webpack_require__(126);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(45);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 127 */,
/* 128 */,
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(130);
var step = __webpack_require__(81);
var Iterators = __webpack_require__(22);
var toIObject = __webpack_require__(19);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(47)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 130 */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),
/* 131 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 134 */,
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(3);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(8), 'Object', { defineProperty: __webpack_require__(6).f });


/***/ }),
/* 136 */,
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(138);
module.exports = __webpack_require__(2).Object.assign;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(3);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(139) });


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(31);
var gOPS = __webpack_require__(53);
var pIE = __webpack_require__(40);
var toObject = __webpack_require__(24);
var IObject = __webpack_require__(49);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(14)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(24);
var $getPrototypeOf = __webpack_require__(78);

__webpack_require__(107)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(112), __esModule: true };

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(113), __esModule: true };

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(5);
var has = __webpack_require__(15);
var DESCRIPTORS = __webpack_require__(8);
var $export = __webpack_require__(3);
var redefine = __webpack_require__(76);
var META = __webpack_require__(55).KEY;
var $fails = __webpack_require__(14);
var shared = __webpack_require__(51);
var setToStringTag = __webpack_require__(29);
var uid = __webpack_require__(38);
var wks = __webpack_require__(4);
var wksExt = __webpack_require__(54);
var wksDefine = __webpack_require__(56);
var enumKeys = __webpack_require__(144);
var isArray = __webpack_require__(82);
var anObject = __webpack_require__(11);
var toIObject = __webpack_require__(19);
var toPrimitive = __webpack_require__(48);
var createDesc = __webpack_require__(26);
var _create = __webpack_require__(36);
var gOPNExt = __webpack_require__(145);
var $GOPD = __webpack_require__(84);
var $DP = __webpack_require__(6);
var $keys = __webpack_require__(31);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(83).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(40).f = $propertyIsEnumerable;
  __webpack_require__(53).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(42)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    replacer = args[1];
    if (typeof replacer == 'function') $replacer = replacer;
    if ($replacer || !isArray(replacer)) replacer = function (key, value) {
      if ($replacer) value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(13)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(31);
var gOPS = __webpack_require__(53);
var pIE = __webpack_require__(40);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(19);
var gOPN = __webpack_require__(83).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(56)('asyncIterator');


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(56)('observable');


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(114), __esModule: true };

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(3);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(150).set });


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(9);
var anObject = __webpack_require__(11);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(12)(Function.call, __webpack_require__(84).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(115), __esModule: true };

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(3);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(36) });


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var PooledClass = __webpack_require__(154);
var ReactElement = __webpack_require__(16);

var emptyFunction = __webpack_require__(23);
var traverseAllChildren = __webpack_require__(155);

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var fourArgumentPooler = PooledClass.fourArgumentPooler;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
ForEachBookKeeping.prototype.destructor = function () {
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function () {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (ReactElement.isValidElement(mappedChild)) {
      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
  count: countChildren,
  toArray: toArray
};

module.exports = ReactChildren;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(20);

var invariant = __webpack_require__(0);

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ?  true ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances.
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler
};

module.exports = PooledClass;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(20);

var ReactCurrentOwner = __webpack_require__(21);
var REACT_ELEMENT_TYPE = __webpack_require__(87);

var getIteratorFn = __webpack_require__(88);
var invariant = __webpack_require__(0);
var KeyEscapeUtils = __webpack_require__(156);
var warning = __webpack_require__(1);

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if (true) {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
           true ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if (true) {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = " It looks like you're using an element created by a different " + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
       true ?  true ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * Unescape and unwrap key for human-readable display
 *
 * @param {string} key to unescape.
 * @return {string} the unescaped key.
 */
function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}

var KeyEscapeUtils = {
  escape: escape,
  unescape: unescape
};

module.exports = KeyEscapeUtils;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactElement = __webpack_require__(16);

/**
 * Create a factory that creates HTML tag elements.
 *
 * @private
 */
var createDOMFactory = ReactElement.createFactory;
if (true) {
  var ReactElementValidator = __webpack_require__(89);
  createDOMFactory = ReactElementValidator.createFactory;
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 *
 * @public
 */
var ReactDOMFactories = {
  a: createDOMFactory('a'),
  abbr: createDOMFactory('abbr'),
  address: createDOMFactory('address'),
  area: createDOMFactory('area'),
  article: createDOMFactory('article'),
  aside: createDOMFactory('aside'),
  audio: createDOMFactory('audio'),
  b: createDOMFactory('b'),
  base: createDOMFactory('base'),
  bdi: createDOMFactory('bdi'),
  bdo: createDOMFactory('bdo'),
  big: createDOMFactory('big'),
  blockquote: createDOMFactory('blockquote'),
  body: createDOMFactory('body'),
  br: createDOMFactory('br'),
  button: createDOMFactory('button'),
  canvas: createDOMFactory('canvas'),
  caption: createDOMFactory('caption'),
  cite: createDOMFactory('cite'),
  code: createDOMFactory('code'),
  col: createDOMFactory('col'),
  colgroup: createDOMFactory('colgroup'),
  data: createDOMFactory('data'),
  datalist: createDOMFactory('datalist'),
  dd: createDOMFactory('dd'),
  del: createDOMFactory('del'),
  details: createDOMFactory('details'),
  dfn: createDOMFactory('dfn'),
  dialog: createDOMFactory('dialog'),
  div: createDOMFactory('div'),
  dl: createDOMFactory('dl'),
  dt: createDOMFactory('dt'),
  em: createDOMFactory('em'),
  embed: createDOMFactory('embed'),
  fieldset: createDOMFactory('fieldset'),
  figcaption: createDOMFactory('figcaption'),
  figure: createDOMFactory('figure'),
  footer: createDOMFactory('footer'),
  form: createDOMFactory('form'),
  h1: createDOMFactory('h1'),
  h2: createDOMFactory('h2'),
  h3: createDOMFactory('h3'),
  h4: createDOMFactory('h4'),
  h5: createDOMFactory('h5'),
  h6: createDOMFactory('h6'),
  head: createDOMFactory('head'),
  header: createDOMFactory('header'),
  hgroup: createDOMFactory('hgroup'),
  hr: createDOMFactory('hr'),
  html: createDOMFactory('html'),
  i: createDOMFactory('i'),
  iframe: createDOMFactory('iframe'),
  img: createDOMFactory('img'),
  input: createDOMFactory('input'),
  ins: createDOMFactory('ins'),
  kbd: createDOMFactory('kbd'),
  keygen: createDOMFactory('keygen'),
  label: createDOMFactory('label'),
  legend: createDOMFactory('legend'),
  li: createDOMFactory('li'),
  link: createDOMFactory('link'),
  main: createDOMFactory('main'),
  map: createDOMFactory('map'),
  mark: createDOMFactory('mark'),
  menu: createDOMFactory('menu'),
  menuitem: createDOMFactory('menuitem'),
  meta: createDOMFactory('meta'),
  meter: createDOMFactory('meter'),
  nav: createDOMFactory('nav'),
  noscript: createDOMFactory('noscript'),
  object: createDOMFactory('object'),
  ol: createDOMFactory('ol'),
  optgroup: createDOMFactory('optgroup'),
  option: createDOMFactory('option'),
  output: createDOMFactory('output'),
  p: createDOMFactory('p'),
  param: createDOMFactory('param'),
  picture: createDOMFactory('picture'),
  pre: createDOMFactory('pre'),
  progress: createDOMFactory('progress'),
  q: createDOMFactory('q'),
  rp: createDOMFactory('rp'),
  rt: createDOMFactory('rt'),
  ruby: createDOMFactory('ruby'),
  s: createDOMFactory('s'),
  samp: createDOMFactory('samp'),
  script: createDOMFactory('script'),
  section: createDOMFactory('section'),
  select: createDOMFactory('select'),
  small: createDOMFactory('small'),
  source: createDOMFactory('source'),
  span: createDOMFactory('span'),
  strong: createDOMFactory('strong'),
  style: createDOMFactory('style'),
  sub: createDOMFactory('sub'),
  summary: createDOMFactory('summary'),
  sup: createDOMFactory('sup'),
  table: createDOMFactory('table'),
  tbody: createDOMFactory('tbody'),
  td: createDOMFactory('td'),
  textarea: createDOMFactory('textarea'),
  tfoot: createDOMFactory('tfoot'),
  th: createDOMFactory('th'),
  thead: createDOMFactory('thead'),
  time: createDOMFactory('time'),
  title: createDOMFactory('title'),
  tr: createDOMFactory('tr'),
  track: createDOMFactory('track'),
  u: createDOMFactory('u'),
  ul: createDOMFactory('ul'),
  'var': createDOMFactory('var'),
  video: createDOMFactory('video'),
  wbr: createDOMFactory('wbr'),

  // SVG
  circle: createDOMFactory('circle'),
  clipPath: createDOMFactory('clipPath'),
  defs: createDOMFactory('defs'),
  ellipse: createDOMFactory('ellipse'),
  g: createDOMFactory('g'),
  image: createDOMFactory('image'),
  line: createDOMFactory('line'),
  linearGradient: createDOMFactory('linearGradient'),
  mask: createDOMFactory('mask'),
  path: createDOMFactory('path'),
  pattern: createDOMFactory('pattern'),
  polygon: createDOMFactory('polygon'),
  polyline: createDOMFactory('polyline'),
  radialGradient: createDOMFactory('radialGradient'),
  rect: createDOMFactory('rect'),
  stop: createDOMFactory('stop'),
  svg: createDOMFactory('svg'),
  text: createDOMFactory('text'),
  tspan: createDOMFactory('tspan')
};

module.exports = ReactDOMFactories;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(20);

var ReactPropTypeLocationNames = __webpack_require__(159);
var ReactPropTypesSecret = __webpack_require__(160);

var invariant = __webpack_require__(0);
var warning = __webpack_require__(1);

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && "development" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = __webpack_require__(17);
}

var loggedTypeFailures = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ?  true ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
       true ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var componentStackInfo = '';

        if (true) {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = __webpack_require__(17);
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
          }
        }

         true ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}

module.exports = checkReactTypeSpec;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(66)))

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypeLocationNames = {};

if (true) {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _require = __webpack_require__(16),
    isValidElement = _require.isValidElement;

var factory = __webpack_require__(116);

module.exports = factory(isValidElement);

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



if (true) {
  var invariant = __webpack_require__(0);
  var warning = __webpack_require__(1);
  var ReactPropTypesSecret = __webpack_require__(91);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', location, typeSpecName);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



module.exports = '15.6.1';

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _require = __webpack_require__(85),
    Component = _require.Component;

var _require2 = __webpack_require__(16),
    isValidElement = _require2.isValidElement;

var ReactNoopUpdateQueue = __webpack_require__(86);
var factory = __webpack_require__(165);

module.exports = factory(Component, isValidElement, ReactNoopUpdateQueue);

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(7);

var emptyObject = __webpack_require__(65);
var _invariant = __webpack_require__(0);

if (true) {
  var warning = __webpack_require__(1);
}

var MIXINS_KEY = 'mixins';

// Helper function to allow the creation of anonymous functions which do not
// have .name set to the name of the variable being assigned to.
function identity(fn) {
  return fn;
}

var ReactPropTypeLocationNames;
if (true) {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
} else {
  ReactPropTypeLocationNames = {};
}

function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
  /**
   * Policies that describe methods in `ReactClassInterface`.
   */

  var injectedMixins = [];

  /**
   * Composite components are higher-level components that compose other composite
   * or host components.
   *
   * To create a new type of `ReactClass`, pass a specification of
   * your new class to `React.createClass`. The only requirement of your class
   * specification is that you implement a `render` method.
   *
   *   var MyComponent = React.createClass({
   *     render: function() {
   *       return <div>Hello World</div>;
   *     }
   *   });
   *
   * The class specification supports a specific protocol of methods that have
   * special meaning (e.g. `render`). See `ReactClassInterface` for
   * more the comprehensive protocol. Any other properties and methods in the
   * class specification will be available on the prototype.
   *
   * @interface ReactClassInterface
   * @internal
   */
  var ReactClassInterface = {
    /**
     * An array of Mixin objects to include when defining your component.
     *
     * @type {array}
     * @optional
     */
    mixins: 'DEFINE_MANY',

    /**
     * An object containing properties and methods that should be defined on
     * the component's constructor instead of its prototype (static methods).
     *
     * @type {object}
     * @optional
     */
    statics: 'DEFINE_MANY',

    /**
     * Definition of prop types for this component.
     *
     * @type {object}
     * @optional
     */
    propTypes: 'DEFINE_MANY',

    /**
     * Definition of context types for this component.
     *
     * @type {object}
     * @optional
     */
    contextTypes: 'DEFINE_MANY',

    /**
     * Definition of context types this component sets for its children.
     *
     * @type {object}
     * @optional
     */
    childContextTypes: 'DEFINE_MANY',

    // ==== Definition methods ====

    /**
     * Invoked when the component is mounted. Values in the mapping will be set on
     * `this.props` if that prop is not specified (i.e. using an `in` check).
     *
     * This method is invoked before `getInitialState` and therefore cannot rely
     * on `this.state` or use `this.setState`.
     *
     * @return {object}
     * @optional
     */
    getDefaultProps: 'DEFINE_MANY_MERGED',

    /**
     * Invoked once before the component is mounted. The return value will be used
     * as the initial value of `this.state`.
     *
     *   getInitialState: function() {
     *     return {
     *       isOn: false,
     *       fooBaz: new BazFoo()
     *     }
     *   }
     *
     * @return {object}
     * @optional
     */
    getInitialState: 'DEFINE_MANY_MERGED',

    /**
     * @return {object}
     * @optional
     */
    getChildContext: 'DEFINE_MANY_MERGED',

    /**
     * Uses props from `this.props` and state from `this.state` to render the
     * structure of the component.
     *
     * No guarantees are made about when or how often this method is invoked, so
     * it must not have side effects.
     *
     *   render: function() {
     *     var name = this.props.name;
     *     return <div>Hello, {name}!</div>;
     *   }
     *
     * @return {ReactComponent}
     * @required
     */
    render: 'DEFINE_ONCE',

    // ==== Delegate methods ====

    /**
     * Invoked when the component is initially created and about to be mounted.
     * This may have side effects, but any external subscriptions or data created
     * by this method must be cleaned up in `componentWillUnmount`.
     *
     * @optional
     */
    componentWillMount: 'DEFINE_MANY',

    /**
     * Invoked when the component has been mounted and has a DOM representation.
     * However, there is no guarantee that the DOM node is in the document.
     *
     * Use this as an opportunity to operate on the DOM when the component has
     * been mounted (initialized and rendered) for the first time.
     *
     * @param {DOMElement} rootNode DOM element representing the component.
     * @optional
     */
    componentDidMount: 'DEFINE_MANY',

    /**
     * Invoked before the component receives new props.
     *
     * Use this as an opportunity to react to a prop transition by updating the
     * state using `this.setState`. Current props are accessed via `this.props`.
     *
     *   componentWillReceiveProps: function(nextProps, nextContext) {
     *     this.setState({
     *       likesIncreasing: nextProps.likeCount > this.props.likeCount
     *     });
     *   }
     *
     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
     * transition may cause a state change, but the opposite is not true. If you
     * need it, you are probably looking for `componentWillUpdate`.
     *
     * @param {object} nextProps
     * @optional
     */
    componentWillReceiveProps: 'DEFINE_MANY',

    /**
     * Invoked while deciding if the component should be updated as a result of
     * receiving new props, state and/or context.
     *
     * Use this as an opportunity to `return false` when you're certain that the
     * transition to the new props/state/context will not require a component
     * update.
     *
     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
     *     return !equal(nextProps, this.props) ||
     *       !equal(nextState, this.state) ||
     *       !equal(nextContext, this.context);
     *   }
     *
     * @param {object} nextProps
     * @param {?object} nextState
     * @param {?object} nextContext
     * @return {boolean} True if the component should update.
     * @optional
     */
    shouldComponentUpdate: 'DEFINE_ONCE',

    /**
     * Invoked when the component is about to update due to a transition from
     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
     * and `nextContext`.
     *
     * Use this as an opportunity to perform preparation before an update occurs.
     *
     * NOTE: You **cannot** use `this.setState()` in this method.
     *
     * @param {object} nextProps
     * @param {?object} nextState
     * @param {?object} nextContext
     * @param {ReactReconcileTransaction} transaction
     * @optional
     */
    componentWillUpdate: 'DEFINE_MANY',

    /**
     * Invoked when the component's DOM representation has been updated.
     *
     * Use this as an opportunity to operate on the DOM when the component has
     * been updated.
     *
     * @param {object} prevProps
     * @param {?object} prevState
     * @param {?object} prevContext
     * @param {DOMElement} rootNode DOM element representing the component.
     * @optional
     */
    componentDidUpdate: 'DEFINE_MANY',

    /**
     * Invoked when the component is about to be removed from its parent and have
     * its DOM representation destroyed.
     *
     * Use this as an opportunity to deallocate any external resources.
     *
     * NOTE: There is no `componentDidUnmount` since your component will have been
     * destroyed by that point.
     *
     * @optional
     */
    componentWillUnmount: 'DEFINE_MANY',

    // ==== Advanced methods ====

    /**
     * Updates the component's currently mounted DOM representation.
     *
     * By default, this implements React's rendering and reconciliation algorithm.
     * Sophisticated clients may wish to override this.
     *
     * @param {ReactReconcileTransaction} transaction
     * @internal
     * @overridable
     */
    updateComponent: 'OVERRIDE_BASE'
  };

  /**
   * Mapping from class specification keys to special processing functions.
   *
   * Although these are declared like instance properties in the specification
   * when defining classes using `React.createClass`, they are actually static
   * and are accessible on the constructor instead of the prototype. Despite
   * being static, they must be defined outside of the "statics" key under
   * which all other static methods are defined.
   */
  var RESERVED_SPEC_KEYS = {
    displayName: function(Constructor, displayName) {
      Constructor.displayName = displayName;
    },
    mixins: function(Constructor, mixins) {
      if (mixins) {
        for (var i = 0; i < mixins.length; i++) {
          mixSpecIntoComponent(Constructor, mixins[i]);
        }
      }
    },
    childContextTypes: function(Constructor, childContextTypes) {
      if (true) {
        validateTypeDef(Constructor, childContextTypes, 'childContext');
      }
      Constructor.childContextTypes = _assign(
        {},
        Constructor.childContextTypes,
        childContextTypes
      );
    },
    contextTypes: function(Constructor, contextTypes) {
      if (true) {
        validateTypeDef(Constructor, contextTypes, 'context');
      }
      Constructor.contextTypes = _assign(
        {},
        Constructor.contextTypes,
        contextTypes
      );
    },
    /**
     * Special case getDefaultProps which should move into statics but requires
     * automatic merging.
     */
    getDefaultProps: function(Constructor, getDefaultProps) {
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps = createMergedResultFunction(
          Constructor.getDefaultProps,
          getDefaultProps
        );
      } else {
        Constructor.getDefaultProps = getDefaultProps;
      }
    },
    propTypes: function(Constructor, propTypes) {
      if (true) {
        validateTypeDef(Constructor, propTypes, 'prop');
      }
      Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
    },
    statics: function(Constructor, statics) {
      mixStaticSpecIntoComponent(Constructor, statics);
    },
    autobind: function() {}
  };

  function validateTypeDef(Constructor, typeDef, location) {
    for (var propName in typeDef) {
      if (typeDef.hasOwnProperty(propName)) {
        // use a warning instead of an _invariant so components
        // don't show up in prod but only in __DEV__
        if (true) {
          warning(
            typeof typeDef[propName] === 'function',
            '%s: %s type `%s` is invalid; it must be a function, usually from ' +
              'React.PropTypes.',
            Constructor.displayName || 'ReactClass',
            ReactPropTypeLocationNames[location],
            propName
          );
        }
      }
    }
  }

  function validateMethodOverride(isAlreadyDefined, name) {
    var specPolicy = ReactClassInterface.hasOwnProperty(name)
      ? ReactClassInterface[name]
      : null;

    // Disallow overriding of base class methods unless explicitly allowed.
    if (ReactClassMixin.hasOwnProperty(name)) {
      _invariant(
        specPolicy === 'OVERRIDE_BASE',
        'ReactClassInterface: You are attempting to override ' +
          '`%s` from your class specification. Ensure that your method names ' +
          'do not overlap with React methods.',
        name
      );
    }

    // Disallow defining methods more than once unless explicitly allowed.
    if (isAlreadyDefined) {
      _invariant(
        specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED',
        'ReactClassInterface: You are attempting to define ' +
          '`%s` on your component more than once. This conflict may be due ' +
          'to a mixin.',
        name
      );
    }
  }

  /**
   * Mixin helper which handles policy validation and reserved
   * specification keys when building React classes.
   */
  function mixSpecIntoComponent(Constructor, spec) {
    if (!spec) {
      if (true) {
        var typeofSpec = typeof spec;
        var isMixinValid = typeofSpec === 'object' && spec !== null;

        if (true) {
          warning(
            isMixinValid,
            "%s: You're attempting to include a mixin that is either null " +
              'or not an object. Check the mixins included by the component, ' +
              'as well as any mixins they include themselves. ' +
              'Expected object but got %s.',
            Constructor.displayName || 'ReactClass',
            spec === null ? null : typeofSpec
          );
        }
      }

      return;
    }

    _invariant(
      typeof spec !== 'function',
      "ReactClass: You're attempting to " +
        'use a component class or function as a mixin. Instead, just use a ' +
        'regular object.'
    );
    _invariant(
      !isValidElement(spec),
      "ReactClass: You're attempting to " +
        'use a component as a mixin. Instead, just use a regular object.'
    );

    var proto = Constructor.prototype;
    var autoBindPairs = proto.__reactAutoBindPairs;

    // By handling mixins before any other properties, we ensure the same
    // chaining order is applied to methods with DEFINE_MANY policy, whether
    // mixins are listed before or after these methods in the spec.
    if (spec.hasOwnProperty(MIXINS_KEY)) {
      RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
    }

    for (var name in spec) {
      if (!spec.hasOwnProperty(name)) {
        continue;
      }

      if (name === MIXINS_KEY) {
        // We have already handled mixins in a special case above.
        continue;
      }

      var property = spec[name];
      var isAlreadyDefined = proto.hasOwnProperty(name);
      validateMethodOverride(isAlreadyDefined, name);

      if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
        RESERVED_SPEC_KEYS[name](Constructor, property);
      } else {
        // Setup methods on prototype:
        // The following member methods should not be automatically bound:
        // 1. Expected ReactClass methods (in the "interface").
        // 2. Overridden methods (that were mixed in).
        var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
        var isFunction = typeof property === 'function';
        var shouldAutoBind =
          isFunction &&
          !isReactClassMethod &&
          !isAlreadyDefined &&
          spec.autobind !== false;

        if (shouldAutoBind) {
          autoBindPairs.push(name, property);
          proto[name] = property;
        } else {
          if (isAlreadyDefined) {
            var specPolicy = ReactClassInterface[name];

            // These cases should already be caught by validateMethodOverride.
            _invariant(
              isReactClassMethod &&
                (specPolicy === 'DEFINE_MANY_MERGED' ||
                  specPolicy === 'DEFINE_MANY'),
              'ReactClass: Unexpected spec policy %s for key %s ' +
                'when mixing in component specs.',
              specPolicy,
              name
            );

            // For methods which are defined more than once, call the existing
            // methods before calling the new property, merging if appropriate.
            if (specPolicy === 'DEFINE_MANY_MERGED') {
              proto[name] = createMergedResultFunction(proto[name], property);
            } else if (specPolicy === 'DEFINE_MANY') {
              proto[name] = createChainedFunction(proto[name], property);
            }
          } else {
            proto[name] = property;
            if (true) {
              // Add verbose displayName to the function, which helps when looking
              // at profiling tools.
              if (typeof property === 'function' && spec.displayName) {
                proto[name].displayName = spec.displayName + '_' + name;
              }
            }
          }
        }
      }
    }
  }

  function mixStaticSpecIntoComponent(Constructor, statics) {
    if (!statics) {
      return;
    }
    for (var name in statics) {
      var property = statics[name];
      if (!statics.hasOwnProperty(name)) {
        continue;
      }

      var isReserved = name in RESERVED_SPEC_KEYS;
      _invariant(
        !isReserved,
        'ReactClass: You are attempting to define a reserved ' +
          'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' +
          'as an instance property instead; it will still be accessible on the ' +
          'constructor.',
        name
      );

      var isInherited = name in Constructor;
      _invariant(
        !isInherited,
        'ReactClass: You are attempting to define ' +
          '`%s` on your component more than once. This conflict may be ' +
          'due to a mixin.',
        name
      );
      Constructor[name] = property;
    }
  }

  /**
   * Merge two objects, but throw if both contain the same key.
   *
   * @param {object} one The first object, which is mutated.
   * @param {object} two The second object
   * @return {object} one after it has been mutated to contain everything in two.
   */
  function mergeIntoWithNoDuplicateKeys(one, two) {
    _invariant(
      one && two && typeof one === 'object' && typeof two === 'object',
      'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.'
    );

    for (var key in two) {
      if (two.hasOwnProperty(key)) {
        _invariant(
          one[key] === undefined,
          'mergeIntoWithNoDuplicateKeys(): ' +
            'Tried to merge two objects with the same key: `%s`. This conflict ' +
            'may be due to a mixin; in particular, this may be caused by two ' +
            'getInitialState() or getDefaultProps() methods returning objects ' +
            'with clashing keys.',
          key
        );
        one[key] = two[key];
      }
    }
    return one;
  }

  /**
   * Creates a function that invokes two functions and merges their return values.
   *
   * @param {function} one Function to invoke first.
   * @param {function} two Function to invoke second.
   * @return {function} Function that invokes the two argument functions.
   * @private
   */
  function createMergedResultFunction(one, two) {
    return function mergedResult() {
      var a = one.apply(this, arguments);
      var b = two.apply(this, arguments);
      if (a == null) {
        return b;
      } else if (b == null) {
        return a;
      }
      var c = {};
      mergeIntoWithNoDuplicateKeys(c, a);
      mergeIntoWithNoDuplicateKeys(c, b);
      return c;
    };
  }

  /**
   * Creates a function that invokes two functions and ignores their return vales.
   *
   * @param {function} one Function to invoke first.
   * @param {function} two Function to invoke second.
   * @return {function} Function that invokes the two argument functions.
   * @private
   */
  function createChainedFunction(one, two) {
    return function chainedFunction() {
      one.apply(this, arguments);
      two.apply(this, arguments);
    };
  }

  /**
   * Binds a method to the component.
   *
   * @param {object} component Component whose method is going to be bound.
   * @param {function} method Method to be bound.
   * @return {function} The bound method.
   */
  function bindAutoBindMethod(component, method) {
    var boundMethod = method.bind(component);
    if (true) {
      boundMethod.__reactBoundContext = component;
      boundMethod.__reactBoundMethod = method;
      boundMethod.__reactBoundArguments = null;
      var componentName = component.constructor.displayName;
      var _bind = boundMethod.bind;
      boundMethod.bind = function(newThis) {
        for (
          var _len = arguments.length,
            args = Array(_len > 1 ? _len - 1 : 0),
            _key = 1;
          _key < _len;
          _key++
        ) {
          args[_key - 1] = arguments[_key];
        }

        // User is trying to bind() an autobound method; we effectively will
        // ignore the value of "this" that the user is trying to use, so
        // let's warn.
        if (newThis !== component && newThis !== null) {
          if (true) {
            warning(
              false,
              'bind(): React component methods may only be bound to the ' +
                'component instance. See %s',
              componentName
            );
          }
        } else if (!args.length) {
          if (true) {
            warning(
              false,
              'bind(): You are binding a component method to the component. ' +
                'React does this for you automatically in a high-performance ' +
                'way, so you can safely remove this call. See %s',
              componentName
            );
          }
          return boundMethod;
        }
        var reboundMethod = _bind.apply(boundMethod, arguments);
        reboundMethod.__reactBoundContext = component;
        reboundMethod.__reactBoundMethod = method;
        reboundMethod.__reactBoundArguments = args;
        return reboundMethod;
      };
    }
    return boundMethod;
  }

  /**
   * Binds all auto-bound methods in a component.
   *
   * @param {object} component Component whose method is going to be bound.
   */
  function bindAutoBindMethods(component) {
    var pairs = component.__reactAutoBindPairs;
    for (var i = 0; i < pairs.length; i += 2) {
      var autoBindKey = pairs[i];
      var method = pairs[i + 1];
      component[autoBindKey] = bindAutoBindMethod(component, method);
    }
  }

  var IsMountedPreMixin = {
    componentDidMount: function() {
      this.__isMounted = true;
    }
  };

  var IsMountedPostMixin = {
    componentWillUnmount: function() {
      this.__isMounted = false;
    }
  };

  /**
   * Add more to the ReactClass base class. These are all legacy features and
   * therefore not already part of the modern ReactComponent.
   */
  var ReactClassMixin = {
    /**
     * TODO: This will be deprecated because state should always keep a consistent
     * type signature and the only use case for this, is to avoid that.
     */
    replaceState: function(newState, callback) {
      this.updater.enqueueReplaceState(this, newState, callback);
    },

    /**
     * Checks whether or not this composite component is mounted.
     * @return {boolean} True if mounted, false otherwise.
     * @protected
     * @final
     */
    isMounted: function() {
      if (true) {
        warning(
          this.__didWarnIsMounted,
          '%s: isMounted is deprecated. Instead, make sure to clean up ' +
            'subscriptions and pending requests in componentWillUnmount to ' +
            'prevent memory leaks.',
          (this.constructor && this.constructor.displayName) ||
            this.name ||
            'Component'
        );
        this.__didWarnIsMounted = true;
      }
      return !!this.__isMounted;
    }
  };

  var ReactClassComponent = function() {};
  _assign(
    ReactClassComponent.prototype,
    ReactComponent.prototype,
    ReactClassMixin
  );

  /**
   * Creates a composite component class given a class specification.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  function createClass(spec) {
    // To keep our warnings more understandable, we'll use a little hack here to
    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
    // unnecessarily identify a class without displayName as 'Constructor'.
    var Constructor = identity(function(props, context, updater) {
      // This constructor gets overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if (true) {
        warning(
          this instanceof Constructor,
          'Something is calling a React component directly. Use a factory or ' +
            'JSX instead. See: https://fb.me/react-legacyfactory'
        );
      }

      // Wire up auto-binding
      if (this.__reactAutoBindPairs.length) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if (true) {
        // We allow auto-mocks to proceed as if they're returning null.
        if (
          initialState === undefined &&
          this.getInitialState._isMockFunction
        ) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      _invariant(
        typeof initialState === 'object' && !Array.isArray(initialState),
        '%s.getInitialState(): must return an object or null',
        Constructor.displayName || 'ReactCompositeComponent'
      );

      this.state = initialState;
    });
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, IsMountedPreMixin);
    mixSpecIntoComponent(Constructor, spec);
    mixSpecIntoComponent(Constructor, IsMountedPostMixin);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if (true) {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    _invariant(
      Constructor.prototype.render,
      'createClass(...): Class specification must implement a `render` method.'
    );

    if (true) {
      warning(
        !Constructor.prototype.componentShouldUpdate,
        '%s has a method called ' +
          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +
          'The name is phrased as a question because the function is ' +
          'expected to return a value.',
        spec.displayName || 'A component'
      );
      warning(
        !Constructor.prototype.componentWillRecieveProps,
        '%s has a method called ' +
          'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',
        spec.displayName || 'A component'
      );
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  }

  return createClass;
}

module.exports = factory;


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */


var _prodInvariant = __webpack_require__(20);

var ReactElement = __webpack_require__(16);

var invariant = __webpack_require__(0);

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !ReactElement.isValidElement(children) ?  true ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
  return children;
}

module.exports = onlyChild;

/***/ }),
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */,
/* 377 */,
/* 378 */,
/* 379 */,
/* 380 */,
/* 381 */,
/* 382 */,
/* 383 */,
/* 384 */,
/* 385 */,
/* 386 */,
/* 387 */,
/* 388 */,
/* 389 */,
/* 390 */,
/* 391 */,
/* 392 */,
/* 393 */,
/* 394 */,
/* 395 */,
/* 396 */,
/* 397 */,
/* 398 */,
/* 399 */,
/* 400 */,
/* 401 */,
/* 402 */,
/* 403 */,
/* 404 */,
/* 405 */,
/* 406 */,
/* 407 */,
/* 408 */,
/* 409 */,
/* 410 */,
/* 411 */,
/* 412 */,
/* 413 */,
/* 414 */,
/* 415 */,
/* 416 */,
/* 417 */,
/* 418 */,
/* 419 */,
/* 420 */,
/* 421 */,
/* 422 */,
/* 423 */,
/* 424 */,
/* 425 */,
/* 426 */,
/* 427 */,
/* 428 */,
/* 429 */,
/* 430 */,
/* 431 */,
/* 432 */,
/* 433 */,
/* 434 */,
/* 435 */,
/* 436 */,
/* 437 */,
/* 438 */,
/* 439 */,
/* 440 */,
/* 441 */,
/* 442 */,
/* 443 */,
/* 444 */,
/* 445 */,
/* 446 */,
/* 447 */,
/* 448 */,
/* 449 */,
/* 450 */,
/* 451 */,
/* 452 */,
/* 453 */,
/* 454 */,
/* 455 */,
/* 456 */,
/* 457 */,
/* 458 */,
/* 459 */,
/* 460 */,
/* 461 */,
/* 462 */,
/* 463 */,
/* 464 */,
/* 465 */,
/* 466 */,
/* 467 */,
/* 468 */,
/* 469 */,
/* 470 */,
/* 471 */,
/* 472 */,
/* 473 */,
/* 474 */,
/* 475 */,
/* 476 */,
/* 477 */,
/* 478 */,
/* 479 */,
/* 480 */,
/* 481 */,
/* 482 */,
/* 483 */,
/* 484 */,
/* 485 */,
/* 486 */,
/* 487 */,
/* 488 */,
/* 489 */,
/* 490 */,
/* 491 */,
/* 492 */,
/* 493 */,
/* 494 */,
/* 495 */,
/* 496 */,
/* 497 */,
/* 498 */,
/* 499 */,
/* 500 */,
/* 501 */,
/* 502 */,
/* 503 */,
/* 504 */,
/* 505 */,
/* 506 */,
/* 507 */,
/* 508 */,
/* 509 */,
/* 510 */,
/* 511 */,
/* 512 */,
/* 513 */,
/* 514 */,
/* 515 */,
/* 516 */,
/* 517 */,
/* 518 */,
/* 519 */,
/* 520 */,
/* 521 */,
/* 522 */,
/* 523 */,
/* 524 */,
/* 525 */,
/* 526 */,
/* 527 */,
/* 528 */,
/* 529 */,
/* 530 */,
/* 531 */,
/* 532 */,
/* 533 */,
/* 534 */,
/* 535 */,
/* 536 */,
/* 537 */,
/* 538 */,
/* 539 */,
/* 540 */,
/* 541 */,
/* 542 */,
/* 543 */,
/* 544 */,
/* 545 */,
/* 546 */,
/* 547 */,
/* 548 */,
/* 549 */,
/* 550 */,
/* 551 */,
/* 552 */,
/* 553 */,
/* 554 */,
/* 555 */,
/* 556 */,
/* 557 */,
/* 558 */,
/* 559 */,
/* 560 */,
/* 561 */,
/* 562 */,
/* 563 */,
/* 564 */,
/* 565 */,
/* 566 */,
/* 567 */,
/* 568 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _redux = __webpack_require__(578);

var _reducers = __webpack_require__(593);

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var store = (0, _redux.createStore)(_reducers2.default);

exports.default = store;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlZHV4XFxzdG9yZS5qcyJdLCJuYW1lcyI6WyJjcmVhdGVTdG9yZSIsIkNvZGVDb21iaW5lciIsInN0b3JlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxBQUFRLEFBQVI7O0FBRUEsQUFBTyxBQUFQOzs7Ozs7QUFFQSxJQUFJLFFBQVEsQUFBWSxBQUFaLEFBQVosQUFFQTs7a0JBQWUsQUFBZiIsImZpbGUiOiJzdG9yZS5qcyIsInNvdXJjZVJvb3QiOiJFOi9Qcm9qZWN0cyBhbmQgSWRlYXMvU3RhcnR2ZXJzaXR5L25ldHdvcnEifQ==

 ;(function register() { /* react-hot-loader/webpack */ if (true) { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } if (typeof module.exports === 'function') { __REACT_HOT_LOADER__.register(module.exports, 'module.exports', "E:\\Projects and Ideas\\Startversity\\networq\\redux\\store.js"); return; } for (var key in module.exports) { if (!Object.prototype.hasOwnProperty.call(module.exports, key)) { continue; } var namedExport = void 0; try { namedExport = module.exports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, "E:\\Projects and Ideas\\Startversity\\networq\\redux\\store.js"); } } })();

/***/ }),
/* 569 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var HTML_SUBMIT = function HTML_SUBMIT(html) {
    return {
        type: 'HTML_SUBMIT',
        html: html
    };
};

var CSS_SUBMIT = function CSS_SUBMIT(css) {
    return {
        type: 'CSS_SUBMIT',
        css: css
    };
};

var JS_SUBMIT = function JS_SUBMIT(js) {
    return {
        type: 'JS_SUBMIT',
        js: js
    };
};

var SAVE_TO_DATABASE = function SAVE_TO_DATABASE() {
    return {
        type: 'SAVE_TO_DATABASE'
    };
};

exports.HTML_SUBMIT = HTML_SUBMIT;
exports.CSS_SUBMIT = CSS_SUBMIT;
exports.JS_SUBMIT = JS_SUBMIT;
exports.SAVE_TO_DATABASE = SAVE_TO_DATABASE;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlZHV4XFxhY3Rpb25zLmpzIl0sIm5hbWVzIjpbIkhUTUxfU1VCTUlUIiwiaHRtbCIsInR5cGUiLCJDU1NfU1VCTUlUIiwiY3NzIiwiSlNfU1VCTUlUIiwianMiLCJTQVZFX1RPX0RBVEFCQVNFIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBLElBQU0sY0FBYyxTQUFkLEFBQWMsWUFBQSxBQUFDLE1BQUQ7O2NBQVcsQUFDckIsQUFDTjtjQUZnQixBQUFXO0FBQUEsQUFDM0I7QUFESjs7QUFLQSxJQUFNLGFBQWEsU0FBYixBQUFhLFdBQUEsQUFBQyxLQUFEOztjQUFVLEFBQ25CLEFBQ047YUFGZSxBQUFVO0FBQUEsQUFDekI7QUFESjs7QUFLQSxJQUFNLFlBQVksU0FBWixBQUFZLFVBQUEsQUFBQyxJQUFEOztjQUFTLEFBQ2pCLEFBQ047WUFGYyxBQUFTO0FBQUEsQUFDdkI7QUFESjs7QUFLQSxJQUFNLG1CQUFtQixTQUFuQixBQUFtQixtQkFBQTs7Y0FBQSxBQUFPLEFBQ3RCO0FBRHNCLEFBQzVCO0FBREosQUFJQTs7UUFBQSxBQUFRO1FBQVIsQUFBcUI7UUFBckIsQUFBaUM7UUFBakMsQUFBNEMiLCJmaWxlIjoiYWN0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiJFOi9Qcm9qZWN0cyBhbmQgSWRlYXMvU3RhcnR2ZXJzaXR5L25ldHdvcnEifQ==

 ;(function register() { /* react-hot-loader/webpack */ if (true) { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } if (typeof module.exports === 'function') { __REACT_HOT_LOADER__.register(module.exports, 'module.exports', "E:\\Projects and Ideas\\Startversity\\networq\\redux\\actions.js"); return; } for (var key in module.exports) { if (!Object.prototype.hasOwnProperty.call(module.exports, key)) { continue; } var namedExport = void 0; try { namedExport = module.exports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, "E:\\Projects and Ideas\\Startversity\\networq\\redux\\actions.js"); } } })();

/***/ }),
/* 570 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ActionTypes; });
/* harmony export (immutable) */ __webpack_exports__["b"] = createStore;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_es_isPlainObject__ = __webpack_require__(571);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_symbol_observable__ = __webpack_require__(587);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_symbol_observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_symbol_observable__);



/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = {
  INIT: '@@redux/INIT'

  /**
   * Creates a Redux store that holds the state tree.
   * The only way to change the data in the store is to call `dispatch()` on it.
   *
   * There should only be a single store in your app. To specify how different
   * parts of the state tree respond to actions, you may combine several reducers
   * into a single reducer function by using `combineReducers`.
   *
   * @param {Function} reducer A function that returns the next state tree, given
   * the current state tree and the action to handle.
   *
   * @param {any} [preloadedState] The initial state. You may optionally specify it
   * to hydrate the state from the server in universal apps, or to restore a
   * previously serialized user session.
   * If you use `combineReducers` to produce the root reducer function, this must be
   * an object with the same shape as `combineReducers` keys.
   *
   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
   * to enhance the store with third-party capabilities such as middleware,
   * time travel, persistence, etc. The only store enhancer that ships with Redux
   * is `applyMiddleware()`.
   *
   * @returns {Store} A Redux store that lets you read the state, dispatch actions
   * and subscribe to changes.
   */
};function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    return currentState;
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.');
    }

    var isSubscribed = true;

    ensureCanMutateNextListeners();
    nextListeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing what changed. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!Object(__WEBPACK_IMPORTED_MODULE_0_lodash_es_isPlainObject__["a" /* default */])(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.INIT });
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */
  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return { unsubscribe: unsubscribe };
      }
    }, _ref[__WEBPACK_IMPORTED_MODULE_1_symbol_observable___default.a] = function () {
      return this;
    }, _ref;
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[__WEBPACK_IMPORTED_MODULE_1_symbol_observable___default.a] = observable, _ref2;
}

/***/ }),
/* 571 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(579);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getPrototype_js__ = __webpack_require__(584);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__ = __webpack_require__(586);




/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!Object(__WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__["a" /* default */])(value) || Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a" /* default */])(value) != objectTag) {
    return false;
  }
  var proto = Object(__WEBPACK_IMPORTED_MODULE_1__getPrototype_js__["a" /* default */])(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/* harmony default export */ __webpack_exports__["a"] = (isPlainObject);


/***/ }),
/* 572 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__root_js__ = __webpack_require__(580);


/** Built-in value references. */
var Symbol = __WEBPACK_IMPORTED_MODULE_0__root_js__["a" /* default */].Symbol;

/* harmony default export */ __webpack_exports__["a"] = (Symbol);


/***/ }),
/* 573 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}

/***/ }),
/* 574 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = compose;
/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(undefined, arguments));
    };
  });
}

/***/ }),
/* 575 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/*!
 * Less - Leaner CSS v2.7.2
 * http://lesscss.org
 *
 * Copyright (c) 2009-2017, Alexis Sellier <self@cloudhead.net>
 * Licensed under the Apache-2.0 License.
 *
 */

 /** * @license Apache-2.0
 */

(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.less = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var addDataAttr = require("./utils").addDataAttr,
    browser = require("./browser");

module.exports = function(window, options) {

    // use options from the current script tag data attribues
    addDataAttr(options, browser.currentScript(window));

    if (options.isFileProtocol === undefined) {
        options.isFileProtocol = /^(file|(chrome|safari)(-extension)?|resource|qrc|app):/.test(window.location.protocol);
    }

    // Load styles asynchronously (default: false)
    //
    // This is set to `false` by default, so that the body
    // doesn't start loading before the stylesheets are parsed.
    // Setting this to `true` can result in flickering.
    //
    options.async = options.async || false;
    options.fileAsync = options.fileAsync || false;

    // Interval between watch polls
    options.poll = options.poll || (options.isFileProtocol ? 1000 : 1500);

    options.env = options.env || (window.location.hostname == '127.0.0.1' ||
        window.location.hostname == '0.0.0.0'   ||
        window.location.hostname == 'localhost' ||
        (window.location.port &&
            window.location.port.length > 0)      ||
        options.isFileProtocol                   ? 'development'
        : 'production');

    var dumpLineNumbers = /!dumpLineNumbers:(comments|mediaquery|all)/.exec(window.location.hash);
    if (dumpLineNumbers) {
        options.dumpLineNumbers = dumpLineNumbers[1];
    }

    if (options.useFileCache === undefined) {
        options.useFileCache = true;
    }

    if (options.onReady === undefined) {
        options.onReady = true;
    }

};

},{"./browser":3,"./utils":10}],2:[function(require,module,exports){
/**
 * Kicks off less and compiles any stylesheets
 * used in the browser distributed version of less
 * to kick-start less using the browser api
 */
/*global window, document */

// shim Promise if required
require('promise/polyfill.js');

var options = window.less || {};
require("./add-default-options")(window, options);

var less = module.exports = require("./index")(window, options);

window.less = less;

var css, head, style;

// Always restore page visibility
function resolveOrReject(data) {
    if (data.filename) {
        console.warn(data);
    }
    if (!options.async) {
        head.removeChild(style);
    }
}

if (options.onReady) {
    if (/!watch/.test(window.location.hash)) {
        less.watch();
    }
    // Simulate synchronous stylesheet loading by blocking page rendering
    if (!options.async) {
        css = 'body { display: none !important }';
        head = document.head || document.getElementsByTagName('head')[0];
        style = document.createElement('style');

        style.type = 'text/css';
        if (style.styleSheet) {
            style.styleSheet.cssText = css;
        } else {
            style.appendChild(document.createTextNode(css));
        }

        head.appendChild(style);
    }
    less.registerStylesheetsImmediately();
    less.pageLoadFinished = less.refresh(less.env === 'development').then(resolveOrReject, resolveOrReject);
}

},{"./add-default-options":1,"./index":8,"promise/polyfill.js":97}],3:[function(require,module,exports){
var utils = require("./utils");
module.exports = {
    createCSS: function (document, styles, sheet) {
        // Strip the query-string
        var href = sheet.href || '';

        // If there is no title set, use the filename, minus the extension
        var id = 'less:' + (sheet.title || utils.extractId(href));

        // If this has already been inserted into the DOM, we may need to replace it
        var oldStyleNode = document.getElementById(id);
        var keepOldStyleNode = false;

        // Create a new stylesheet node for insertion or (if necessary) replacement
        var styleNode = document.createElement('style');
        styleNode.setAttribute('type', 'text/css');
        if (sheet.media) {
            styleNode.setAttribute('media', sheet.media);
        }
        styleNode.id = id;

        if (!styleNode.styleSheet) {
            styleNode.appendChild(document.createTextNode(styles));

            // If new contents match contents of oldStyleNode, don't replace oldStyleNode
            keepOldStyleNode = (oldStyleNode !== null && oldStyleNode.childNodes.length > 0 && styleNode.childNodes.length > 0 &&
                oldStyleNode.firstChild.nodeValue === styleNode.firstChild.nodeValue);
        }

        var head = document.getElementsByTagName('head')[0];

        // If there is no oldStyleNode, just append; otherwise, only append if we need
        // to replace oldStyleNode with an updated stylesheet
        if (oldStyleNode === null || keepOldStyleNode === false) {
            var nextEl = sheet && sheet.nextSibling || null;
            if (nextEl) {
                nextEl.parentNode.insertBefore(styleNode, nextEl);
            } else {
                head.appendChild(styleNode);
            }
        }
        if (oldStyleNode && keepOldStyleNode === false) {
            oldStyleNode.parentNode.removeChild(oldStyleNode);
        }

        // For IE.
        // This needs to happen *after* the style element is added to the DOM, otherwise IE 7 and 8 may crash.
        // See http://social.msdn.microsoft.com/Forums/en-US/7e081b65-878a-4c22-8e68-c10d39c2ed32/internet-explorer-crashes-appending-style-element-to-head
        if (styleNode.styleSheet) {
            try {
                styleNode.styleSheet.cssText = styles;
            } catch (e) {
                throw new Error("Couldn't reassign styleSheet.cssText.");
            }
        }
    },
    currentScript: function(window) {
        var document = window.document;
        return document.currentScript || (function() {
            var scripts = document.getElementsByTagName("script");
            return scripts[scripts.length - 1];
        })();
    }
};

},{"./utils":10}],4:[function(require,module,exports){
// Cache system is a bit outdated and could do with work

module.exports = function(window, options, logger) {
    var cache = null;
    if (options.env !== 'development') {
        try {
            cache = (typeof window.localStorage === 'undefined') ? null : window.localStorage;
        } catch (_) {}
    }
    return {
        setCSS: function(path, lastModified, modifyVars, styles) {
            if (cache) {
                logger.info('saving ' + path + ' to cache.');
                try {
                    cache.setItem(path, styles);
                    cache.setItem(path + ':timestamp', lastModified);
                    if (modifyVars) {
                        cache.setItem(path + ':vars', JSON.stringify(modifyVars));
                    }
                } catch(e) {
                    //TODO - could do with adding more robust error handling
                    logger.error('failed to save "' + path + '" to local storage for caching.');
                }
            }
        },
        getCSS: function(path, webInfo, modifyVars) {
            var css       = cache && cache.getItem(path),
                timestamp = cache && cache.getItem(path + ':timestamp'),
                vars      = cache && cache.getItem(path + ':vars');

            modifyVars = modifyVars || {};

            if (timestamp && webInfo.lastModified &&
                (new Date(webInfo.lastModified).valueOf() ===
                    new Date(timestamp).valueOf()) &&
                (!modifyVars && !vars || JSON.stringify(modifyVars) === vars)) {
                // Use local copy
                return css;
            }
        }
    };
};

},{}],5:[function(require,module,exports){
var utils = require("./utils"),
    browser = require("./browser");

module.exports = function(window, less, options) {

    function errorHTML(e, rootHref) {
        var id = 'less-error-message:' + utils.extractId(rootHref || "");
        var template = '<li><label>{line}</label><pre class="{class}">{content}</pre></li>';
        var elem = window.document.createElement('div'), timer, content, errors = [];
        var filename = e.filename || rootHref;
        var filenameNoPath = filename.match(/([^\/]+(\?.*)?)$/)[1];

        elem.id        = id;
        elem.className = "less-error-message";

        content = '<h3>'  + (e.type || "Syntax") + "Error: " + (e.message || 'There is an error in your .less file') +
            '</h3>' + '<p>in <a href="' + filename   + '">' + filenameNoPath + "</a> ";

        var errorline = function (e, i, classname) {
            if (e.extract[i] !== undefined) {
                errors.push(template.replace(/\{line\}/, (parseInt(e.line, 10) || 0) + (i - 1))
                    .replace(/\{class\}/, classname)
                    .replace(/\{content\}/, e.extract[i]));
            }
        };

        if (e.extract) {
            errorline(e, 0, '');
            errorline(e, 1, 'line');
            errorline(e, 2, '');
            content += 'on line ' + e.line + ', column ' + (e.column + 1) + ':</p>' +
                '<ul>' + errors.join('') + '</ul>';
        }
        if (e.stack && (e.extract || options.logLevel >= 4)) {
            content += '<br/>Stack Trace</br />' + e.stack.split('\n').slice(1).join('<br/>');
        }
        elem.innerHTML = content;

        // CSS for error messages
        browser.createCSS(window.document, [
            '.less-error-message ul, .less-error-message li {',
            'list-style-type: none;',
            'margin-right: 15px;',
            'padding: 4px 0;',
            'margin: 0;',
            '}',
            '.less-error-message label {',
            'font-size: 12px;',
            'margin-right: 15px;',
            'padding: 4px 0;',
            'color: #cc7777;',
            '}',
            '.less-error-message pre {',
            'color: #dd6666;',
            'padding: 4px 0;',
            'margin: 0;',
            'display: inline-block;',
            '}',
            '.less-error-message pre.line {',
            'color: #ff0000;',
            '}',
            '.less-error-message h3 {',
            'font-size: 20px;',
            'font-weight: bold;',
            'padding: 15px 0 5px 0;',
            'margin: 0;',
            '}',
            '.less-error-message a {',
            'color: #10a',
            '}',
            '.less-error-message .error {',
            'color: red;',
            'font-weight: bold;',
            'padding-bottom: 2px;',
            'border-bottom: 1px dashed red;',
            '}'
        ].join('\n'), { title: 'error-message' });

        elem.style.cssText = [
            "font-family: Arial, sans-serif",
            "border: 1px solid #e00",
            "background-color: #eee",
            "border-radius: 5px",
            "-webkit-border-radius: 5px",
            "-moz-border-radius: 5px",
            "color: #e00",
            "padding: 15px",
            "margin-bottom: 15px"
        ].join(';');

        if (options.env === 'development') {
            timer = setInterval(function () {
                var document = window.document,
                    body = document.body;
                if (body) {
                    if (document.getElementById(id)) {
                        body.replaceChild(elem, document.getElementById(id));
                    } else {
                        body.insertBefore(elem, body.firstChild);
                    }
                    clearInterval(timer);
                }
            }, 10);
        }
    }

    function removeErrorHTML(path) {
        var node = window.document.getElementById('less-error-message:' + utils.extractId(path));
        if (node) {
            node.parentNode.removeChild(node);
        }
    }

    function removeErrorConsole(path) {
        //no action
    }

    function removeError(path) {
        if (!options.errorReporting || options.errorReporting === "html") {
            removeErrorHTML(path);
        } else if (options.errorReporting === "console") {
            removeErrorConsole(path);
        } else if (typeof options.errorReporting === 'function') {
            options.errorReporting("remove", path);
        }
    }

    function errorConsole(e, rootHref) {
        var template = '{line} {content}';
        var filename = e.filename || rootHref;
        var errors = [];
        var content = (e.type || "Syntax") + "Error: " + (e.message || 'There is an error in your .less file') +
            " in " + filename + " ";

        var errorline = function (e, i, classname) {
            if (e.extract[i] !== undefined) {
                errors.push(template.replace(/\{line\}/, (parseInt(e.line, 10) || 0) + (i - 1))
                    .replace(/\{class\}/, classname)
                    .replace(/\{content\}/, e.extract[i]));
            }
        };

        if (e.extract) {
            errorline(e, 0, '');
            errorline(e, 1, 'line');
            errorline(e, 2, '');
            content += 'on line ' + e.line + ', column ' + (e.column + 1) + ':\n' +
                errors.join('\n');
        }
        if (e.stack && (e.extract || options.logLevel >= 4)) {
            content += '\nStack Trace\n' + e.stack;
        }
        less.logger.error(content);
    }

    function error(e, rootHref) {
        if (!options.errorReporting || options.errorReporting === "html") {
            errorHTML(e, rootHref);
        } else if (options.errorReporting === "console") {
            errorConsole(e, rootHref);
        } else if (typeof options.errorReporting === 'function') {
            options.errorReporting("add", e, rootHref);
        }
    }

    return {
        add: error,
        remove: removeError
    };
};

},{"./browser":3,"./utils":10}],6:[function(require,module,exports){
/*global window, XMLHttpRequest */

module.exports = function(options, logger) {

    var AbstractFileManager = require("../less/environment/abstract-file-manager.js");

    var fileCache = {};

    //TODOS - move log somewhere. pathDiff and doing something similar in node. use pathDiff in the other browser file for the initial load

    function getXMLHttpRequest() {
        if (window.XMLHttpRequest && (window.location.protocol !== "file:" || !("ActiveXObject" in window))) {
            return new XMLHttpRequest();
        } else {
            try {
                /*global ActiveXObject */
                return new ActiveXObject("Microsoft.XMLHTTP");
            } catch (e) {
                logger.error("browser doesn't support AJAX.");
                return null;
            }
        }
    }

    var FileManager = function() {
    };

    FileManager.prototype = new AbstractFileManager();

    FileManager.prototype.alwaysMakePathsAbsolute = function alwaysMakePathsAbsolute() {
        return true;
    };
    FileManager.prototype.join = function join(basePath, laterPath) {
        if (!basePath) {
            return laterPath;
        }
        return this.extractUrlParts(laterPath, basePath).path;
    };
    FileManager.prototype.doXHR = function doXHR(url, type, callback, errback) {

        var xhr = getXMLHttpRequest();
        var async = options.isFileProtocol ? options.fileAsync : true;

        if (typeof xhr.overrideMimeType === 'function') {
            xhr.overrideMimeType('text/css');
        }
        logger.debug("XHR: Getting '" + url + "'");
        xhr.open('GET', url, async);
        xhr.setRequestHeader('Accept', type || 'text/x-less, text/css; q=0.9, */*; q=0.5');
        xhr.send(null);

        function handleResponse(xhr, callback, errback) {
            if (xhr.status >= 200 && xhr.status < 300) {
                callback(xhr.responseText,
                    xhr.getResponseHeader("Last-Modified"));
            } else if (typeof errback === 'function') {
                errback(xhr.status, url);
            }
        }

        if (options.isFileProtocol && !options.fileAsync) {
            if (xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300)) {
                callback(xhr.responseText);
            } else {
                errback(xhr.status, url);
            }
        } else if (async) {
            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4) {
                    handleResponse(xhr, callback, errback);
                }
            };
        } else {
            handleResponse(xhr, callback, errback);
        }
    };
    FileManager.prototype.supports = function(filename, currentDirectory, options, environment) {
        return true;
    };

    FileManager.prototype.clearFileCache = function() {
        fileCache = {};
    };

    FileManager.prototype.loadFile = function loadFile(filename, currentDirectory, options, environment, callback) {
        if (currentDirectory && !this.isPathAbsolute(filename)) {
            filename = currentDirectory + filename;
        }

        options = options || {};

        // sheet may be set to the stylesheet for the initial load or a collection of properties including
        // some context variables for imports
        var hrefParts = this.extractUrlParts(filename, window.location.href);
        var href      = hrefParts.url;

        if (options.useFileCache && fileCache[href]) {
            try {
                var lessText = fileCache[href];
                callback(null, { contents: lessText, filename: href, webInfo: { lastModified: new Date() }});
            } catch (e) {
                callback({filename: href, message: "Error loading file " + href + " error was " + e.message});
            }
            return;
        }

        this.doXHR(href, options.mime, function doXHRCallback(data, lastModified) {
            // per file cache
            fileCache[href] = data;

            // Use remote copy (re-parse)
            callback(null, { contents: data, filename: href, webInfo: { lastModified: lastModified }});
        }, function doXHRError(status, url) {
            callback({ type: 'File', message: "'" + url + "' wasn't found (" + status + ")", href: href });
        });
    };

    return FileManager;
};

},{"../less/environment/abstract-file-manager.js":15}],7:[function(require,module,exports){
module.exports = function() {

    var functionRegistry = require("./../less/functions/function-registry");

    function imageSize() {
        throw {
            type: "Runtime",
            message: "Image size functions are not supported in browser version of less"
        };
    }

    var imageFunctions = {
        "image-size": function(filePathNode) {
            imageSize(this, filePathNode);
            return -1;
        },
        "image-width": function(filePathNode) {
            imageSize(this, filePathNode);
            return -1;
        },
        "image-height": function(filePathNode) {
            imageSize(this, filePathNode);
            return -1;
        }
    };

    functionRegistry.addMultiple(imageFunctions);
};

},{"./../less/functions/function-registry":22}],8:[function(require,module,exports){
//
// index.js
// Should expose the additional browser functions on to the less object
//
var addDataAttr = require("./utils").addDataAttr,
    browser = require("./browser");

module.exports = function(window, options) {
    var document = window.document;
    var less = require('../less')();

    //module.exports = less;
    less.options = options;
    var environment = less.environment,
        FileManager = require("./file-manager")(options, less.logger),
        fileManager = new FileManager();
    environment.addFileManager(fileManager);
    less.FileManager = FileManager;

    require("./log-listener")(less, options);
    var errors = require("./error-reporting")(window, less, options);
    var cache = less.cache = options.cache || require("./cache")(window, options, less.logger);
    require('./image-size')(less.environment);

    //Setup user functions
    if (options.functions) {
        less.functions.functionRegistry.addMultiple(options.functions);
    }

    var typePattern = /^text\/(x-)?less$/;

    function postProcessCSS(styles) { // deprecated, use a plugin for postprocesstasks
        if (options.postProcessor && typeof options.postProcessor === 'function') {
            styles = options.postProcessor.call(styles, styles) || styles;
        }
        return styles;
    }

    function clone(obj) {
        var cloned = {};
        for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
                cloned[prop] = obj[prop];
            }
        }
        return cloned;
    }

    // only really needed for phantom
    function bind(func, thisArg) {
        var curryArgs = Array.prototype.slice.call(arguments, 2);
        return function() {
            var args = curryArgs.concat(Array.prototype.slice.call(arguments, 0));
            return func.apply(thisArg, args);
        };
    }

    function loadStyles(modifyVars) {
        var styles = document.getElementsByTagName('style'),
            style;

        for (var i = 0; i < styles.length; i++) {
            style = styles[i];
            if (style.type.match(typePattern)) {
                var instanceOptions = clone(options);
                instanceOptions.modifyVars = modifyVars;
                var lessText = style.innerHTML || '';
                instanceOptions.filename = document.location.href.replace(/#.*$/, '');

                /*jshint loopfunc:true */
                // use closure to store current style
                less.render(lessText, instanceOptions,
                        bind(function(style, e, result) {
                            if (e) {
                                errors.add(e, "inline");
                            } else {
                                style.type = 'text/css';
                                if (style.styleSheet) {
                                    style.styleSheet.cssText = result.css;
                                } else {
                                    style.innerHTML = result.css;
                                }
                            }
                        }, null, style));
            }
        }
    }

    function loadStyleSheet(sheet, callback, reload, remaining, modifyVars) {

        var instanceOptions = clone(options);
        addDataAttr(instanceOptions, sheet);
        instanceOptions.mime = sheet.type;

        if (modifyVars) {
            instanceOptions.modifyVars = modifyVars;
        }

        function loadInitialFileCallback(loadedFile) {

            var data = loadedFile.contents,
                path = loadedFile.filename,
                webInfo = loadedFile.webInfo;

            var newFileInfo = {
                currentDirectory: fileManager.getPath(path),
                filename: path,
                rootFilename: path,
                relativeUrls: instanceOptions.relativeUrls};

            newFileInfo.entryPath = newFileInfo.currentDirectory;
            newFileInfo.rootpath = instanceOptions.rootpath || newFileInfo.currentDirectory;

            if (webInfo) {
                webInfo.remaining = remaining;

                var css = cache.getCSS(path, webInfo, instanceOptions.modifyVars);
                if (!reload && css) {
                    webInfo.local = true;
                    callback(null, css, data, sheet, webInfo, path);
                    return;
                }

            }

            //TODO add tests around how this behaves when reloading
            errors.remove(path);

            instanceOptions.rootFileInfo = newFileInfo;
            less.render(data, instanceOptions, function(e, result) {
                if (e) {
                    e.href = path;
                    callback(e);
                } else {
                    result.css = postProcessCSS(result.css);
                    cache.setCSS(sheet.href, webInfo.lastModified, instanceOptions.modifyVars, result.css);
                    callback(null, result.css, data, sheet, webInfo, path);
                }
            });
        }

        fileManager.loadFile(sheet.href, null, instanceOptions, environment, function(e, loadedFile) {
            if (e) {
                callback(e);
                return;
            }
            loadInitialFileCallback(loadedFile);
        });
    }

    function loadStyleSheets(callback, reload, modifyVars) {
        for (var i = 0; i < less.sheets.length; i++) {
            loadStyleSheet(less.sheets[i], callback, reload, less.sheets.length - (i + 1), modifyVars);
        }
    }

    function initRunningMode() {
        if (less.env === 'development') {
            less.watchTimer = setInterval(function () {
                if (less.watchMode) {
                    fileManager.clearFileCache();
                    loadStyleSheets(function (e, css, _, sheet, webInfo) {
                        if (e) {
                            errors.add(e, e.href || sheet.href);
                        } else if (css) {
                            browser.createCSS(window.document, css, sheet);
                        }
                    });
                }
            }, options.poll);
        }
    }

    //
    // Watch mode
    //
    less.watch   = function () {
        if (!less.watchMode ) {
            less.env = 'development';
            initRunningMode();
        }
        this.watchMode = true;
        return true;
    };

    less.unwatch = function () {clearInterval(less.watchTimer); this.watchMode = false; return false; };

    //
    // Synchronously get all <link> tags with the 'rel' attribute set to
    // "stylesheet/less".
    //
    less.registerStylesheetsImmediately = function() {
        var links = document.getElementsByTagName('link');
        less.sheets = [];

        for (var i = 0; i < links.length; i++) {
            if (links[i].rel === 'stylesheet/less' || (links[i].rel.match(/stylesheet/) &&
                (links[i].type.match(typePattern)))) {
                less.sheets.push(links[i]);
            }
        }
    };

    //
    // Asynchronously get all <link> tags with the 'rel' attribute set to
    // "stylesheet/less", returning a Promise.
    //
    less.registerStylesheets = function() {
        return new Promise(function(resolve, reject) {
            less.registerStylesheetsImmediately();
            resolve();
        });
    };

    //
    // With this function, it's possible to alter variables and re-render
    // CSS without reloading less-files
    //
    less.modifyVars = function(record) {
        return less.refresh(true, record, false);
    };

    less.refresh = function (reload, modifyVars, clearFileCache) {
        if ((reload || clearFileCache) && clearFileCache !== false) {
            fileManager.clearFileCache();
        }
        return new Promise(function (resolve, reject) {
            var startTime, endTime, totalMilliseconds, remainingSheets;
            startTime = endTime = new Date();

            // Set counter for remaining unprocessed sheets
            remainingSheets = less.sheets.length;

            if (remainingSheets === 0) {

                endTime = new Date();
                totalMilliseconds = endTime - startTime;
                less.logger.info("Less has finished and no sheets were loaded.");
                resolve({
                    startTime: startTime,
                    endTime: endTime,
                    totalMilliseconds: totalMilliseconds,
                    sheets: less.sheets.length
                });

            } else {
                // Relies on less.sheets array, callback seems to be guaranteed to be called for every element of the array
                loadStyleSheets(function (e, css, _, sheet, webInfo) {
                    if (e) {
                        errors.add(e, e.href || sheet.href);
                        reject(e);
                        return;
                    }
                    if (webInfo.local) {
                        less.logger.info("Loading " + sheet.href + " from cache.");
                    } else {
                        less.logger.info("Rendered " + sheet.href + " successfully.");
                    }
                    browser.createCSS(window.document, css, sheet);
                    less.logger.info("CSS for " + sheet.href + " generated in " + (new Date() - endTime) + 'ms');

                    // Count completed sheet
                    remainingSheets--;

                    // Check if the last remaining sheet was processed and then call the promise
                    if (remainingSheets === 0) {
                        totalMilliseconds = new Date() - startTime;
                        less.logger.info("Less has finished. CSS generated in " + totalMilliseconds + 'ms');
                        resolve({
                            startTime: startTime,
                            endTime: endTime,
                            totalMilliseconds: totalMilliseconds,
                            sheets: less.sheets.length
                        });
                    }
                    endTime = new Date();
                }, reload, modifyVars);
            }

            loadStyles(modifyVars);
        });
    };

    less.refreshStyles = loadStyles;
    return less;
};

},{"../less":31,"./browser":3,"./cache":4,"./error-reporting":5,"./file-manager":6,"./image-size":7,"./log-listener":9,"./utils":10}],9:[function(require,module,exports){
module.exports = function(less, options) {

    var logLevel_debug = 4,
        logLevel_info = 3,
        logLevel_warn = 2,
        logLevel_error = 1;

    // The amount of logging in the javascript console.
    // 3 - Debug, information and errors
    // 2 - Information and errors
    // 1 - Errors
    // 0 - None
    // Defaults to 2
    options.logLevel = typeof options.logLevel !== 'undefined' ? options.logLevel : (options.env === 'development' ?  logLevel_info : logLevel_error);

    if (!options.loggers) {
        options.loggers = [{
            debug: function(msg) {
                if (options.logLevel >= logLevel_debug) {
                    console.log(msg);
                }
            },
            info: function(msg) {
                if (options.logLevel >= logLevel_info) {
                    console.log(msg);
                }
            },
            warn: function(msg) {
                if (options.logLevel >= logLevel_warn) {
                    console.warn(msg);
                }
            },
            error: function(msg) {
                if (options.logLevel >= logLevel_error) {
                    console.error(msg);
                }
            }
        }];
    }
    for (var i = 0; i < options.loggers.length; i++) {
        less.logger.addListener(options.loggers[i]);
    }
};

},{}],10:[function(require,module,exports){
module.exports = {
    extractId: function(href) {
        return href.replace(/^[a-z-]+:\/+?[^\/]+/, '')  // Remove protocol & domain
            .replace(/[\?\&]livereload=\w+/, '')        // Remove LiveReload cachebuster
            .replace(/^\//, '')                         // Remove root /
            .replace(/\.[a-zA-Z]+$/, '')                // Remove simple extension
            .replace(/[^\.\w-]+/g, '-')                 // Replace illegal characters
            .replace(/\./g, ':');                       // Replace dots with colons(for valid id)
    },
    addDataAttr: function(options, tag) {
        for (var opt in tag.dataset) {
            if (tag.dataset.hasOwnProperty(opt)) {
                if (opt === "env" || opt === "dumpLineNumbers" || opt === "rootpath" || opt === "errorReporting") {
                    options[opt] = tag.dataset[opt];
                } else {
                    try {
                        options[opt] = JSON.parse(tag.dataset[opt]);
                    }
                    catch(_) {}
                }
            }
        }
    }
};

},{}],11:[function(require,module,exports){
var contexts = {};
module.exports = contexts;

var copyFromOriginal = function copyFromOriginal(original, destination, propertiesToCopy) {
    if (!original) { return; }

    for (var i = 0; i < propertiesToCopy.length; i++) {
        if (original.hasOwnProperty(propertiesToCopy[i])) {
            destination[propertiesToCopy[i]] = original[propertiesToCopy[i]];
        }
    }
};

/*
 parse is used whilst parsing
 */
var parseCopyProperties = [
    // options
    'paths',            // option - unmodified - paths to search for imports on
    'relativeUrls',     // option - whether to adjust URL's to be relative
    'rootpath',         // option - rootpath to append to URL's
    'strictImports',    // option -
    'insecure',         // option - whether to allow imports from insecure ssl hosts
    'dumpLineNumbers',  // option - whether to dump line numbers
    'compress',         // option - whether to compress
    'syncImport',       // option - whether to import synchronously
    'chunkInput',       // option - whether to chunk input. more performant but causes parse issues.
    'mime',             // browser only - mime type for sheet import
    'useFileCache',     // browser only - whether to use the per file session cache
    // context
    'processImports',   // option & context - whether to process imports. if false then imports will not be imported.
                        // Used by the import manager to stop multiple import visitors being created.
    'pluginManager'     // Used as the plugin manager for the session
];

contexts.Parse = function(options) {
    copyFromOriginal(options, this, parseCopyProperties);

    if (typeof this.paths === "string") { this.paths = [this.paths]; }
};

var evalCopyProperties = [
    'paths',          // additional include paths
    'compress',       // whether to compress
    'ieCompat',       // whether to enforce IE compatibility (IE8 data-uri)
    'strictMath',     // whether math has to be within parenthesis
    'strictUnits',    // whether units need to evaluate correctly
    'sourceMap',      // whether to output a source map
    'importMultiple', // whether we are currently importing multiple copies
    'urlArgs',        // whether to add args into url tokens
    'javascriptEnabled',// option - whether JavaScript is enabled. if undefined, defaults to true
    'pluginManager',  // Used as the plugin manager for the session
    'importantScope'  // used to bubble up !important statements
    ];

contexts.Eval = function(options, frames) {
    copyFromOriginal(options, this, evalCopyProperties);

    if (typeof this.paths === "string") { this.paths = [this.paths]; }

    this.frames = frames || [];
    this.importantScope = this.importantScope || [];
};

contexts.Eval.prototype.inParenthesis = function () {
    if (!this.parensStack) {
        this.parensStack = [];
    }
    this.parensStack.push(true);
};

contexts.Eval.prototype.outOfParenthesis = function () {
    this.parensStack.pop();
};

contexts.Eval.prototype.isMathOn = function () {
    return this.strictMath ? (this.parensStack && this.parensStack.length) : true;
};

contexts.Eval.prototype.isPathRelative = function (path) {
    return !/^(?:[a-z-]+:|\/|#)/i.test(path);
};

contexts.Eval.prototype.normalizePath = function( path ) {
    var
      segments = path.split("/").reverse(),
      segment;

    path = [];
    while (segments.length !== 0 ) {
        segment = segments.pop();
        switch( segment ) {
            case ".":
                break;
            case "..":
                if ((path.length === 0) || (path[path.length - 1] === "..")) {
                    path.push( segment );
                } else {
                    path.pop();
                }
                break;
            default:
                path.push( segment );
                break;
        }
    }

    return path.join("/");
};

//todo - do the same for the toCSS ?

},{}],12:[function(require,module,exports){
module.exports = {
    'aliceblue':'#f0f8ff',
    'antiquewhite':'#faebd7',
    'aqua':'#00ffff',
    'aquamarine':'#7fffd4',
    'azure':'#f0ffff',
    'beige':'#f5f5dc',
    'bisque':'#ffe4c4',
    'black':'#000000',
    'blanchedalmond':'#ffebcd',
    'blue':'#0000ff',
    'blueviolet':'#8a2be2',
    'brown':'#a52a2a',
    'burlywood':'#deb887',
    'cadetblue':'#5f9ea0',
    'chartreuse':'#7fff00',
    'chocolate':'#d2691e',
    'coral':'#ff7f50',
    'cornflowerblue':'#6495ed',
    'cornsilk':'#fff8dc',
    'crimson':'#dc143c',
    'cyan':'#00ffff',
    'darkblue':'#00008b',
    'darkcyan':'#008b8b',
    'darkgoldenrod':'#b8860b',
    'darkgray':'#a9a9a9',
    'darkgrey':'#a9a9a9',
    'darkgreen':'#006400',
    'darkkhaki':'#bdb76b',
    'darkmagenta':'#8b008b',
    'darkolivegreen':'#556b2f',
    'darkorange':'#ff8c00',
    'darkorchid':'#9932cc',
    'darkred':'#8b0000',
    'darksalmon':'#e9967a',
    'darkseagreen':'#8fbc8f',
    'darkslateblue':'#483d8b',
    'darkslategray':'#2f4f4f',
    'darkslategrey':'#2f4f4f',
    'darkturquoise':'#00ced1',
    'darkviolet':'#9400d3',
    'deeppink':'#ff1493',
    'deepskyblue':'#00bfff',
    'dimgray':'#696969',
    'dimgrey':'#696969',
    'dodgerblue':'#1e90ff',
    'firebrick':'#b22222',
    'floralwhite':'#fffaf0',
    'forestgreen':'#228b22',
    'fuchsia':'#ff00ff',
    'gainsboro':'#dcdcdc',
    'ghostwhite':'#f8f8ff',
    'gold':'#ffd700',
    'goldenrod':'#daa520',
    'gray':'#808080',
    'grey':'#808080',
    'green':'#008000',
    'greenyellow':'#adff2f',
    'honeydew':'#f0fff0',
    'hotpink':'#ff69b4',
    'indianred':'#cd5c5c',
    'indigo':'#4b0082',
    'ivory':'#fffff0',
    'khaki':'#f0e68c',
    'lavender':'#e6e6fa',
    'lavenderblush':'#fff0f5',
    'lawngreen':'#7cfc00',
    'lemonchiffon':'#fffacd',
    'lightblue':'#add8e6',
    'lightcoral':'#f08080',
    'lightcyan':'#e0ffff',
    'lightgoldenrodyellow':'#fafad2',
    'lightgray':'#d3d3d3',
    'lightgrey':'#d3d3d3',
    'lightgreen':'#90ee90',
    'lightpink':'#ffb6c1',
    'lightsalmon':'#ffa07a',
    'lightseagreen':'#20b2aa',
    'lightskyblue':'#87cefa',
    'lightslategray':'#778899',
    'lightslategrey':'#778899',
    'lightsteelblue':'#b0c4de',
    'lightyellow':'#ffffe0',
    'lime':'#00ff00',
    'limegreen':'#32cd32',
    'linen':'#faf0e6',
    'magenta':'#ff00ff',
    'maroon':'#800000',
    'mediumaquamarine':'#66cdaa',
    'mediumblue':'#0000cd',
    'mediumorchid':'#ba55d3',
    'mediumpurple':'#9370d8',
    'mediumseagreen':'#3cb371',
    'mediumslateblue':'#7b68ee',
    'mediumspringgreen':'#00fa9a',
    'mediumturquoise':'#48d1cc',
    'mediumvioletred':'#c71585',
    'midnightblue':'#191970',
    'mintcream':'#f5fffa',
    'mistyrose':'#ffe4e1',
    'moccasin':'#ffe4b5',
    'navajowhite':'#ffdead',
    'navy':'#000080',
    'oldlace':'#fdf5e6',
    'olive':'#808000',
    'olivedrab':'#6b8e23',
    'orange':'#ffa500',
    'orangered':'#ff4500',
    'orchid':'#da70d6',
    'palegoldenrod':'#eee8aa',
    'palegreen':'#98fb98',
    'paleturquoise':'#afeeee',
    'palevioletred':'#d87093',
    'papayawhip':'#ffefd5',
    'peachpuff':'#ffdab9',
    'peru':'#cd853f',
    'pink':'#ffc0cb',
    'plum':'#dda0dd',
    'powderblue':'#b0e0e6',
    'purple':'#800080',
    'rebeccapurple':'#663399',
    'red':'#ff0000',
    'rosybrown':'#bc8f8f',
    'royalblue':'#4169e1',
    'saddlebrown':'#8b4513',
    'salmon':'#fa8072',
    'sandybrown':'#f4a460',
    'seagreen':'#2e8b57',
    'seashell':'#fff5ee',
    'sienna':'#a0522d',
    'silver':'#c0c0c0',
    'skyblue':'#87ceeb',
    'slateblue':'#6a5acd',
    'slategray':'#708090',
    'slategrey':'#708090',
    'snow':'#fffafa',
    'springgreen':'#00ff7f',
    'steelblue':'#4682b4',
    'tan':'#d2b48c',
    'teal':'#008080',
    'thistle':'#d8bfd8',
    'tomato':'#ff6347',
    'turquoise':'#40e0d0',
    'violet':'#ee82ee',
    'wheat':'#f5deb3',
    'white':'#ffffff',
    'whitesmoke':'#f5f5f5',
    'yellow':'#ffff00',
    'yellowgreen':'#9acd32'
};
},{}],13:[function(require,module,exports){
module.exports = {
    colors: require("./colors"),
    unitConversions: require("./unit-conversions")
};

},{"./colors":12,"./unit-conversions":14}],14:[function(require,module,exports){
module.exports = {
    length: {
        'm': 1,
        'cm': 0.01,
        'mm': 0.001,
        'in': 0.0254,
        'px': 0.0254 / 96,
        'pt': 0.0254 / 72,
        'pc': 0.0254 / 72 * 12
    },
    duration: {
        's': 1,
        'ms': 0.001
    },
    angle: {
        'rad': 1 / (2 * Math.PI),
        'deg': 1 / 360,
        'grad': 1 / 400,
        'turn': 1
    }
};
},{}],15:[function(require,module,exports){
var abstractFileManager = function() {
};

abstractFileManager.prototype.getPath = function (filename) {
    var j = filename.lastIndexOf('?');
    if (j > 0) {
        filename = filename.slice(0, j);
    }
    j = filename.lastIndexOf('/');
    if (j < 0) {
        j = filename.lastIndexOf('\\');
    }
    if (j < 0) {
        return "";
    }
    return filename.slice(0, j + 1);
};

abstractFileManager.prototype.tryAppendExtension = function(path, ext) {
    return /(\.[a-z]*$)|([\?;].*)$/.test(path) ? path : path + ext;
};

abstractFileManager.prototype.tryAppendLessExtension = function(path) {
    return this.tryAppendExtension(path, '.less');
};

abstractFileManager.prototype.supportsSync = function() {
    return false;
};

abstractFileManager.prototype.alwaysMakePathsAbsolute = function() {
    return false;
};

abstractFileManager.prototype.isPathAbsolute = function(filename) {
    return (/^(?:[a-z-]+:|\/|\\|#)/i).test(filename);
};

abstractFileManager.prototype.join = function(basePath, laterPath) {
    if (!basePath) {
        return laterPath;
    }
    return basePath + laterPath;
};
abstractFileManager.prototype.pathDiff = function pathDiff(url, baseUrl) {
    // diff between two paths to create a relative path

    var urlParts = this.extractUrlParts(url),
        baseUrlParts = this.extractUrlParts(baseUrl),
        i, max, urlDirectories, baseUrlDirectories, diff = "";
    if (urlParts.hostPart !== baseUrlParts.hostPart) {
        return "";
    }
    max = Math.max(baseUrlParts.directories.length, urlParts.directories.length);
    for (i = 0; i < max; i++) {
        if (baseUrlParts.directories[i] !== urlParts.directories[i]) { break; }
    }
    baseUrlDirectories = baseUrlParts.directories.slice(i);
    urlDirectories = urlParts.directories.slice(i);
    for (i = 0; i < baseUrlDirectories.length - 1; i++) {
        diff += "../";
    }
    for (i = 0; i < urlDirectories.length - 1; i++) {
        diff += urlDirectories[i] + "/";
    }
    return diff;
};
// helper function, not part of API
abstractFileManager.prototype.extractUrlParts = function extractUrlParts(url, baseUrl) {
    // urlParts[1] = protocol://hostname/ OR /
    // urlParts[2] = / if path relative to host base
    // urlParts[3] = directories
    // urlParts[4] = filename
    // urlParts[5] = parameters

    var urlPartsRegex = /^((?:[a-z-]+:)?\/{2}(?:[^\/\?#]*\/)|([\/\\]))?((?:[^\/\\\?#]*[\/\\])*)([^\/\\\?#]*)([#\?].*)?$/i,
        urlParts = url.match(urlPartsRegex),
        returner = {}, directories = [], i, baseUrlParts;

    if (!urlParts) {
        throw new Error("Could not parse sheet href - '" + url + "'");
    }

    // Stylesheets in IE don't always return the full path
    if (baseUrl && (!urlParts[1] || urlParts[2])) {
        baseUrlParts = baseUrl.match(urlPartsRegex);
        if (!baseUrlParts) {
            throw new Error("Could not parse page url - '" + baseUrl + "'");
        }
        urlParts[1] = urlParts[1] || baseUrlParts[1] || "";
        if (!urlParts[2]) {
            urlParts[3] = baseUrlParts[3] + urlParts[3];
        }
    }

    if (urlParts[3]) {
        directories = urlParts[3].replace(/\\/g, "/").split("/");

        // extract out . before .. so .. doesn't absorb a non-directory
        for (i = 0; i < directories.length; i++) {
            if (directories[i] === ".") {
                directories.splice(i, 1);
                i -= 1;
            }
        }

        for (i = 0; i < directories.length; i++) {
            if (directories[i] === ".." && i > 0) {
                directories.splice(i - 1, 2);
                i -= 2;
            }
        }
    }

    returner.hostPart = urlParts[1];
    returner.directories = directories;
    returner.path = (urlParts[1] || "") + directories.join("/");
    returner.fileUrl = returner.path + (urlParts[4] || "");
    returner.url = returner.fileUrl + (urlParts[5] || "");
    return returner;
};

module.exports = abstractFileManager;

},{}],16:[function(require,module,exports){
var logger = require("../logger");
var environment = function(externalEnvironment, fileManagers) {
    this.fileManagers = fileManagers || [];
    externalEnvironment = externalEnvironment || {};

    var optionalFunctions = ["encodeBase64", "mimeLookup", "charsetLookup", "getSourceMapGenerator"],
        requiredFunctions = [],
        functions = requiredFunctions.concat(optionalFunctions);

    for (var i = 0; i < functions.length; i++) {
        var propName = functions[i],
            environmentFunc = externalEnvironment[propName];
        if (environmentFunc) {
            this[propName] = environmentFunc.bind(externalEnvironment);
        } else if (i < requiredFunctions.length) {
            this.warn("missing required function in environment - " + propName);
        }
    }
};

environment.prototype.getFileManager = function (filename, currentDirectory, options, environment, isSync) {

    if (!filename) {
        logger.warn("getFileManager called with no filename.. Please report this issue. continuing.");
    }
    if (currentDirectory == null) {
        logger.warn("getFileManager called with null directory.. Please report this issue. continuing.");
    }

    var fileManagers = this.fileManagers;
    if (options.pluginManager) {
        fileManagers = [].concat(fileManagers).concat(options.pluginManager.getFileManagers());
    }
    for (var i = fileManagers.length - 1; i >= 0 ; i--) {
        var fileManager = fileManagers[i];
        if (fileManager[isSync ? "supportsSync" : "supports"](filename, currentDirectory, options, environment)) {
            return fileManager;
        }
    }
    return null;
};

environment.prototype.addFileManager = function (fileManager) {
    this.fileManagers.push(fileManager);
};

environment.prototype.clearFileManagers = function () {
    this.fileManagers = [];
};

module.exports = environment;

},{"../logger":33}],17:[function(require,module,exports){
var Color = require("../tree/color"),
    functionRegistry = require("./function-registry");

// Color Blending
// ref: http://www.w3.org/TR/compositing-1

function colorBlend(mode, color1, color2) {
    var ab = color1.alpha, cb, // backdrop
        as = color2.alpha, cs, // source
        ar, cr, r = [];        // result

    ar = as + ab * (1 - as);
    for (var i = 0; i < 3; i++) {
        cb = color1.rgb[i] / 255;
        cs = color2.rgb[i] / 255;
        cr = mode(cb, cs);
        if (ar) {
            cr = (as * cs + ab * (cb -
                  as * (cb + cs - cr))) / ar;
        }
        r[i] = cr * 255;
    }

    return new Color(r, ar);
}

var colorBlendModeFunctions = {
    multiply: function(cb, cs) {
        return cb * cs;
    },
    screen: function(cb, cs) {
        return cb + cs - cb * cs;
    },
    overlay: function(cb, cs) {
        cb *= 2;
        return (cb <= 1) ?
            colorBlendModeFunctions.multiply(cb, cs) :
            colorBlendModeFunctions.screen(cb - 1, cs);
    },
    softlight: function(cb, cs) {
        var d = 1, e = cb;
        if (cs > 0.5) {
            e = 1;
            d = (cb > 0.25) ? Math.sqrt(cb)
                : ((16 * cb - 12) * cb + 4) * cb;
        }
        return cb - (1 - 2 * cs) * e * (d - cb);
    },
    hardlight: function(cb, cs) {
        return colorBlendModeFunctions.overlay(cs, cb);
    },
    difference: function(cb, cs) {
        return Math.abs(cb - cs);
    },
    exclusion: function(cb, cs) {
        return cb + cs - 2 * cb * cs;
    },

    // non-w3c functions:
    average: function(cb, cs) {
        return (cb + cs) / 2;
    },
    negation: function(cb, cs) {
        return 1 - Math.abs(cb + cs - 1);
    }
};

for (var f in colorBlendModeFunctions) {
    if (colorBlendModeFunctions.hasOwnProperty(f)) {
        colorBlend[f] = colorBlend.bind(null, colorBlendModeFunctions[f]);
    }
}

functionRegistry.addMultiple(colorBlend);

},{"../tree/color":50,"./function-registry":22}],18:[function(require,module,exports){
var Dimension = require("../tree/dimension"),
    Color = require("../tree/color"),
    Quoted = require("../tree/quoted"),
    Anonymous = require("../tree/anonymous"),
    functionRegistry = require("./function-registry"),
    colorFunctions;

function clamp(val) {
    return Math.min(1, Math.max(0, val));
}
function hsla(color) {
    return colorFunctions.hsla(color.h, color.s, color.l, color.a);
}
function number(n) {
    if (n instanceof Dimension) {
        return parseFloat(n.unit.is('%') ? n.value / 100 : n.value);
    } else if (typeof n === 'number') {
        return n;
    } else {
        throw {
            type: "Argument",
            message: "color functions take numbers as parameters"
        };
    }
}
function scaled(n, size) {
    if (n instanceof Dimension && n.unit.is('%')) {
        return parseFloat(n.value * size / 100);
    } else {
        return number(n);
    }
}
colorFunctions = {
    rgb: function (r, g, b) {
        return colorFunctions.rgba(r, g, b, 1.0);
    },
    rgba: function (r, g, b, a) {
        var rgb = [r, g, b].map(function (c) { return scaled(c, 255); });
        a = number(a);
        return new Color(rgb, a);
    },
    hsl: function (h, s, l) {
        return colorFunctions.hsla(h, s, l, 1.0);
    },
    hsla: function (h, s, l, a) {

        var m1, m2;

        function hue(h) {
            h = h < 0 ? h + 1 : (h > 1 ? h - 1 : h);
            if (h * 6 < 1) {
                return m1 + (m2 - m1) * h * 6;
            }
            else if (h * 2 < 1) {
                return m2;
            }
            else if (h * 3 < 2) {
                return m1 + (m2 - m1) * (2 / 3 - h) * 6;
            }
            else {
                return m1;
            }
        }

        h = (number(h) % 360) / 360;
        s = clamp(number(s)); l = clamp(number(l)); a = clamp(number(a));

        m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        m1 = l * 2 - m2;

        return colorFunctions.rgba(hue(h + 1 / 3) * 255,
            hue(h)       * 255,
            hue(h - 1 / 3) * 255,
            a);
    },

    hsv: function(h, s, v) {
        return colorFunctions.hsva(h, s, v, 1.0);
    },

    hsva: function(h, s, v, a) {
        h = ((number(h) % 360) / 360) * 360;
        s = number(s); v = number(v); a = number(a);

        var i, f;
        i = Math.floor((h / 60) % 6);
        f = (h / 60) - i;

        var vs = [v,
            v * (1 - s),
            v * (1 - f * s),
            v * (1 - (1 - f) * s)];
        var perm = [[0, 3, 1],
            [2, 0, 1],
            [1, 0, 3],
            [1, 2, 0],
            [3, 1, 0],
            [0, 1, 2]];

        return colorFunctions.rgba(vs[perm[i][0]] * 255,
            vs[perm[i][1]] * 255,
            vs[perm[i][2]] * 255,
            a);
    },

    hue: function (color) {
        return new Dimension(color.toHSL().h);
    },
    saturation: function (color) {
        return new Dimension(color.toHSL().s * 100, '%');
    },
    lightness: function (color) {
        return new Dimension(color.toHSL().l * 100, '%');
    },
    hsvhue: function(color) {
        return new Dimension(color.toHSV().h);
    },
    hsvsaturation: function (color) {
        return new Dimension(color.toHSV().s * 100, '%');
    },
    hsvvalue: function (color) {
        return new Dimension(color.toHSV().v * 100, '%');
    },
    red: function (color) {
        return new Dimension(color.rgb[0]);
    },
    green: function (color) {
        return new Dimension(color.rgb[1]);
    },
    blue: function (color) {
        return new Dimension(color.rgb[2]);
    },
    alpha: function (color) {
        return new Dimension(color.toHSL().a);
    },
    luma: function (color) {
        return new Dimension(color.luma() * color.alpha * 100, '%');
    },
    luminance: function (color) {
        var luminance =
            (0.2126 * color.rgb[0] / 255) +
                (0.7152 * color.rgb[1] / 255) +
                (0.0722 * color.rgb[2] / 255);

        return new Dimension(luminance * color.alpha * 100, '%');
    },
    saturate: function (color, amount, method) {
        // filter: saturate(3.2);
        // should be kept as is, so check for color
        if (!color.rgb) {
            return null;
        }
        var hsl = color.toHSL();

        if (typeof method !== "undefined" && method.value === "relative") {
            hsl.s +=  hsl.s * amount.value / 100;
        }
        else {
            hsl.s += amount.value / 100;
        }
        hsl.s = clamp(hsl.s);
        return hsla(hsl);
    },
    desaturate: function (color, amount, method) {
        var hsl = color.toHSL();

        if (typeof method !== "undefined" && method.value === "relative") {
            hsl.s -=  hsl.s * amount.value / 100;
        }
        else {
            hsl.s -= amount.value / 100;
        }
        hsl.s = clamp(hsl.s);
        return hsla(hsl);
    },
    lighten: function (color, amount, method) {
        var hsl = color.toHSL();

        if (typeof method !== "undefined" && method.value === "relative") {
            hsl.l +=  hsl.l * amount.value / 100;
        }
        else {
            hsl.l += amount.value / 100;
        }
        hsl.l = clamp(hsl.l);
        return hsla(hsl);
    },
    darken: function (color, amount, method) {
        var hsl = color.toHSL();

        if (typeof method !== "undefined" && method.value === "relative") {
            hsl.l -=  hsl.l * amount.value / 100;
        }
        else {
            hsl.l -= amount.value / 100;
        }
        hsl.l = clamp(hsl.l);
        return hsla(hsl);
    },
    fadein: function (color, amount, method) {
        var hsl = color.toHSL();

        if (typeof method !== "undefined" && method.value === "relative") {
            hsl.a +=  hsl.a * amount.value / 100;
        }
        else {
            hsl.a += amount.value / 100;
        }
        hsl.a = clamp(hsl.a);
        return hsla(hsl);
    },
    fadeout: function (color, amount, method) {
        var hsl = color.toHSL();

        if (typeof method !== "undefined" && method.value === "relative") {
            hsl.a -=  hsl.a * amount.value / 100;
        }
        else {
            hsl.a -= amount.value / 100;
        }
        hsl.a = clamp(hsl.a);
        return hsla(hsl);
    },
    fade: function (color, amount) {
        var hsl = color.toHSL();

        hsl.a = amount.value / 100;
        hsl.a = clamp(hsl.a);
        return hsla(hsl);
    },
    spin: function (color, amount) {
        var hsl = color.toHSL();
        var hue = (hsl.h + amount.value) % 360;

        hsl.h = hue < 0 ? 360 + hue : hue;

        return hsla(hsl);
    },
    //
    // Copyright (c) 2006-2009 Hampton Catlin, Natalie Weizenbaum, and Chris Eppstein
    // http://sass-lang.com
    //
    mix: function (color1, color2, weight) {
        if (!color1.toHSL || !color2.toHSL) {
            console.log(color2.type);
            console.dir(color2);
        }
        if (!weight) {
            weight = new Dimension(50);
        }
        var p = weight.value / 100.0;
        var w = p * 2 - 1;
        var a = color1.toHSL().a - color2.toHSL().a;

        var w1 = (((w * a == -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
        var w2 = 1 - w1;

        var rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2,
            color1.rgb[1] * w1 + color2.rgb[1] * w2,
            color1.rgb[2] * w1 + color2.rgb[2] * w2];

        var alpha = color1.alpha * p + color2.alpha * (1 - p);

        return new Color(rgb, alpha);
    },
    greyscale: function (color) {
        return colorFunctions.desaturate(color, new Dimension(100));
    },
    contrast: function (color, dark, light, threshold) {
        // filter: contrast(3.2);
        // should be kept as is, so check for color
        if (!color.rgb) {
            return null;
        }
        if (typeof light === 'undefined') {
            light = colorFunctions.rgba(255, 255, 255, 1.0);
        }
        if (typeof dark === 'undefined') {
            dark = colorFunctions.rgba(0, 0, 0, 1.0);
        }
        //Figure out which is actually light and dark!
        if (dark.luma() > light.luma()) {
            var t = light;
            light = dark;
            dark = t;
        }
        if (typeof threshold === 'undefined') {
            threshold = 0.43;
        } else {
            threshold = number(threshold);
        }
        if (color.luma() < threshold) {
            return light;
        } else {
            return dark;
        }
    },
    argb: function (color) {
        return new Anonymous(color.toARGB());
    },
    color: function(c) {
        if ((c instanceof Quoted) &&
            (/^#([a-f0-9]{6}|[a-f0-9]{3})$/i.test(c.value))) {
            return new Color(c.value.slice(1));
        }
        if ((c instanceof Color) || (c = Color.fromKeyword(c.value))) {
            c.value = undefined;
            return c;
        }
        throw {
            type:    "Argument",
            message: "argument must be a color keyword or 3/6 digit hex e.g. #FFF"
        };
    },
    tint: function(color, amount) {
        return colorFunctions.mix(colorFunctions.rgb(255, 255, 255), color, amount);
    },
    shade: function(color, amount) {
        return colorFunctions.mix(colorFunctions.rgb(0, 0, 0), color, amount);
    }
};
functionRegistry.addMultiple(colorFunctions);

},{"../tree/anonymous":46,"../tree/color":50,"../tree/dimension":56,"../tree/quoted":73,"./function-registry":22}],19:[function(require,module,exports){
module.exports = function(environment) {
    var Quoted = require("../tree/quoted"),
        URL = require("../tree/url"),
        functionRegistry = require("./function-registry"),
        fallback = function(functionThis, node) {
            return new URL(node, functionThis.index, functionThis.currentFileInfo).eval(functionThis.context);
        },
        logger = require('../logger');

    functionRegistry.add("data-uri", function(mimetypeNode, filePathNode) {

        if (!filePathNode) {
            filePathNode = mimetypeNode;
            mimetypeNode = null;
        }

        var mimetype = mimetypeNode && mimetypeNode.value;
        var filePath = filePathNode.value;
        var currentFileInfo = this.currentFileInfo;
        var currentDirectory = currentFileInfo.relativeUrls ?
            currentFileInfo.currentDirectory : currentFileInfo.entryPath;

        var fragmentStart = filePath.indexOf('#');
        var fragment = '';
        if (fragmentStart !== -1) {
            fragment = filePath.slice(fragmentStart);
            filePath = filePath.slice(0, fragmentStart);
        }

        var fileManager = environment.getFileManager(filePath, currentDirectory, this.context, environment, true);

        if (!fileManager) {
            return fallback(this, filePathNode);
        }

        var useBase64 = false;

        // detect the mimetype if not given
        if (!mimetypeNode) {

            mimetype = environment.mimeLookup(filePath);

            if (mimetype === "image/svg+xml") {
                useBase64 = false;
            } else {
                // use base 64 unless it's an ASCII or UTF-8 format
                var charset = environment.charsetLookup(mimetype);
                useBase64 = ['US-ASCII', 'UTF-8'].indexOf(charset) < 0;
            }
            if (useBase64) { mimetype += ';base64'; }
        }
        else {
            useBase64 = /;base64$/.test(mimetype);
        }

        var fileSync = fileManager.loadFileSync(filePath, currentDirectory, this.context, environment);
        if (!fileSync.contents) {
            logger.warn("Skipped data-uri embedding of " + filePath + " because file not found");
            return fallback(this, filePathNode || mimetypeNode);
        }
        var buf = fileSync.contents;
        if (useBase64 && !environment.encodeBase64) {
            return fallback(this, filePathNode);
        }

        buf = useBase64 ? environment.encodeBase64(buf) : encodeURIComponent(buf);

        var uri = "data:" + mimetype + ',' + buf + fragment;

        // IE8 cannot handle a data-uri larger than 32,768 characters. If this is exceeded
        // and the --ieCompat flag is enabled, return a normal url() instead.
        var DATA_URI_MAX = 32768;
        if (uri.length >= DATA_URI_MAX) {

            if (this.context.ieCompat !== false) {
                logger.warn("Skipped data-uri embedding of " + filePath + " because its size (" + uri.length +
                    " characters) exceeds IE8-safe " + DATA_URI_MAX + " characters!");

                return fallback(this, filePathNode || mimetypeNode);
            }
        }

        return new URL(new Quoted('"' + uri + '"', uri, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);
    });
};

},{"../logger":33,"../tree/quoted":73,"../tree/url":80,"./function-registry":22}],20:[function(require,module,exports){
var Keyword = require("../tree/keyword"),
    functionRegistry = require("./function-registry");

var defaultFunc = {
    eval: function () {
        var v = this.value_, e = this.error_;
        if (e) {
            throw e;
        }
        if (v != null) {
            return v ? Keyword.True : Keyword.False;
        }
    },
    value: function (v) {
        this.value_ = v;
    },
    error: function (e) {
        this.error_ = e;
    },
    reset: function () {
        this.value_ = this.error_ = null;
    }
};

functionRegistry.add("default", defaultFunc.eval.bind(defaultFunc));

module.exports = defaultFunc;

},{"../tree/keyword":65,"./function-registry":22}],21:[function(require,module,exports){
var Expression = require("../tree/expression");

var functionCaller = function(name, context, index, currentFileInfo) {
    this.name = name.toLowerCase();
    this.index = index;
    this.context = context;
    this.currentFileInfo = currentFileInfo;

    this.func = context.frames[0].functionRegistry.get(this.name);
};
functionCaller.prototype.isValid = function() {
    return Boolean(this.func);
};
functionCaller.prototype.call = function(args) {

    // This code is terrible and should be replaced as per this issue...
    // https://github.com/less/less.js/issues/2477
    if (Array.isArray(args)) {
        args = args.filter(function (item) {
            if (item.type === "Comment") {
                return false;
            }
            return true;
        })
        .map(function(item) {
            if (item.type === "Expression") {
                var subNodes = item.value.filter(function (item) {
                    if (item.type === "Comment") {
                        return false;
                    }
                    return true;
                });
                if (subNodes.length === 1) {
                    return subNodes[0];
                } else {
                    return new Expression(subNodes);
                }
            }
            return item;
        });
    }

    return this.func.apply(this, args);
};

module.exports = functionCaller;

},{"../tree/expression":59}],22:[function(require,module,exports){
function makeRegistry( base ) {
    return {
        _data: {},
        add: function(name, func) {
            // precautionary case conversion, as later querying of
            // the registry by function-caller uses lower case as well.
            name = name.toLowerCase();

            if (this._data.hasOwnProperty(name)) {
                //TODO warn
            }
            this._data[name] = func;
        },
        addMultiple: function(functions) {
            Object.keys(functions).forEach(
                function(name) {
                    this.add(name, functions[name]);
                }.bind(this));
        },
        get: function(name) {
            return this._data[name] || ( base && base.get( name ));
        },
        inherit : function() {
            return makeRegistry( this );
        }
    };
}

module.exports = makeRegistry( null );
},{}],23:[function(require,module,exports){
module.exports = function(environment) {
    var functions = {
        functionRegistry: require("./function-registry"),
        functionCaller: require("./function-caller")
    };

    //register functions
    require("./default");
    require("./color");
    require("./color-blending");
    require("./data-uri")(environment);
    require("./math");
    require("./number");
    require("./string");
    require("./svg")(environment);
    require("./types");

    return functions;
};

},{"./color":18,"./color-blending":17,"./data-uri":19,"./default":20,"./function-caller":21,"./function-registry":22,"./math":25,"./number":26,"./string":27,"./svg":28,"./types":29}],24:[function(require,module,exports){
var Dimension = require("../tree/dimension");

var MathHelper = function() {
};
MathHelper._math = function (fn, unit, n) {
    if (!(n instanceof Dimension)) {
        throw { type: "Argument", message: "argument must be a number" };
    }
    if (unit == null) {
        unit = n.unit;
    } else {
        n = n.unify();
    }
    return new Dimension(fn(parseFloat(n.value)), unit);
};
module.exports = MathHelper;
},{"../tree/dimension":56}],25:[function(require,module,exports){
var functionRegistry = require("./function-registry"),
    mathHelper = require("./math-helper.js");

var mathFunctions = {
    // name,  unit
    ceil:  null,
    floor: null,
    sqrt:  null,
    abs:   null,
    tan:   "",
    sin:   "",
    cos:   "",
    atan:  "rad",
    asin:  "rad",
    acos:  "rad"
};

for (var f in mathFunctions) {
    if (mathFunctions.hasOwnProperty(f)) {
        mathFunctions[f] = mathHelper._math.bind(null, Math[f], mathFunctions[f]);
    }
}

mathFunctions.round = function (n, f) {
    var fraction = typeof f === "undefined" ? 0 : f.value;
    return mathHelper._math(function(num) { return num.toFixed(fraction); }, null, n);
};

functionRegistry.addMultiple(mathFunctions);

},{"./function-registry":22,"./math-helper.js":24}],26:[function(require,module,exports){
var Dimension = require("../tree/dimension"),
    Anonymous = require("../tree/anonymous"),
    functionRegistry = require("./function-registry"),
    mathHelper = require("./math-helper.js");

var minMax = function (isMin, args) {
    args = Array.prototype.slice.call(args);
    switch(args.length) {
        case 0: throw { type: "Argument", message: "one or more arguments required" };
    }
    var i, j, current, currentUnified, referenceUnified, unit, unitStatic, unitClone,
        order  = [], // elems only contains original argument values.
        values = {}; // key is the unit.toString() for unified Dimension values,
    // value is the index into the order array.
    for (i = 0; i < args.length; i++) {
        current = args[i];
        if (!(current instanceof Dimension)) {
            if (Array.isArray(args[i].value)) {
                Array.prototype.push.apply(args, Array.prototype.slice.call(args[i].value));
            }
            continue;
        }
        currentUnified = current.unit.toString() === "" && unitClone !== undefined ? new Dimension(current.value, unitClone).unify() : current.unify();
        unit = currentUnified.unit.toString() === "" && unitStatic !== undefined ? unitStatic : currentUnified.unit.toString();
        unitStatic = unit !== "" && unitStatic === undefined || unit !== "" && order[0].unify().unit.toString() === "" ? unit : unitStatic;
        unitClone = unit !== "" && unitClone === undefined ? current.unit.toString() : unitClone;
        j = values[""] !== undefined && unit !== "" && unit === unitStatic ? values[""] : values[unit];
        if (j === undefined) {
            if (unitStatic !== undefined && unit !== unitStatic) {
                throw{ type: "Argument", message: "incompatible types" };
            }
            values[unit] = order.length;
            order.push(current);
            continue;
        }
        referenceUnified = order[j].unit.toString() === "" && unitClone !== undefined ? new Dimension(order[j].value, unitClone).unify() : order[j].unify();
        if ( isMin && currentUnified.value < referenceUnified.value ||
            !isMin && currentUnified.value > referenceUnified.value) {
            order[j] = current;
        }
    }
    if (order.length == 1) {
        return order[0];
    }
    args = order.map(function (a) { return a.toCSS(this.context); }).join(this.context.compress ? "," : ", ");
    return new Anonymous((isMin ? "min" : "max") + "(" + args + ")");
};
functionRegistry.addMultiple({
    min: function () {
        return minMax(true, arguments);
    },
    max: function () {
        return minMax(false, arguments);
    },
    convert: function (val, unit) {
        return val.convertTo(unit.value);
    },
    pi: function () {
        return new Dimension(Math.PI);
    },
    mod: function(a, b) {
        return new Dimension(a.value % b.value, a.unit);
    },
    pow: function(x, y) {
        if (typeof x === "number" && typeof y === "number") {
            x = new Dimension(x);
            y = new Dimension(y);
        } else if (!(x instanceof Dimension) || !(y instanceof Dimension)) {
            throw { type: "Argument", message: "arguments must be numbers" };
        }

        return new Dimension(Math.pow(x.value, y.value), x.unit);
    },
    percentage: function (n) {
        var result = mathHelper._math(function(num) {
            return num * 100;
        }, '%', n);

        return result;
    }
});

},{"../tree/anonymous":46,"../tree/dimension":56,"./function-registry":22,"./math-helper.js":24}],27:[function(require,module,exports){
var Quoted = require("../tree/quoted"),
    Anonymous = require("../tree/anonymous"),
    JavaScript = require("../tree/javascript"),
    functionRegistry = require("./function-registry");

functionRegistry.addMultiple({
    e: function (str) {
        return new Anonymous(str instanceof JavaScript ? str.evaluated : str.value);
    },
    escape: function (str) {
        return new Anonymous(
            encodeURI(str.value).replace(/=/g, "%3D").replace(/:/g, "%3A").replace(/#/g, "%23").replace(/;/g, "%3B")
                .replace(/\(/g, "%28").replace(/\)/g, "%29"));
    },
    replace: function (string, pattern, replacement, flags) {
        var result = string.value;
        replacement = (replacement.type === "Quoted") ?
            replacement.value : replacement.toCSS();
        result = result.replace(new RegExp(pattern.value, flags ? flags.value : ''), replacement);
        return new Quoted(string.quote || '', result, string.escaped);
    },
    '%': function (string /* arg, arg, ...*/) {
        var args = Array.prototype.slice.call(arguments, 1),
            result = string.value;

        for (var i = 0; i < args.length; i++) {
            /*jshint loopfunc:true */
            result = result.replace(/%[sda]/i, function(token) {
                var value = ((args[i].type === "Quoted") &&
                    token.match(/s/i)) ? args[i].value : args[i].toCSS();
                return token.match(/[A-Z]$/) ? encodeURIComponent(value) : value;
            });
        }
        result = result.replace(/%%/g, '%');
        return new Quoted(string.quote || '', result, string.escaped);
    }
});

},{"../tree/anonymous":46,"../tree/javascript":63,"../tree/quoted":73,"./function-registry":22}],28:[function(require,module,exports){
module.exports = function(environment) {
    var Dimension = require("../tree/dimension"),
        Color = require("../tree/color"),
        Expression = require("../tree/expression"),
        Quoted = require("../tree/quoted"),
        URL = require("../tree/url"),
        functionRegistry = require("./function-registry");

    functionRegistry.add("svg-gradient", function(direction) {

        var stops,
            gradientDirectionSvg,
            gradientType = "linear",
            rectangleDimension = 'x="0" y="0" width="1" height="1"',
            renderEnv = {compress: false},
            returner,
            directionValue = direction.toCSS(renderEnv),
			i, color, position, positionValue, alpha;

        function throwArgumentDescriptor() {
            throw { type: "Argument",
					message: "svg-gradient expects direction, start_color [start_position], [color position,]...," +
							" end_color [end_position] or direction, color list" };
        }

        if (arguments.length == 2) {
            if (arguments[1].value.length < 2) {
                throwArgumentDescriptor();
            }
            stops = arguments[1].value;
        } else if (arguments.length < 3) {
            throwArgumentDescriptor();
        } else {
            stops = Array.prototype.slice.call(arguments, 1);
        }

        switch (directionValue) {
            case "to bottom":
                gradientDirectionSvg = 'x1="0%" y1="0%" x2="0%" y2="100%"';
                break;
            case "to right":
                gradientDirectionSvg = 'x1="0%" y1="0%" x2="100%" y2="0%"';
                break;
            case "to bottom right":
                gradientDirectionSvg = 'x1="0%" y1="0%" x2="100%" y2="100%"';
                break;
            case "to top right":
                gradientDirectionSvg = 'x1="0%" y1="100%" x2="100%" y2="0%"';
                break;
            case "ellipse":
            case "ellipse at center":
                gradientType = "radial";
                gradientDirectionSvg = 'cx="50%" cy="50%" r="75%"';
                rectangleDimension = 'x="-50" y="-50" width="101" height="101"';
                break;
            default:
                throw { type: "Argument", message: "svg-gradient direction must be 'to bottom', 'to right'," +
                    " 'to bottom right', 'to top right' or 'ellipse at center'" };
        }
        returner = '<?xml version="1.0" ?>' +
            '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" viewBox="0 0 1 1" preserveAspectRatio="none">' +
            '<' + gradientType + 'Gradient id="gradient" gradientUnits="userSpaceOnUse" ' + gradientDirectionSvg + '>';

        for (i = 0; i < stops.length; i+= 1) {
            if (stops[i] instanceof Expression) {
                color = stops[i].value[0];
                position = stops[i].value[1];
            } else {
                color = stops[i];
                position = undefined;
            }

            if (!(color instanceof Color) || (!((i === 0 || i + 1 === stops.length) && position === undefined) && !(position instanceof Dimension))) {
                throwArgumentDescriptor();
            }
            positionValue = position ? position.toCSS(renderEnv) : i === 0 ? "0%" : "100%";
            alpha = color.alpha;
            returner += '<stop offset="' + positionValue + '" stop-color="' + color.toRGB() + '"' + (alpha < 1 ? ' stop-opacity="' + alpha + '"' : '') + '/>';
        }
        returner += '</' + gradientType + 'Gradient>' +
            '<rect ' + rectangleDimension + ' fill="url(#gradient)" /></svg>';

        returner = encodeURIComponent(returner);

        returner = "data:image/svg+xml," + returner;
        return new URL(new Quoted("'" + returner + "'", returner, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);
    });
};

},{"../tree/color":50,"../tree/dimension":56,"../tree/expression":59,"../tree/quoted":73,"../tree/url":80,"./function-registry":22}],29:[function(require,module,exports){
var Keyword = require("../tree/keyword"),
    DetachedRuleset = require("../tree/detached-ruleset"),
    Dimension = require("../tree/dimension"),
    Color = require("../tree/color"),
    Quoted = require("../tree/quoted"),
    Anonymous = require("../tree/anonymous"),
    URL = require("../tree/url"),
    Operation = require("../tree/operation"),
    functionRegistry = require("./function-registry");

var isa = function (n, Type) {
        return (n instanceof Type) ? Keyword.True : Keyword.False;
    },
    isunit = function (n, unit) {
        if (unit === undefined) {
            throw { type: "Argument", message: "missing the required second argument to isunit." };
        }
        unit = typeof unit.value === "string" ? unit.value : unit;
        if (typeof unit !== "string") {
            throw { type: "Argument", message: "Second argument to isunit should be a unit or a string." };
        }
        return (n instanceof Dimension) && n.unit.is(unit) ? Keyword.True : Keyword.False;
    },
    getItemsFromNode = function(node) {
        // handle non-array values as an array of length 1
        // return 'undefined' if index is invalid
        var items = Array.isArray(node.value) ?
            node.value : Array(node);

        return items;
    };
functionRegistry.addMultiple({
    isruleset: function (n) {
        return isa(n, DetachedRuleset);
    },
    iscolor: function (n) {
        return isa(n, Color);
    },
    isnumber: function (n) {
        return isa(n, Dimension);
    },
    isstring: function (n) {
        return isa(n, Quoted);
    },
    iskeyword: function (n) {
        return isa(n, Keyword);
    },
    isurl: function (n) {
        return isa(n, URL);
    },
    ispixel: function (n) {
        return isunit(n, 'px');
    },
    ispercentage: function (n) {
        return isunit(n, '%');
    },
    isem: function (n) {
        return isunit(n, 'em');
    },
    isunit: isunit,
    unit: function (val, unit) {
        if (!(val instanceof Dimension)) {
            throw { type: "Argument",
                message: "the first argument to unit must be a number" +
                    (val instanceof Operation ? ". Have you forgotten parenthesis?" : "") };
        }
        if (unit) {
            if (unit instanceof Keyword) {
                unit = unit.value;
            } else {
                unit = unit.toCSS();
            }
        } else {
            unit = "";
        }
        return new Dimension(val.value, unit);
    },
    "get-unit": function (n) {
        return new Anonymous(n.unit);
    },
    extract: function(values, index) {
        index = index.value - 1; // (1-based index)

        return getItemsFromNode(values)[index];
    },
    length: function(values) {
        return new Dimension(getItemsFromNode(values).length);
    }
});

},{"../tree/anonymous":46,"../tree/color":50,"../tree/detached-ruleset":55,"../tree/dimension":56,"../tree/keyword":65,"../tree/operation":71,"../tree/quoted":73,"../tree/url":80,"./function-registry":22}],30:[function(require,module,exports){
var contexts = require("./contexts"),
    Parser = require('./parser/parser'),
    FunctionImporter = require('./plugins/function-importer');

module.exports = function(environment) {

    // FileInfo = {
    //  'relativeUrls' - option - whether to adjust URL's to be relative
    //  'filename' - full resolved filename of current file
    //  'rootpath' - path to append to normal URLs for this node
    //  'currentDirectory' - path to the current file, absolute
    //  'rootFilename' - filename of the base file
    //  'entryPath' - absolute path to the entry file
    //  'reference' - whether the file should not be output and only output parts that are referenced

    var ImportManager = function(context, rootFileInfo) {
        this.rootFilename = rootFileInfo.filename;
        this.paths = context.paths || [];  // Search paths, when importing
        this.contents = {};             // map - filename to contents of all the files
        this.contentsIgnoredChars = {}; // map - filename to lines at the beginning of each file to ignore
        this.mime = context.mime;
        this.error = null;
        this.context = context;
        // Deprecated? Unused outside of here, could be useful.
        this.queue = [];        // Files which haven't been imported yet
        this.files = {};        // Holds the imported parse trees.
    };
    /**
     * Add an import to be imported
     * @param path - the raw path
     * @param tryAppendLessExtension - whether to try appending the less extension (if the path has no extension)
     * @param currentFileInfo - the current file info (used for instance to work out relative paths)
     * @param importOptions - import options
     * @param callback - callback for when it is imported
     */
    ImportManager.prototype.push = function (path, tryAppendLessExtension, currentFileInfo, importOptions, callback) {
        var importManager = this;
        this.queue.push(path);

        var fileParsedFunc = function (e, root, fullPath) {
            importManager.queue.splice(importManager.queue.indexOf(path), 1); // Remove the path from the queue

            var importedEqualsRoot = fullPath === importManager.rootFilename;
            if (importOptions.optional && e) {
                callback(null, {rules:[]}, false, null);
            }
            else {
                importManager.files[fullPath] = root;
                if (e && !importManager.error) { importManager.error = e; }
                callback(e, root, importedEqualsRoot, fullPath);
            }
        };

        var newFileInfo = {
            relativeUrls: this.context.relativeUrls,
            entryPath: currentFileInfo.entryPath,
            rootpath: currentFileInfo.rootpath,
            rootFilename: currentFileInfo.rootFilename
        };

        var fileManager = environment.getFileManager(path, currentFileInfo.currentDirectory, this.context, environment);

        if (!fileManager) {
            fileParsedFunc({ message: "Could not find a file-manager for " + path });
            return;
        }

        if (tryAppendLessExtension) {
            path = fileManager.tryAppendExtension(path, importOptions.plugin ? ".js" : ".less");
        }

        var loadFileCallback = function(loadedFile) {
            var resolvedFilename = loadedFile.filename,
                contents = loadedFile.contents.replace(/^\uFEFF/, '');

            // Pass on an updated rootpath if path of imported file is relative and file
            // is in a (sub|sup) directory
            //
            // Examples:
            // - If path of imported file is 'module/nav/nav.less' and rootpath is 'less/',
            //   then rootpath should become 'less/module/nav/'
            // - If path of imported file is '../mixins.less' and rootpath is 'less/',
            //   then rootpath should become 'less/../'
            newFileInfo.currentDirectory = fileManager.getPath(resolvedFilename);
            if (newFileInfo.relativeUrls) {
                newFileInfo.rootpath = fileManager.join(
                    (importManager.context.rootpath || ""),
                    fileManager.pathDiff(newFileInfo.currentDirectory, newFileInfo.entryPath));

                if (!fileManager.isPathAbsolute(newFileInfo.rootpath) && fileManager.alwaysMakePathsAbsolute()) {
                    newFileInfo.rootpath = fileManager.join(newFileInfo.entryPath, newFileInfo.rootpath);
                }
            }
            newFileInfo.filename = resolvedFilename;

            var newEnv = new contexts.Parse(importManager.context);

            newEnv.processImports = false;
            importManager.contents[resolvedFilename] = contents;

            if (currentFileInfo.reference || importOptions.reference) {
                newFileInfo.reference = true;
            }

            if (importOptions.plugin) {
                new FunctionImporter(newEnv, newFileInfo).eval(contents, function (e, root) {
                    fileParsedFunc(e, root, resolvedFilename);
                });
            } else if (importOptions.inline) {
                fileParsedFunc(null, contents, resolvedFilename);
            } else {
                new Parser(newEnv, importManager, newFileInfo).parse(contents, function (e, root) {
                    fileParsedFunc(e, root, resolvedFilename);
                });
            }
        };

        var promise = fileManager.loadFile(path, currentFileInfo.currentDirectory, this.context, environment,
            function(err, loadedFile) {
            if (err) {
                fileParsedFunc(err);
            } else {
                loadFileCallback(loadedFile);
            }
        });
        if (promise) {
            promise.then(loadFileCallback, fileParsedFunc);
        }
    };
    return ImportManager;
};

},{"./contexts":11,"./parser/parser":38,"./plugins/function-importer":40}],31:[function(require,module,exports){
module.exports = function(environment, fileManagers) {
    var SourceMapOutput, SourceMapBuilder, ParseTree, ImportManager, Environment;

    var less = {
        version: [2, 7, 2],
        data: require('./data'),
        tree: require('./tree'),
        Environment: (Environment = require("./environment/environment")),
        AbstractFileManager: require("./environment/abstract-file-manager"),
        environment: (environment = new Environment(environment, fileManagers)),
        visitors: require('./visitors'),
        Parser: require('./parser/parser'),
        functions: require('./functions')(environment),
        contexts: require("./contexts"),
        SourceMapOutput: (SourceMapOutput = require('./source-map-output')(environment)),
        SourceMapBuilder: (SourceMapBuilder = require('./source-map-builder')(SourceMapOutput, environment)),
        ParseTree: (ParseTree = require('./parse-tree')(SourceMapBuilder)),
        ImportManager: (ImportManager = require('./import-manager')(environment)),
        render: require("./render")(environment, ParseTree, ImportManager),
        parse: require("./parse")(environment, ParseTree, ImportManager),
        LessError: require('./less-error'),
        transformTree: require('./transform-tree'),
        utils: require('./utils'),
        PluginManager: require('./plugin-manager'),
        logger: require('./logger')
    };

    return less;
};

},{"./contexts":11,"./data":13,"./environment/abstract-file-manager":15,"./environment/environment":16,"./functions":23,"./import-manager":30,"./less-error":32,"./logger":33,"./parse":35,"./parse-tree":34,"./parser/parser":38,"./plugin-manager":39,"./render":41,"./source-map-builder":42,"./source-map-output":43,"./transform-tree":44,"./tree":62,"./utils":83,"./visitors":87}],32:[function(require,module,exports){
var utils = require("./utils");

var LessError = module.exports = function LessError(e, importManager, currentFilename) {

    Error.call(this);

    var filename = e.filename || currentFilename;

    if (importManager && filename) {
        var input = importManager.contents[filename],
            loc = utils.getLocation(e.index, input),
            line = loc.line,
            col  = loc.column,
            callLine = e.call && utils.getLocation(e.call, input).line,
            lines = input.split('\n');

        this.type = e.type || 'Syntax';
        this.filename = filename;
        this.index = e.index;
        this.line = typeof line === 'number' ? line + 1 : null;
        this.callLine = callLine + 1;
        this.callExtract = lines[callLine];
        this.column = col;
        this.extract = [
            lines[line - 1],
            lines[line],
            lines[line + 1]
        ];
    }
    this.message = e.message;
    this.stack = e.stack;
};

if (typeof Object.create === 'undefined') {
    var F = function () {};
    F.prototype = Error.prototype;
    LessError.prototype = new F();
} else {
    LessError.prototype = Object.create(Error.prototype);
}

LessError.prototype.constructor = LessError;

},{"./utils":83}],33:[function(require,module,exports){
module.exports = {
    error: function(msg) {
        this._fireEvent("error", msg);
    },
    warn: function(msg) {
        this._fireEvent("warn", msg);
    },
    info: function(msg) {
        this._fireEvent("info", msg);
    },
    debug: function(msg) {
        this._fireEvent("debug", msg);
    },
    addListener: function(listener) {
        this._listeners.push(listener);
    },
    removeListener: function(listener) {
        for (var i = 0; i < this._listeners.length; i++) {
            if (this._listeners[i] === listener) {
                this._listeners.splice(i, 1);
                return;
            }
        }
    },
    _fireEvent: function(type, msg) {
        for (var i = 0; i < this._listeners.length; i++) {
            var logFunction = this._listeners[i][type];
            if (logFunction) {
                logFunction(msg);
            }
        }
    },
    _listeners: []
};

},{}],34:[function(require,module,exports){
var LessError = require('./less-error'),
    transformTree = require("./transform-tree"),
    logger = require("./logger");

module.exports = function(SourceMapBuilder) {
    var ParseTree = function(root, imports) {
        this.root = root;
        this.imports = imports;
    };

    ParseTree.prototype.toCSS = function(options) {
        var evaldRoot, result = {}, sourceMapBuilder;
        try {
            evaldRoot = transformTree(this.root, options);
        } catch (e) {
            throw new LessError(e, this.imports);
        }

        try {
            var compress = Boolean(options.compress);
            if (compress) {
                logger.warn("The compress option has been deprecated. We recommend you use a dedicated css minifier, for instance see less-plugin-clean-css.");
            }

            var toCSSOptions = {
                compress: compress,
                dumpLineNumbers: options.dumpLineNumbers,
                strictUnits: Boolean(options.strictUnits),
                numPrecision: 8};

            if (options.sourceMap) {
                sourceMapBuilder = new SourceMapBuilder(options.sourceMap);
                result.css = sourceMapBuilder.toCSS(evaldRoot, toCSSOptions, this.imports);
            } else {
                result.css = evaldRoot.toCSS(toCSSOptions);
            }
        } catch (e) {
            throw new LessError(e, this.imports);
        }

        if (options.pluginManager) {
            var postProcessors = options.pluginManager.getPostProcessors();
            for (var i = 0; i < postProcessors.length; i++) {
                result.css = postProcessors[i].process(result.css, { sourceMap: sourceMapBuilder, options: options, imports: this.imports });
            }
        }
        if (options.sourceMap) {
            result.map = sourceMapBuilder.getExternalSourceMap();
        }

        result.imports = [];
        for (var file in this.imports.files) {
            if (this.imports.files.hasOwnProperty(file) && file !== this.imports.rootFilename) {
                result.imports.push(file);
            }
        }
        return result;
    };
    return ParseTree;
};

},{"./less-error":32,"./logger":33,"./transform-tree":44}],35:[function(require,module,exports){
var PromiseConstructor,
    contexts = require("./contexts"),
    Parser = require('./parser/parser'),
    PluginManager = require('./plugin-manager');

module.exports = function(environment, ParseTree, ImportManager) {
    var parse = function (input, options, callback) {
        options = options || {};

        if (typeof options === 'function') {
            callback = options;
            options = {};
        }

        if (!callback) {
            if (!PromiseConstructor) {
                PromiseConstructor = typeof Promise === 'undefined' ? require('promise') : Promise;
            }
            var self = this;
            return new PromiseConstructor(function (resolve, reject) {
                parse.call(self, input, options, function(err, output) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(output);
                    }
                });
            });
        } else {
            var context,
                rootFileInfo,
                pluginManager = new PluginManager(this);

            pluginManager.addPlugins(options.plugins);
            options.pluginManager = pluginManager;

            context = new contexts.Parse(options);

            if (options.rootFileInfo) {
                rootFileInfo = options.rootFileInfo;
            } else {
                var filename = options.filename || "input";
                var entryPath = filename.replace(/[^\/\\]*$/, "");
                rootFileInfo = {
                    filename: filename,
                    relativeUrls: context.relativeUrls,
                    rootpath: context.rootpath || "",
                    currentDirectory: entryPath,
                    entryPath: entryPath,
                    rootFilename: filename
                };
                // add in a missing trailing slash
                if (rootFileInfo.rootpath && rootFileInfo.rootpath.slice(-1) !== "/") {
                    rootFileInfo.rootpath += "/";
                }
            }

            var imports = new ImportManager(context, rootFileInfo);

            new Parser(context, imports, rootFileInfo)
                .parse(input, function (e, root) {
                if (e) { return callback(e); }
                callback(null, root, imports, options);
            }, options);
        }
    };
    return parse;
};

},{"./contexts":11,"./parser/parser":38,"./plugin-manager":39,"promise":undefined}],36:[function(require,module,exports){
// Split the input into chunks.
module.exports = function (input, fail) {
    var len = input.length, level = 0, parenLevel = 0,
        lastOpening, lastOpeningParen, lastMultiComment, lastMultiCommentEndBrace,
        chunks = [], emitFrom = 0,
        chunkerCurrentIndex, currentChunkStartIndex, cc, cc2, matched;

    function emitChunk(force) {
        var len = chunkerCurrentIndex - emitFrom;
        if (((len < 512) && !force) || !len) {
            return;
        }
        chunks.push(input.slice(emitFrom, chunkerCurrentIndex + 1));
        emitFrom = chunkerCurrentIndex + 1;
    }

    for (chunkerCurrentIndex = 0; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
        cc = input.charCodeAt(chunkerCurrentIndex);
        if (((cc >= 97) && (cc <= 122)) || (cc < 34)) {
            // a-z or whitespace
            continue;
        }

        switch (cc) {
            case 40:                        // (
                parenLevel++;
                lastOpeningParen = chunkerCurrentIndex;
                continue;
            case 41:                        // )
                if (--parenLevel < 0) {
                    return fail("missing opening `(`", chunkerCurrentIndex);
                }
                continue;
            case 59:                        // ;
                if (!parenLevel) { emitChunk(); }
                continue;
            case 123:                       // {
                level++;
                lastOpening = chunkerCurrentIndex;
                continue;
            case 125:                       // }
                if (--level < 0) {
                    return fail("missing opening `{`", chunkerCurrentIndex);
                }
                if (!level && !parenLevel) { emitChunk(); }
                continue;
            case 92:                        // \
                if (chunkerCurrentIndex < len - 1) { chunkerCurrentIndex++; continue; }
                return fail("unescaped `\\`", chunkerCurrentIndex);
            case 34:
            case 39:
            case 96:                        // ", ' and `
                matched = 0;
                currentChunkStartIndex = chunkerCurrentIndex;
                for (chunkerCurrentIndex = chunkerCurrentIndex + 1; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
                    cc2 = input.charCodeAt(chunkerCurrentIndex);
                    if (cc2 > 96) { continue; }
                    if (cc2 == cc) { matched = 1; break; }
                    if (cc2 == 92) {        // \
                        if (chunkerCurrentIndex == len - 1) {
                            return fail("unescaped `\\`", chunkerCurrentIndex);
                        }
                        chunkerCurrentIndex++;
                    }
                }
                if (matched) { continue; }
                return fail("unmatched `" + String.fromCharCode(cc) + "`", currentChunkStartIndex);
            case 47:                        // /, check for comment
                if (parenLevel || (chunkerCurrentIndex == len - 1)) { continue; }
                cc2 = input.charCodeAt(chunkerCurrentIndex + 1);
                if (cc2 == 47) {
                    // //, find lnfeed
                    for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
                        cc2 = input.charCodeAt(chunkerCurrentIndex);
                        if ((cc2 <= 13) && ((cc2 == 10) || (cc2 == 13))) { break; }
                    }
                } else if (cc2 == 42) {
                    // /*, find */
                    lastMultiComment = currentChunkStartIndex = chunkerCurrentIndex;
                    for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len - 1; chunkerCurrentIndex++) {
                        cc2 = input.charCodeAt(chunkerCurrentIndex);
                        if (cc2 == 125) { lastMultiCommentEndBrace = chunkerCurrentIndex; }
                        if (cc2 != 42) { continue; }
                        if (input.charCodeAt(chunkerCurrentIndex + 1) == 47) { break; }
                    }
                    if (chunkerCurrentIndex == len - 1) {
                        return fail("missing closing `*/`", currentChunkStartIndex);
                    }
                    chunkerCurrentIndex++;
                }
                continue;
            case 42:                       // *, check for unmatched */
                if ((chunkerCurrentIndex < len - 1) && (input.charCodeAt(chunkerCurrentIndex + 1) == 47)) {
                    return fail("unmatched `/*`", chunkerCurrentIndex);
                }
                continue;
        }
    }

    if (level !== 0) {
        if ((lastMultiComment > lastOpening) && (lastMultiCommentEndBrace > lastMultiComment)) {
            return fail("missing closing `}` or `*/`", lastOpening);
        } else {
            return fail("missing closing `}`", lastOpening);
        }
    } else if (parenLevel !== 0) {
        return fail("missing closing `)`", lastOpeningParen);
    }

    emitChunk(true);
    return chunks;
};

},{}],37:[function(require,module,exports){
var chunker = require('./chunker');

module.exports = function() {
    var input,       // LeSS input string
        j,           // current chunk
        saveStack = [],   // holds state for backtracking
        furthest,    // furthest index the parser has gone to
        furthestPossibleErrorMessage,// if this is furthest we got to, this is the probably cause
        chunks,      // chunkified input
        current,     // current chunk
        currentPos,  // index of current chunk, in `input`
        parserInput = {};

    var CHARCODE_SPACE = 32,
        CHARCODE_TAB = 9,
        CHARCODE_LF = 10,
        CHARCODE_CR = 13,
        CHARCODE_PLUS = 43,
        CHARCODE_COMMA = 44,
        CHARCODE_FORWARD_SLASH = 47,
        CHARCODE_9 = 57;

    function skipWhitespace(length) {
        var oldi = parserInput.i, oldj = j,
            curr = parserInput.i - currentPos,
            endIndex = parserInput.i + current.length - curr,
            mem = (parserInput.i += length),
            inp = input,
            c, nextChar, comment;

        for (; parserInput.i < endIndex; parserInput.i++) {
            c = inp.charCodeAt(parserInput.i);

            if (parserInput.autoCommentAbsorb && c === CHARCODE_FORWARD_SLASH) {
                nextChar = inp.charAt(parserInput.i + 1);
                if (nextChar === '/') {
                    comment = {index: parserInput.i, isLineComment: true};
                    var nextNewLine = inp.indexOf("\n", parserInput.i + 2);
                    if (nextNewLine < 0) {
                        nextNewLine = endIndex;
                    }
                    parserInput.i = nextNewLine;
                    comment.text = inp.substr(comment.index, parserInput.i - comment.index);
                    parserInput.commentStore.push(comment);
                    continue;
                } else if (nextChar === '*') {
                    var nextStarSlash = inp.indexOf("*/", parserInput.i + 2);
                    if (nextStarSlash >= 0) {
                        comment = {
                            index: parserInput.i,
                            text: inp.substr(parserInput.i, nextStarSlash + 2 - parserInput.i),
                            isLineComment: false
                        };
                        parserInput.i += comment.text.length - 1;
                        parserInput.commentStore.push(comment);
                        continue;
                    }
                }
                break;
            }

            if ((c !== CHARCODE_SPACE) && (c !== CHARCODE_LF) && (c !== CHARCODE_TAB) && (c !== CHARCODE_CR)) {
                break;
            }
        }

        current = current.slice(length + parserInput.i - mem + curr);
        currentPos = parserInput.i;

        if (!current.length) {
            if (j < chunks.length - 1) {
                current = chunks[++j];
                skipWhitespace(0); // skip space at the beginning of a chunk
                return true; // things changed
            }
            parserInput.finished = true;
        }

        return oldi !== parserInput.i || oldj !== j;
    }

    parserInput.save = function() {
        currentPos = parserInput.i;
        saveStack.push( { current: current, i: parserInput.i, j: j });
    };
    parserInput.restore = function(possibleErrorMessage) {

        if (parserInput.i > furthest || (parserInput.i === furthest && possibleErrorMessage && !furthestPossibleErrorMessage)) {
            furthest = parserInput.i;
            furthestPossibleErrorMessage = possibleErrorMessage;
        }
        var state = saveStack.pop();
        current = state.current;
        currentPos = parserInput.i = state.i;
        j = state.j;
    };
    parserInput.forget = function() {
        saveStack.pop();
    };
    parserInput.isWhitespace = function (offset) {
        var pos = parserInput.i + (offset || 0),
            code = input.charCodeAt(pos);
        return (code === CHARCODE_SPACE || code === CHARCODE_CR || code === CHARCODE_TAB || code === CHARCODE_LF);
    };

    // Specialization of $(tok)
    parserInput.$re = function(tok) {
        if (parserInput.i > currentPos) {
            current = current.slice(parserInput.i - currentPos);
            currentPos = parserInput.i;
        }

        var m = tok.exec(current);
        if (!m) {
            return null;
        }

        skipWhitespace(m[0].length);
        if (typeof m === "string") {
            return m;
        }

        return m.length === 1 ? m[0] : m;
    };

    parserInput.$char = function(tok) {
        if (input.charAt(parserInput.i) !== tok) {
            return null;
        }
        skipWhitespace(1);
        return tok;
    };

    parserInput.$str = function(tok) {
        var tokLength = tok.length;

        // https://jsperf.com/string-startswith/21
        for (var i = 0; i < tokLength; i++) {
            if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {
                return null;
            }
        }

        skipWhitespace(tokLength);
        return tok;
    };

    parserInput.$quoted = function() {

        var startChar = input.charAt(parserInput.i);
        if (startChar !== "'" && startChar !== '"') {
            return;
        }
        var length = input.length,
            currentPosition = parserInput.i;

        for (var i = 1; i + currentPosition < length; i++) {
            var nextChar = input.charAt(i + currentPosition);
            switch(nextChar) {
                case "\\":
                    i++;
                    continue;
                case "\r":
                case "\n":
                    break;
                case startChar:
                    var str = input.substr(currentPosition, i + 1);
                    skipWhitespace(i + 1);
                    return str;
                default:
            }
        }
        return null;
    };

    parserInput.autoCommentAbsorb = true;
    parserInput.commentStore = [];
    parserInput.finished = false;

    // Same as $(), but don't change the state of the parser,
    // just return the match.
    parserInput.peek = function(tok) {
        if (typeof tok === 'string') {
            // https://jsperf.com/string-startswith/21
            for (var i = 0; i < tok.length; i++) {
                if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {
                    return false;
                }
            }
            return true;
        } else {
            return tok.test(current);
        }
    };

    // Specialization of peek()
    // TODO remove or change some currentChar calls to peekChar
    parserInput.peekChar = function(tok) {
        return input.charAt(parserInput.i) === tok;
    };

    parserInput.currentChar = function() {
        return input.charAt(parserInput.i);
    };

    parserInput.getInput = function() {
        return input;
    };

    parserInput.peekNotNumeric = function() {
        var c = input.charCodeAt(parserInput.i);
        //Is the first char of the dimension 0-9, '.', '+' or '-'
        return (c > CHARCODE_9 || c < CHARCODE_PLUS) || c === CHARCODE_FORWARD_SLASH || c === CHARCODE_COMMA;
    };

    parserInput.start = function(str, chunkInput, failFunction) {
        input = str;
        parserInput.i = j = currentPos = furthest = 0;

        // chunking apparently makes things quicker (but my tests indicate
        // it might actually make things slower in node at least)
        // and it is a non-perfect parse - it can't recognise
        // unquoted urls, meaning it can't distinguish comments
        // meaning comments with quotes or {}() in them get 'counted'
        // and then lead to parse errors.
        // In addition if the chunking chunks in the wrong place we might
        // not be able to parse a parser statement in one go
        // this is officially deprecated but can be switched on via an option
        // in the case it causes too much performance issues.
        if (chunkInput) {
            chunks = chunker(str, failFunction);
        } else {
            chunks = [str];
        }

        current = chunks[0];

        skipWhitespace(0);
    };

    parserInput.end = function() {
        var message,
            isFinished = parserInput.i >= input.length;

        if (parserInput.i < furthest) {
            message = furthestPossibleErrorMessage;
            parserInput.i = furthest;
        }
        return {
            isFinished: isFinished,
            furthest: parserInput.i,
            furthestPossibleErrorMessage: message,
            furthestReachedEnd: parserInput.i >= input.length - 1,
            furthestChar: input[parserInput.i]
        };
    };

    return parserInput;
};

},{"./chunker":36}],38:[function(require,module,exports){
var LessError = require('../less-error'),
    tree = require("../tree"),
    visitors = require("../visitors"),
    getParserInput = require("./parser-input"),
    utils = require("../utils");

//
// less.js - parser
//
//    A relatively straight-forward predictive parser.
//    There is no tokenization/lexing stage, the input is parsed
//    in one sweep.
//
//    To make the parser fast enough to run in the browser, several
//    optimization had to be made:
//
//    - Matching and slicing on a huge input is often cause of slowdowns.
//      The solution is to chunkify the input into smaller strings.
//      The chunks are stored in the `chunks` var,
//      `j` holds the current chunk index, and `currentPos` holds
//      the index of the current chunk in relation to `input`.
//      This gives us an almost 4x speed-up.
//
//    - In many cases, we don't need to match individual tokens;
//      for example, if a value doesn't hold any variables, operations
//      or dynamic references, the parser can effectively 'skip' it,
//      treating it as a literal.
//      An example would be '1px solid #000' - which evaluates to itself,
//      we don't need to know what the individual components are.
//      The drawback, of course is that you don't get the benefits of
//      syntax-checking on the CSS. This gives us a 50% speed-up in the parser,
//      and a smaller speed-up in the code-gen.
//
//
//    Token matching is done with the `$` function, which either takes
//    a terminal string or regexp, or a non-terminal function to call.
//    It also takes care of moving all the indices forwards.
//`
//
var Parser = function Parser(context, imports, fileInfo) {
    var parsers,
        parserInput = getParserInput();

    function error(msg, type) {
        throw new LessError(
            {
                index: parserInput.i,
                filename: fileInfo.filename,
                type: type || 'Syntax',
                message: msg
            },
            imports
        );
    }

    function expect(arg, msg, index) {
        // some older browsers return typeof 'function' for RegExp
        var result = (arg instanceof Function) ? arg.call(parsers) : parserInput.$re(arg);
        if (result) {
            return result;
        }
        error(msg || (typeof arg === 'string' ? "expected '" + arg + "' got '" + parserInput.currentChar() + "'"
                                               : "unexpected token"));
    }

    // Specialization of expect()
    function expectChar(arg, msg) {
        if (parserInput.$char(arg)) {
            return arg;
        }
        error(msg || "expected '" + arg + "' got '" + parserInput.currentChar() + "'");
    }

    function getDebugInfo(index) {
        var filename = fileInfo.filename;

        return {
            lineNumber: utils.getLocation(index, parserInput.getInput()).line + 1,
            fileName: filename
        };
    }

    //
    // The Parser
    //
    return {

        //
        // Parse an input string into an abstract syntax tree,
        // @param str A string containing 'less' markup
        // @param callback call `callback` when done.
        // @param [additionalData] An optional map which can contains vars - a map (key, value) of variables to apply
        //
        parse: function (str, callback, additionalData) {
            var root, error = null, globalVars, modifyVars, ignored, preText = "";

            globalVars = (additionalData && additionalData.globalVars) ? Parser.serializeVars(additionalData.globalVars) + '\n' : '';
            modifyVars = (additionalData && additionalData.modifyVars) ? '\n' + Parser.serializeVars(additionalData.modifyVars) : '';

            if (context.pluginManager) {
                var preProcessors = context.pluginManager.getPreProcessors();
                for (var i = 0; i < preProcessors.length; i++) {
                    str = preProcessors[i].process(str, { context: context, imports: imports, fileInfo: fileInfo });
                }
            }

            if (globalVars || (additionalData && additionalData.banner)) {
                preText = ((additionalData && additionalData.banner) ? additionalData.banner : "") + globalVars;
                ignored = imports.contentsIgnoredChars;
                ignored[fileInfo.filename] = ignored[fileInfo.filename] || 0;
                ignored[fileInfo.filename] += preText.length;
            }

            str = str.replace(/\r\n?/g, '\n');
            // Remove potential UTF Byte Order Mark
            str = preText + str.replace(/^\uFEFF/, '') + modifyVars;
            imports.contents[fileInfo.filename] = str;

            // Start with the primary rule.
            // The whole syntax tree is held under a Ruleset node,
            // with the `root` property set to true, so no `{}` are
            // output. The callback is called when the input is parsed.
            try {
                parserInput.start(str, context.chunkInput, function fail(msg, index) {
                    throw new LessError({
                        index: index,
                        type: 'Parse',
                        message: msg,
                        filename: fileInfo.filename
                    }, imports);
                });

                root = new(tree.Ruleset)(null, this.parsers.primary());
                root.root = true;
                root.firstRoot = true;
            } catch (e) {
                return callback(new LessError(e, imports, fileInfo.filename));
            }

            // If `i` is smaller than the `input.length - 1`,
            // it means the parser wasn't able to parse the whole
            // string, so we've got a parsing error.
            //
            // We try to extract a \n delimited string,
            // showing the line where the parse error occurred.
            // We split it up into two parts (the part which parsed,
            // and the part which didn't), so we can color them differently.
            var endInfo = parserInput.end();
            if (!endInfo.isFinished) {

                var message = endInfo.furthestPossibleErrorMessage;

                if (!message) {
                    message = "Unrecognised input";
                    if (endInfo.furthestChar === '}') {
                        message += ". Possibly missing opening '{'";
                    } else if (endInfo.furthestChar === ')') {
                        message += ". Possibly missing opening '('";
                    } else if (endInfo.furthestReachedEnd) {
                        message += ". Possibly missing something";
                    }
                }

                error = new LessError({
                    type: "Parse",
                    message: message,
                    index: endInfo.furthest,
                    filename: fileInfo.filename
                }, imports);
            }

            var finish = function (e) {
                e = error || e || imports.error;

                if (e) {
                    if (!(e instanceof LessError)) {
                        e = new LessError(e, imports, fileInfo.filename);
                    }

                    return callback(e);
                }
                else {
                    return callback(null, root);
                }
            };

            if (context.processImports !== false) {
                new visitors.ImportVisitor(imports, finish)
                    .run(root);
            } else {
                return finish();
            }
        },

        //
        // Here in, the parsing rules/functions
        //
        // The basic structure of the syntax tree generated is as follows:
        //
        //   Ruleset ->  Rule -> Value -> Expression -> Entity
        //
        // Here's some Less code:
        //
        //    .class {
        //      color: #fff;
        //      border: 1px solid #000;
        //      width: @w + 4px;
        //      > .child {...}
        //    }
        //
        // And here's what the parse tree might look like:
        //
        //     Ruleset (Selector '.class', [
        //         Rule ("color",  Value ([Expression [Color #fff]]))
        //         Rule ("border", Value ([Expression [Dimension 1px][Keyword "solid"][Color #000]]))
        //         Rule ("width",  Value ([Expression [Operation " + " [Variable "@w"][Dimension 4px]]]))
        //         Ruleset (Selector [Element '>', '.child'], [...])
        //     ])
        //
        //  In general, most rules will try to parse a token with the `$re()` function, and if the return
        //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check
        //  first, before parsing, that's when we use `peek()`.
        //
        parsers: parsers = {
            //
            // The `primary` rule is the *entry* and *exit* point of the parser.
            // The rules here can appear at any level of the parse tree.
            //
            // The recursive nature of the grammar is an interplay between the `block`
            // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,
            // as represented by this simplified grammar:
            //
            //     primary    (ruleset | rule)+
            //     ruleset    selector+ block
            //     block      '{' primary '}'
            //
            // Only at one point is the primary rule not called from the
            // block rule: at the root level.
            //
            primary: function () {
                var mixin = this.mixin, root = [], node;

                while (true) {
                    while (true) {
                        node = this.comment();
                        if (!node) { break; }
                        root.push(node);
                    }
                    // always process comments before deciding if finished
                    if (parserInput.finished) {
                        break;
                    }
                    if (parserInput.peek('}')) {
                        break;
                    }

                    node = this.extendRule();
                    if (node) {
                        root = root.concat(node);
                        continue;
                    }

                    node = mixin.definition() || this.rule() || this.ruleset() ||
                        mixin.call() || this.rulesetCall() || this.entities.call() || this.directive();
                    if (node) {
                        root.push(node);
                    } else {
                        var foundSemiColon = false;
                        while (parserInput.$char(";")) {
                            foundSemiColon = true;
                        }
                        if (!foundSemiColon) {
                            break;
                        }
                    }
                }

                return root;
            },

            // comments are collected by the main parsing mechanism and then assigned to nodes
            // where the current structure allows it
            comment: function () {
                if (parserInput.commentStore.length) {
                    var comment = parserInput.commentStore.shift();
                    return new(tree.Comment)(comment.text, comment.isLineComment, comment.index, fileInfo);
                }
            },

            //
            // Entities are tokens which can be found inside an Expression
            //
            entities: {
                //
                // A string, which supports escaping " and '
                //
                //     "milky way" 'he\'s the one!'
                //
                quoted: function () {
                    var str, index = parserInput.i, isEscaped = false;

                    parserInput.save();
                    if (parserInput.$char("~")) {
                        isEscaped = true;
                    }
                    str = parserInput.$quoted();
                    if (!str) {
                        parserInput.restore();
                        return;
                    }
                    parserInput.forget();

                    return new(tree.Quoted)(str.charAt(0), str.substr(1, str.length - 2), isEscaped, index, fileInfo);
                },

                //
                // A catch-all word, such as:
                //
                //     black border-collapse
                //
                keyword: function () {
                    var k = parserInput.$char("%") || parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]*/);
                    if (k) {
                        return tree.Color.fromKeyword(k) || new(tree.Keyword)(k);
                    }
                },

                //
                // A function call
                //
                //     rgb(255, 0, 255)
                //
                // We also try to catch IE's `alpha()`, but let the `alpha` parser
                // deal with the details.
                //
                // The arguments are parsed with the `entities.arguments` parser.
                //
                call: function () {
                    var name, nameLC, args, alpha, index = parserInput.i;

                    // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18
                    if (parserInput.peek(/^url\(/i)) {
                        return;
                    }

                    parserInput.save();

                    name = parserInput.$re(/^([\w-]+|%|progid:[\w\.]+)\(/);
                    if (!name) { parserInput.forget(); return; }

                    name = name[1];
                    nameLC = name.toLowerCase();

                    if (nameLC === 'alpha') {
                        alpha = parsers.alpha();
                        if (alpha) {
                            parserInput.forget();
                            return alpha;
                        }
                    }

                    args = this.arguments();

                    if (! parserInput.$char(')')) {
                        parserInput.restore("Could not parse call arguments or missing ')'");
                        return;
                    }

                    parserInput.forget();
                    return new(tree.Call)(name, args, index, fileInfo);
                },
                arguments: function () {
                    var argsSemiColon = [], argsComma = [],
                        expressions = [],
                        isSemiColonSeparated, value, arg;

                    parserInput.save();

                    while (true) {

                        arg = parsers.detachedRuleset() || this.assignment() || parsers.expression();

                        if (!arg) {
                            break;
                        }

                        value = arg;

                        if (arg.value && arg.value.length == 1) {
                            value = arg.value[0];
                        }

                        if (value) {
                            expressions.push(value);
                        }

                        argsComma.push(value);

                        if (parserInput.$char(',')) {
                            continue;
                        }

                        if (parserInput.$char(';') || isSemiColonSeparated) {

                            isSemiColonSeparated = true;

                            if (expressions.length > 1) {
                                value = new(tree.Value)(expressions);
                            }
                            argsSemiColon.push(value);

                            expressions = [];
                        }
                    }

                    parserInput.forget();
                    return isSemiColonSeparated ? argsSemiColon : argsComma;
                },
                literal: function () {
                    return this.dimension() ||
                           this.color() ||
                           this.quoted() ||
                           this.unicodeDescriptor();
                },

                // Assignments are argument entities for calls.
                // They are present in ie filter properties as shown below.
                //
                //     filter: progid:DXImageTransform.Microsoft.Alpha( *opacity=50* )
                //

                assignment: function () {
                    var key, value;
                    parserInput.save();
                    key = parserInput.$re(/^\w+(?=\s?=)/i);
                    if (!key) {
                        parserInput.restore();
                        return;
                    }
                    if (!parserInput.$char('=')) {
                        parserInput.restore();
                        return;
                    }
                    value = parsers.entity();
                    if (value) {
                        parserInput.forget();
                        return new(tree.Assignment)(key, value);
                    } else {
                        parserInput.restore();
                    }
                },

                //
                // Parse url() tokens
                //
                // We use a specific rule for urls, because they don't really behave like
                // standard function calls. The difference is that the argument doesn't have
                // to be enclosed within a string, so it can't be parsed as an Expression.
                //
                url: function () {
                    var value, index = parserInput.i;

                    parserInput.autoCommentAbsorb = false;

                    if (!parserInput.$str("url(")) {
                        parserInput.autoCommentAbsorb = true;
                        return;
                    }

                    value = this.quoted() || this.variable() ||
                            parserInput.$re(/^(?:(?:\\[\(\)'"])|[^\(\)'"])+/) || "";

                    parserInput.autoCommentAbsorb = true;

                    expectChar(')');

                    return new(tree.URL)((value.value != null || value instanceof tree.Variable) ?
                                        value : new(tree.Anonymous)(value), index, fileInfo);
                },

                //
                // A Variable entity, such as `@fink`, in
                //
                //     width: @fink + 2px
                //
                // We use a different parser for variable definitions,
                // see `parsers.variable`.
                //
                variable: function () {
                    var name, index = parserInput.i;

                    if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^@@?[\w-]+/))) {
                        return new(tree.Variable)(name, index, fileInfo);
                    }
                },

                // A variable entity using the protective {} e.g. @{var}
                variableCurly: function () {
                    var curly, index = parserInput.i;

                    if (parserInput.currentChar() === '@' && (curly = parserInput.$re(/^@\{([\w-]+)\}/))) {
                        return new(tree.Variable)("@" + curly[1], index, fileInfo);
                    }
                },

                //
                // A Hexadecimal color
                //
                //     #4F3C2F
                //
                // `rgb` and `hsl` colors are parsed through the `entities.call` parser.
                //
                color: function () {
                    var rgb;

                    if (parserInput.currentChar() === '#' && (rgb = parserInput.$re(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})/))) {
                        // strip colons, brackets, whitespaces and other characters that should not
                        // definitely be part of color string
                        var colorCandidateString = rgb.input.match(/^#([\w]+).*/);
                        colorCandidateString = colorCandidateString[1];
                        if (!colorCandidateString.match(/^[A-Fa-f0-9]+$/)) { // verify if candidate consists only of allowed HEX characters
                            error("Invalid HEX color code");
                        }
                        return new(tree.Color)(rgb[1], undefined, '#' + colorCandidateString);
                    }
                },

                colorKeyword: function () {
                    parserInput.save();
                    var autoCommentAbsorb = parserInput.autoCommentAbsorb;
                    parserInput.autoCommentAbsorb = false;
                    var k = parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]+/);
                    parserInput.autoCommentAbsorb = autoCommentAbsorb;
                    if (!k) {
                        parserInput.forget();
                        return;
                    }
                    parserInput.restore();
                    var color = tree.Color.fromKeyword(k);
                    if (color) {
                        parserInput.$str(k);
                        return color;
                    }
                },

                //
                // A Dimension, that is, a number and a unit
                //
                //     0.5em 95%
                //
                dimension: function () {
                    if (parserInput.peekNotNumeric()) {
                        return;
                    }

                    var value = parserInput.$re(/^([+-]?\d*\.?\d+)(%|[a-z_]+)?/i);
                    if (value) {
                        return new(tree.Dimension)(value[1], value[2]);
                    }
                },

                //
                // A unicode descriptor, as is used in unicode-range
                //
                // U+0??  or U+00A1-00A9
                //
                unicodeDescriptor: function () {
                    var ud;

                    ud = parserInput.$re(/^U\+[0-9a-fA-F?]+(\-[0-9a-fA-F?]+)?/);
                    if (ud) {
                        return new(tree.UnicodeDescriptor)(ud[0]);
                    }
                },

                //
                // JavaScript code to be evaluated
                //
                //     `window.location.href`
                //
                javascript: function () {
                    var js, index = parserInput.i;

                    parserInput.save();

                    var escape = parserInput.$char("~");
                    var jsQuote = parserInput.$char("`");

                    if (!jsQuote) {
                        parserInput.restore();
                        return;
                    }

                    js = parserInput.$re(/^[^`]*`/);
                    if (js) {
                        parserInput.forget();
                        return new(tree.JavaScript)(js.substr(0, js.length - 1), Boolean(escape), index, fileInfo);
                    }
                    parserInput.restore("invalid javascript definition");
                }
            },

            //
            // The variable part of a variable definition. Used in the `rule` parser
            //
            //     @fink:
            //
            variable: function () {
                var name;

                if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\w-]+)\s*:/))) { return name[1]; }
            },

            //
            // The variable part of a variable definition. Used in the `rule` parser
            //
            //     @fink();
            //
            rulesetCall: function () {
                var name;

                if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\w-]+)\(\s*\)\s*;/))) {
                    return new tree.RulesetCall(name[1]);
                }
            },

            //
            // extend syntax - used to extend selectors
            //
            extend: function(isRule) {
                var elements, e, index = parserInput.i, option, extendList, extend;

                if (!parserInput.$str(isRule ? "&:extend(" : ":extend(")) {
                    return;
                }

                do {
                    option = null;
                    elements = null;
                    while (! (option = parserInput.$re(/^(all)(?=\s*(\)|,))/))) {
                        e = this.element();
                        if (!e) {
                            break;
                        }
                        if (elements) {
                            elements.push(e);
                        } else {
                            elements = [ e ];
                        }
                    }

                    option = option && option[1];
                    if (!elements) {
                        error("Missing target selector for :extend().");
                    }
                    extend = new(tree.Extend)(new(tree.Selector)(elements), option, index, fileInfo);
                    if (extendList) {
                        extendList.push(extend);
                    } else {
                        extendList = [ extend ];
                    }
                } while (parserInput.$char(","));

                expect(/^\)/);

                if (isRule) {
                    expect(/^;/);
                }

                return extendList;
            },

            //
            // extendRule - used in a rule to extend all the parent selectors
            //
            extendRule: function() {
                return this.extend(true);
            },

            //
            // Mixins
            //
            mixin: {
                //
                // A Mixin call, with an optional argument list
                //
                //     #mixins > .square(#fff);
                //     .rounded(4px, black);
                //     .button;
                //
                // The `while` loop is there because mixins can be
                // namespaced, but we only support the child and descendant
                // selector for now.
                //
                call: function () {
                    var s = parserInput.currentChar(), important = false, index = parserInput.i, elemIndex,
                        elements, elem, e, c, args;

                    if (s !== '.' && s !== '#') { return; }

                    parserInput.save(); // stop us absorbing part of an invalid selector

                    while (true) {
                        elemIndex = parserInput.i;
                        e = parserInput.$re(/^[#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/);
                        if (!e) {
                            break;
                        }
                        elem = new(tree.Element)(c, e, elemIndex, fileInfo);
                        if (elements) {
                            elements.push(elem);
                        } else {
                            elements = [ elem ];
                        }
                        c = parserInput.$char('>');
                    }

                    if (elements) {
                        if (parserInput.$char('(')) {
                            args = this.args(true).args;
                            expectChar(')');
                        }

                        if (parsers.important()) {
                            important = true;
                        }

                        if (parsers.end()) {
                            parserInput.forget();
                            return new(tree.mixin.Call)(elements, args, index, fileInfo, important);
                        }
                    }

                    parserInput.restore();
                },
                args: function (isCall) {
                    var entities = parsers.entities,
                        returner = { args:null, variadic: false },
                        expressions = [], argsSemiColon = [], argsComma = [],
                        isSemiColonSeparated, expressionContainsNamed, name, nameLoop,
                        value, arg, expand;

                    parserInput.save();

                    while (true) {
                        if (isCall) {
                            arg = parsers.detachedRuleset() || parsers.expression();
                        } else {
                            parserInput.commentStore.length = 0;
                            if (parserInput.$str("...")) {
                                returner.variadic = true;
                                if (parserInput.$char(";") && !isSemiColonSeparated) {
                                    isSemiColonSeparated = true;
                                }
                                (isSemiColonSeparated ? argsSemiColon : argsComma)
                                    .push({ variadic: true });
                                break;
                            }
                            arg = entities.variable() || entities.literal() || entities.keyword();
                        }

                        if (!arg) {
                            break;
                        }

                        nameLoop = null;
                        if (arg.throwAwayComments) {
                            arg.throwAwayComments();
                        }
                        value = arg;
                        var val = null;

                        if (isCall) {
                            // Variable
                            if (arg.value && arg.value.length == 1) {
                                val = arg.value[0];
                            }
                        } else {
                            val = arg;
                        }

                        if (val && val instanceof tree.Variable) {
                            if (parserInput.$char(':')) {
                                if (expressions.length > 0) {
                                    if (isSemiColonSeparated) {
                                        error("Cannot mix ; and , as delimiter types");
                                    }
                                    expressionContainsNamed = true;
                                }

                                value = parsers.detachedRuleset() || parsers.expression();

                                if (!value) {
                                    if (isCall) {
                                        error("could not understand value for named argument");
                                    } else {
                                        parserInput.restore();
                                        returner.args = [];
                                        return returner;
                                    }
                                }
                                nameLoop = (name = val.name);
                            } else if (parserInput.$str("...")) {
                                if (!isCall) {
                                    returner.variadic = true;
                                    if (parserInput.$char(";") && !isSemiColonSeparated) {
                                        isSemiColonSeparated = true;
                                    }
                                    (isSemiColonSeparated ? argsSemiColon : argsComma)
                                        .push({ name: arg.name, variadic: true });
                                    break;
                                } else {
                                    expand = true;
                                }
                            } else if (!isCall) {
                                name = nameLoop = val.name;
                                value = null;
                            }
                        }

                        if (value) {
                            expressions.push(value);
                        }

                        argsComma.push({ name:nameLoop, value:value, expand:expand });

                        if (parserInput.$char(',')) {
                            continue;
                        }

                        if (parserInput.$char(';') || isSemiColonSeparated) {

                            if (expressionContainsNamed) {
                                error("Cannot mix ; and , as delimiter types");
                            }

                            isSemiColonSeparated = true;

                            if (expressions.length > 1) {
                                value = new(tree.Value)(expressions);
                            }
                            argsSemiColon.push({ name:name, value:value, expand:expand });

                            name = null;
                            expressions = [];
                            expressionContainsNamed = false;
                        }
                    }

                    parserInput.forget();
                    returner.args = isSemiColonSeparated ? argsSemiColon : argsComma;
                    return returner;
                },
                //
                // A Mixin definition, with a list of parameters
                //
                //     .rounded (@radius: 2px, @color) {
                //        ...
                //     }
                //
                // Until we have a finer grained state-machine, we have to
                // do a look-ahead, to make sure we don't have a mixin call.
                // See the `rule` function for more information.
                //
                // We start by matching `.rounded (`, and then proceed on to
                // the argument list, which has optional default values.
                // We store the parameters in `params`, with a `value` key,
                // if there is a value, such as in the case of `@radius`.
                //
                // Once we've got our params list, and a closing `)`, we parse
                // the `{...}` block.
                //
                definition: function () {
                    var name, params = [], match, ruleset, cond, variadic = false;
                    if ((parserInput.currentChar() !== '.' && parserInput.currentChar() !== '#') ||
                        parserInput.peek(/^[^{]*\}/)) {
                        return;
                    }

                    parserInput.save();

                    match = parserInput.$re(/^([#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\s*\(/);
                    if (match) {
                        name = match[1];

                        var argInfo = this.args(false);
                        params = argInfo.args;
                        variadic = argInfo.variadic;

                        // .mixincall("@{a}");
                        // looks a bit like a mixin definition..
                        // also
                        // .mixincall(@a: {rule: set;});
                        // so we have to be nice and restore
                        if (!parserInput.$char(')')) {
                            parserInput.restore("Missing closing ')'");
                            return;
                        }

                        parserInput.commentStore.length = 0;

                        if (parserInput.$str("when")) { // Guard
                            cond = expect(parsers.conditions, 'expected condition');
                        }

                        ruleset = parsers.block();

                        if (ruleset) {
                            parserInput.forget();
                            return new(tree.mixin.Definition)(name, params, ruleset, cond, variadic);
                        } else {
                            parserInput.restore();
                        }
                    } else {
                        parserInput.forget();
                    }
                }
            },

            //
            // Entities are the smallest recognized token,
            // and can be found inside a rule's value.
            //
            entity: function () {
                var entities = this.entities;

                return this.comment() || entities.literal() || entities.variable() || entities.url() ||
                       entities.call()    || entities.keyword()  || entities.javascript();
            },

            //
            // A Rule terminator. Note that we use `peek()` to check for '}',
            // because the `block` rule will be expecting it, but we still need to make sure
            // it's there, if ';' was omitted.
            //
            end: function () {
                return parserInput.$char(';') || parserInput.peek('}');
            },

            //
            // IE's alpha function
            //
            //     alpha(opacity=88)
            //
            alpha: function () {
                var value;

                // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18
                if (! parserInput.$re(/^opacity=/i)) { return; }
                value = parserInput.$re(/^\d+/);
                if (!value) {
                    value = expect(this.entities.variable, "Could not parse alpha");
                }
                expectChar(')');
                return new(tree.Alpha)(value);
            },

            //
            // A Selector Element
            //
            //     div
            //     + h1
            //     #socks
            //     input[type="text"]
            //
            // Elements are the building blocks for Selectors,
            // they are made out of a `Combinator` (see combinator rule),
            // and an element name, such as a tag a class, or `*`.
            //
            element: function () {
                var e, c, v, index = parserInput.i;

                c = this.combinator();

                e = parserInput.$re(/^(?:\d+\.\d+|\d+)%/) ||
                    parserInput.$re(/^(?:[.#]?|:*)(?:[\w-]|[^\x00-\x9f]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/) ||
                    parserInput.$char('*') || parserInput.$char('&') || this.attribute() ||
                    parserInput.$re(/^\([^&()@]+\)/) ||  parserInput.$re(/^[\.#:](?=@)/) ||
                    this.entities.variableCurly();

                if (! e) {
                    parserInput.save();
                    if (parserInput.$char('(')) {
                        if ((v = this.selector()) && parserInput.$char(')')) {
                            e = new(tree.Paren)(v);
                            parserInput.forget();
                        } else {
                            parserInput.restore("Missing closing ')'");
                        }
                    } else {
                        parserInput.forget();
                    }
                }

                if (e) { return new(tree.Element)(c, e, index, fileInfo); }
            },

            //
            // Combinators combine elements together, in a Selector.
            //
            // Because our parser isn't white-space sensitive, special care
            // has to be taken, when parsing the descendant combinator, ` `,
            // as it's an empty space. We have to check the previous character
            // in the input, to see if it's a ` ` character. More info on how
            // we deal with this in *combinator.js*.
            //
            combinator: function () {
                var c = parserInput.currentChar();

                if (c === '/') {
                    parserInput.save();
                    var slashedCombinator = parserInput.$re(/^\/[a-z]+\//i);
                    if (slashedCombinator) {
                        parserInput.forget();
                        return new(tree.Combinator)(slashedCombinator);
                    }
                    parserInput.restore();
                }

                if (c === '>' || c === '+' || c === '~' || c === '|' || c === '^') {
                    parserInput.i++;
                    if (c === '^' && parserInput.currentChar() === '^') {
                        c = '^^';
                        parserInput.i++;
                    }
                    while (parserInput.isWhitespace()) { parserInput.i++; }
                    return new(tree.Combinator)(c);
                } else if (parserInput.isWhitespace(-1)) {
                    return new(tree.Combinator)(" ");
                } else {
                    return new(tree.Combinator)(null);
                }
            },
            //
            // A CSS selector (see selector below)
            // with less extensions e.g. the ability to extend and guard
            //
            lessSelector: function () {
                return this.selector(true);
            },
            //
            // A CSS Selector
            //
            //     .class > div + h1
            //     li a:hover
            //
            // Selectors are made out of one or more Elements, see above.
            //
            selector: function (isLess) {
                var index = parserInput.i, elements, extendList, c, e, allExtends, when, condition;

                while ((isLess && (extendList = this.extend())) || (isLess && (when = parserInput.$str("when"))) || (e = this.element())) {
                    if (when) {
                        condition = expect(this.conditions, 'expected condition');
                    } else if (condition) {
                        error("CSS guard can only be used at the end of selector");
                    } else if (extendList) {
                        if (allExtends) {
                            allExtends = allExtends.concat(extendList);
                        } else {
                            allExtends = extendList;
                        }
                    } else {
                        if (allExtends) { error("Extend can only be used at the end of selector"); }
                        c = parserInput.currentChar();
                        if (elements) {
                            elements.push(e);
                        } else {
                            elements = [ e ];
                        }
                        e = null;
                    }
                    if (c === '{' || c === '}' || c === ';' || c === ',' || c === ')') {
                        break;
                    }
                }

                if (elements) { return new(tree.Selector)(elements, allExtends, condition, index, fileInfo); }
                if (allExtends) { error("Extend must be used to extend a selector, it cannot be used on its own"); }
            },
            attribute: function () {
                if (! parserInput.$char('[')) { return; }

                var entities = this.entities,
                    key, val, op;

                if (!(key = entities.variableCurly())) {
                    key = expect(/^(?:[_A-Za-z0-9-\*]*\|)?(?:[_A-Za-z0-9-]|\\.)+/);
                }

                op = parserInput.$re(/^[|~*$^]?=/);
                if (op) {
                    val = entities.quoted() || parserInput.$re(/^[0-9]+%/) || parserInput.$re(/^[\w-]+/) || entities.variableCurly();
                }

                expectChar(']');

                return new(tree.Attribute)(key, op, val);
            },

            //
            // The `block` rule is used by `ruleset` and `mixin.definition`.
            // It's a wrapper around the `primary` rule, with added `{}`.
            //
            block: function () {
                var content;
                if (parserInput.$char('{') && (content = this.primary()) && parserInput.$char('}')) {
                    return content;
                }
            },

            blockRuleset: function() {
                var block = this.block();

                if (block) {
                    block = new tree.Ruleset(null, block);
                }
                return block;
            },

            detachedRuleset: function() {
                var blockRuleset = this.blockRuleset();
                if (blockRuleset) {
                    return new tree.DetachedRuleset(blockRuleset);
                }
            },

            //
            // div, .class, body > p {...}
            //
            ruleset: function () {
                var selectors, s, rules, debugInfo;

                parserInput.save();

                if (context.dumpLineNumbers) {
                    debugInfo = getDebugInfo(parserInput.i);
                }

                while (true) {
                    s = this.lessSelector();
                    if (!s) {
                        break;
                    }
                    if (selectors) {
                        selectors.push(s);
                    } else {
                        selectors = [ s ];
                    }
                    parserInput.commentStore.length = 0;
                    if (s.condition && selectors.length > 1) {
                        error("Guards are only currently allowed on a single selector.");
                    }
                    if (! parserInput.$char(',')) { break; }
                    if (s.condition) {
                        error("Guards are only currently allowed on a single selector.");
                    }
                    parserInput.commentStore.length = 0;
                }

                if (selectors && (rules = this.block())) {
                    parserInput.forget();
                    var ruleset = new(tree.Ruleset)(selectors, rules, context.strictImports);
                    if (context.dumpLineNumbers) {
                        ruleset.debugInfo = debugInfo;
                    }
                    return ruleset;
                } else {
                    parserInput.restore();
                }
            },
            rule: function (tryAnonymous) {
                var name, value, startOfRule = parserInput.i, c = parserInput.currentChar(), important, merge, isVariable;

                if (c === '.' || c === '#' || c === '&' || c === ':') { return; }

                parserInput.save();

                name = this.variable() || this.ruleProperty();
                if (name) {
                    isVariable = typeof name === "string";

                    if (isVariable) {
                        value = this.detachedRuleset();
                    }

                    parserInput.commentStore.length = 0;
                    if (!value) {
                        // a name returned by this.ruleProperty() is always an array of the form:
                        // [string-1, ..., string-n, ""] or [string-1, ..., string-n, "+"]
                        // where each item is a tree.Keyword or tree.Variable
                        merge = !isVariable && name.length > 1 && name.pop().value;

                        // prefer to try to parse first if its a variable or we are compressing
                        // but always fallback on the other one
                        var tryValueFirst = !tryAnonymous && (context.compress || isVariable);

                        if (tryValueFirst) {
                            value = this.value();
                        }
                        if (!value) {
                            value = this.anonymousValue();
                            if (value) {
                                parserInput.forget();
                                // anonymous values absorb the end ';' which is required for them to work
                                return new (tree.Rule)(name, value, false, merge, startOfRule, fileInfo);
                            }
                        }
                        if (!tryValueFirst && !value) {
                            value = this.value();
                        }

                        important = this.important();
                    }

                    if (value && this.end()) {
                        parserInput.forget();
                        return new (tree.Rule)(name, value, important, merge, startOfRule, fileInfo);
                    } else {
                        parserInput.restore();
                        if (value && !tryAnonymous) {
                            return this.rule(true);
                        }
                    }
                } else {
                    parserInput.forget();
                }
            },
            anonymousValue: function () {
                var match = parserInput.$re(/^([^@+\/'"*`(;{}-]*);/);
                if (match) {
                    return new(tree.Anonymous)(match[1]);
                }
            },

            //
            // An @import directive
            //
            //     @import "lib";
            //
            // Depending on our environment, importing is done differently:
            // In the browser, it's an XHR request, in Node, it would be a
            // file-system operation. The function used for importing is
            // stored in `import`, which we pass to the Import constructor.
            //
            "import": function () {
                var path, features, index = parserInput.i;

                var dir = parserInput.$re(/^@import?\s+/);

                if (dir) {
                    var options = (dir ? this.importOptions() : null) || {};

                    if ((path = this.entities.quoted() || this.entities.url())) {
                        features = this.mediaFeatures();

                        if (!parserInput.$char(';')) {
                            parserInput.i = index;
                            error("missing semi-colon or unrecognised media features on import");
                        }
                        features = features && new(tree.Value)(features);
                        return new(tree.Import)(path, features, options, index, fileInfo);
                    }
                    else {
                        parserInput.i = index;
                        error("malformed import statement");
                    }
                }
            },

            importOptions: function() {
                var o, options = {}, optionName, value;

                // list of options, surrounded by parens
                if (! parserInput.$char('(')) { return null; }
                do {
                    o = this.importOption();
                    if (o) {
                        optionName = o;
                        value = true;
                        switch(optionName) {
                            case "css":
                                optionName = "less";
                                value = false;
                                break;
                            case "once":
                                optionName = "multiple";
                                value = false;
                                break;
                        }
                        options[optionName] = value;
                        if (! parserInput.$char(',')) { break; }
                    }
                } while (o);
                expectChar(')');
                return options;
            },

            importOption: function() {
                var opt = parserInput.$re(/^(less|css|multiple|once|inline|reference|optional)/);
                if (opt) {
                    return opt[1];
                }
            },

            mediaFeature: function () {
                var entities = this.entities, nodes = [], e, p;
                parserInput.save();
                do {
                    e = entities.keyword() || entities.variable();
                    if (e) {
                        nodes.push(e);
                    } else if (parserInput.$char('(')) {
                        p = this.property();
                        e = this.value();
                        if (parserInput.$char(')')) {
                            if (p && e) {
                                nodes.push(new(tree.Paren)(new(tree.Rule)(p, e, null, null, parserInput.i, fileInfo, true)));
                            } else if (e) {
                                nodes.push(new(tree.Paren)(e));
                            } else {
                                error("badly formed media feature definition");
                            }
                        } else {
                            error("Missing closing ')'", "Parse");
                        }
                    }
                } while (e);

                parserInput.forget();
                if (nodes.length > 0) {
                    return new(tree.Expression)(nodes);
                }
            },

            mediaFeatures: function () {
                var entities = this.entities, features = [], e;
                do {
                    e = this.mediaFeature();
                    if (e) {
                        features.push(e);
                        if (! parserInput.$char(',')) { break; }
                    } else {
                        e = entities.variable();
                        if (e) {
                            features.push(e);
                            if (! parserInput.$char(',')) { break; }
                        }
                    }
                } while (e);

                return features.length > 0 ? features : null;
            },

            media: function () {
                var features, rules, media, debugInfo, index = parserInput.i;

                if (context.dumpLineNumbers) {
                    debugInfo = getDebugInfo(index);
                }

                parserInput.save();

                if (parserInput.$str("@media")) {
                    features = this.mediaFeatures();

                    rules = this.block();

                    if (!rules) {
                        error("media definitions require block statements after any features");
                    }

                    parserInput.forget();

                    media = new(tree.Media)(rules, features, index, fileInfo);
                    if (context.dumpLineNumbers) {
                        media.debugInfo = debugInfo;
                    }

                    return media;
                }

                parserInput.restore();
            },

            //
            // A @plugin directive, used to import compiler extensions dynamically.
            //
            //     @plugin "lib";
            //
            // Depending on our environment, importing is done differently:
            // In the browser, it's an XHR request, in Node, it would be a
            // file-system operation. The function used for importing is
            // stored in `import`, which we pass to the Import constructor.
            //
            plugin: function () {
                var path,
                    index = parserInput.i,
                    dir   = parserInput.$re(/^@plugin?\s+/);

                if (dir) {
                    var options = { plugin : true };

                    if ((path = this.entities.quoted() || this.entities.url())) {

                        if (!parserInput.$char(';')) {
                            parserInput.i = index;
                            error("missing semi-colon on plugin");
                        }

                        return new(tree.Import)(path, null, options, index, fileInfo);
                    }
                    else {
                        parserInput.i = index;
                        error("malformed plugin statement");
                    }
                }
            },

            //
            // A CSS Directive
            //
            //     @charset "utf-8";
            //
            directive: function () {
                var index = parserInput.i, name, value, rules, nonVendorSpecificName,
                    hasIdentifier, hasExpression, hasUnknown, hasBlock = true, isRooted = true;

                if (parserInput.currentChar() !== '@') { return; }

                value = this['import']() || this.plugin() || this.media();
                if (value) {
                    return value;
                }

                parserInput.save();

                name = parserInput.$re(/^@[a-z-]+/);

                if (!name) { return; }

                nonVendorSpecificName = name;
                if (name.charAt(1) == '-' && name.indexOf('-', 2) > 0) {
                    nonVendorSpecificName = "@" + name.slice(name.indexOf('-', 2) + 1);
                }

                switch(nonVendorSpecificName) {
                    case "@charset":
                        hasIdentifier = true;
                        hasBlock = false;
                        break;
                    case "@namespace":
                        hasExpression = true;
                        hasBlock = false;
                        break;
                    case "@keyframes":
                    case "@counter-style":
                        hasIdentifier = true;
                        break;
                    case "@document":
                    case "@supports":
                        hasUnknown = true;
                        isRooted = false;
                        break;
                    default:
                        hasUnknown = true;
                        break;
                }

                parserInput.commentStore.length = 0;

                if (hasIdentifier) {
                    value = this.entity();
                    if (!value) {
                        error("expected " + name + " identifier");
                    }
                } else if (hasExpression) {
                    value = this.expression();
                    if (!value) {
                        error("expected " + name + " expression");
                    }
                } else if (hasUnknown) {
                    value = (parserInput.$re(/^[^{;]+/) || '').trim();
                    hasBlock = (parserInput.currentChar() == '{');
                    if (value) {
                        value = new(tree.Anonymous)(value);
                    }
                }

                if (hasBlock) {
                    rules = this.blockRuleset();
                }

                if (rules || (!hasBlock && value && parserInput.$char(';'))) {
                    parserInput.forget();
                    return new (tree.Directive)(name, value, rules, index, fileInfo,
                        context.dumpLineNumbers ? getDebugInfo(index) : null,
                        isRooted
                    );
                }

                parserInput.restore("directive options not recognised");
            },

            //
            // A Value is a comma-delimited list of Expressions
            //
            //     font-family: Baskerville, Georgia, serif;
            //
            // In a Rule, a Value represents everything after the `:`,
            // and before the `;`.
            //
            value: function () {
                var e, expressions = [];

                do {
                    e = this.expression();
                    if (e) {
                        expressions.push(e);
                        if (! parserInput.$char(',')) { break; }
                    }
                } while (e);

                if (expressions.length > 0) {
                    return new(tree.Value)(expressions);
                }
            },
            important: function () {
                if (parserInput.currentChar() === '!') {
                    return parserInput.$re(/^! *important/);
                }
            },
            sub: function () {
                var a, e;

                parserInput.save();
                if (parserInput.$char('(')) {
                    a = this.addition();
                    if (a && parserInput.$char(')')) {
                        parserInput.forget();
                        e = new(tree.Expression)([a]);
                        e.parens = true;
                        return e;
                    }
                    parserInput.restore("Expected ')'");
                    return;
                }
                parserInput.restore();
            },
            multiplication: function () {
                var m, a, op, operation, isSpaced;
                m = this.operand();
                if (m) {
                    isSpaced = parserInput.isWhitespace(-1);
                    while (true) {
                        if (parserInput.peek(/^\/[*\/]/)) {
                            break;
                        }

                        parserInput.save();

                        op = parserInput.$char('/') || parserInput.$char('*');

                        if (!op) { parserInput.forget(); break; }

                        a = this.operand();

                        if (!a) { parserInput.restore(); break; }
                        parserInput.forget();

                        m.parensInOp = true;
                        a.parensInOp = true;
                        operation = new(tree.Operation)(op, [operation || m, a], isSpaced);
                        isSpaced = parserInput.isWhitespace(-1);
                    }
                    return operation || m;
                }
            },
            addition: function () {
                var m, a, op, operation, isSpaced;
                m = this.multiplication();
                if (m) {
                    isSpaced = parserInput.isWhitespace(-1);
                    while (true) {
                        op = parserInput.$re(/^[-+]\s+/) || (!isSpaced && (parserInput.$char('+') || parserInput.$char('-')));
                        if (!op) {
                            break;
                        }
                        a = this.multiplication();
                        if (!a) {
                            break;
                        }

                        m.parensInOp = true;
                        a.parensInOp = true;
                        operation = new(tree.Operation)(op, [operation || m, a], isSpaced);
                        isSpaced = parserInput.isWhitespace(-1);
                    }
                    return operation || m;
                }
            },
            conditions: function () {
                var a, b, index = parserInput.i, condition;

                a = this.condition();
                if (a) {
                    while (true) {
                        if (!parserInput.peek(/^,\s*(not\s*)?\(/) || !parserInput.$char(',')) {
                            break;
                        }
                        b = this.condition();
                        if (!b) {
                            break;
                        }
                        condition = new(tree.Condition)('or', condition || a, b, index);
                    }
                    return condition || a;
                }
            },
            condition: function () {
                var result, logical, next;
                function or() {
                    return parserInput.$str("or");
                }

                result = this.conditionAnd(this);
                if (!result) {
                    return ;
                }
                logical = or();
                if (logical) {
                    next = this.condition();
                    if (next) {
                        result = new(tree.Condition)(logical, result, next);
                    } else {
                        return ;
                    }
                }
                return result;
            },
            conditionAnd: function () {
                var result, logical, next;
                function insideCondition(me) {
                    return me.negatedCondition() || me.parenthesisCondition();
                }
                function and() {
                    return parserInput.$str("and");
                }

                result = insideCondition(this);
                if (!result) {
                    return ;
                }
                logical = and();
                if (logical) {
                    next = this.conditionAnd();
                    if (next) {
                        result = new(tree.Condition)(logical, result, next);
                    } else {
                        return ;
                    }
                }
                return result;
            },
            negatedCondition: function () {
                if (parserInput.$str("not")) {
                    var result = this.parenthesisCondition();
                    if (result) {
                        result.negate = !result.negate;
                    }
                    return result;
                }
            },
            parenthesisCondition: function () {
                function tryConditionFollowedByParenthesis(me) {
                    var body;
                    parserInput.save();
                    body = me.condition();
                    if (!body) {
                        parserInput.restore();
                        return ;
                    }
                    if (!parserInput.$char(')')) {
                        parserInput.restore();
                        return ;
                    }
                    parserInput.forget();
                    return body;
                }

                var body;
                parserInput.save();
                if (!parserInput.$str("(")) {
                    parserInput.restore();
                    return ;
                }
                body = tryConditionFollowedByParenthesis(this);
                if (body) {
                    parserInput.forget();
                    return body;
                }

                body = this.atomicCondition();
                if (!body) {
                    parserInput.restore();
                    return ;
                }
                if (!parserInput.$char(')')) {
                    parserInput.restore("expected ')' got '" + parserInput.currentChar() + "'");
                    return ;
                }
                parserInput.forget();
                return body;
            },
            atomicCondition: function () {
                var entities = this.entities, index = parserInput.i, a, b, c, op;

                a = this.addition() || entities.keyword() || entities.quoted();
                if (a) {
                    if (parserInput.$char('>')) {
                        if (parserInput.$char('=')) {
                            op = ">=";
                        } else {
                            op = '>';
                        }
                    } else
                    if (parserInput.$char('<')) {
                        if (parserInput.$char('=')) {
                            op = "<=";
                        } else {
                            op = '<';
                        }
                    } else
                    if (parserInput.$char('=')) {
                        if (parserInput.$char('>')) {
                            op = "=>";
                        } else if (parserInput.$char('<')) {
                            op = '=<';
                        } else {
                            op = '=';
                        }
                    }
                    if (op) {
                        b = this.addition() || entities.keyword() || entities.quoted();
                        if (b) {
                            c = new(tree.Condition)(op, a, b, index, false);
                        } else {
                            error('expected expression');
                        }
                    } else {
                        c = new(tree.Condition)('=', a, new(tree.Keyword)('true'), index, false);
                    }
                    return c;
                }
            },

            //
            // An operand is anything that can be part of an operation,
            // such as a Color, or a Variable
            //
            operand: function () {
                var entities = this.entities, negate;

                if (parserInput.peek(/^-[@\(]/)) {
                    negate = parserInput.$char('-');
                }

                var o = this.sub() || entities.dimension() ||
                        entities.color() || entities.variable() ||
                        entities.call() || entities.colorKeyword();

                if (negate) {
                    o.parensInOp = true;
                    o = new(tree.Negative)(o);
                }

                return o;
            },

            //
            // Expressions either represent mathematical operations,
            // or white-space delimited Entities.
            //
            //     1px solid black
            //     @var * 2
            //
            expression: function () {
                var entities = [], e, delim;

                do {
                    e = this.comment();
                    if (e) {
                        entities.push(e);
                        continue;
                    }
                    e = this.addition() || this.entity();
                    if (e) {
                        entities.push(e);
                        // operations do not allow keyword "/" dimension (e.g. small/20px) so we support that here
                        if (!parserInput.peek(/^\/[\/*]/)) {
                            delim = parserInput.$char('/');
                            if (delim) {
                                entities.push(new(tree.Anonymous)(delim));
                            }
                        }
                    }
                } while (e);
                if (entities.length > 0) {
                    return new(tree.Expression)(entities);
                }
            },
            property: function () {
                var name = parserInput.$re(/^(\*?-?[_a-zA-Z0-9-]+)\s*:/);
                if (name) {
                    return name[1];
                }
            },
            ruleProperty: function () {
                var name = [], index = [], s, k;

                parserInput.save();

                var simpleProperty = parserInput.$re(/^([_a-zA-Z0-9-]+)\s*:/);
                if (simpleProperty) {
                    name = [new(tree.Keyword)(simpleProperty[1])];
                    parserInput.forget();
                    return name;
                }

                function match(re) {
                    var i = parserInput.i,
                        chunk = parserInput.$re(re);
                    if (chunk) {
                        index.push(i);
                        return name.push(chunk[1]);
                    }
                }

                match(/^(\*?)/);
                while (true) {
                    if (!match(/^((?:[\w-]+)|(?:@\{[\w-]+\}))/)) {
                        break;
                    }
                }

                if ((name.length > 1) && match(/^((?:\+_|\+)?)\s*:/)) {
                    parserInput.forget();

                    // at last, we have the complete match now. move forward,
                    // convert name particles to tree objects and return:
                    if (name[0] === '') {
                        name.shift();
                        index.shift();
                    }
                    for (k = 0; k < name.length; k++) {
                        s = name[k];
                        name[k] = (s.charAt(0) !== '@') ?
                            new(tree.Keyword)(s) :
                            new(tree.Variable)('@' + s.slice(2, -1),
                                index[k], fileInfo);
                    }
                    return name;
                }
                parserInput.restore();
            }
        }
    };
};
Parser.serializeVars = function(vars) {
    var s = '';

    for (var name in vars) {
        if (Object.hasOwnProperty.call(vars, name)) {
            var value = vars[name];
            s += ((name[0] === '@') ? '' : '@') + name + ': ' + value +
                ((String(value).slice(-1) === ';') ? '' : ';');
        }
    }

    return s;
};

module.exports = Parser;

},{"../less-error":32,"../tree":62,"../utils":83,"../visitors":87,"./parser-input":37}],39:[function(require,module,exports){
/**
 * Plugin Manager
 */
var PluginManager = function(less) {
    this.less = less;
    this.visitors = [];
    this.preProcessors = [];
    this.postProcessors = [];
    this.installedPlugins = [];
    this.fileManagers = [];
};
/**
 * Adds all the plugins in the array
 * @param {Array} plugins
 */
PluginManager.prototype.addPlugins = function(plugins) {
    if (plugins) {
        for (var i = 0; i < plugins.length; i++) {
            this.addPlugin(plugins[i]);
        }
    }
};
/**
 *
 * @param plugin
 */
PluginManager.prototype.addPlugin = function(plugin) {
    this.installedPlugins.push(plugin);
    plugin.install(this.less, this);
};
/**
 * Adds a visitor. The visitor object has options on itself to determine
 * when it should run.
 * @param visitor
 */
PluginManager.prototype.addVisitor = function(visitor) {
    this.visitors.push(visitor);
};
/**
 * Adds a pre processor object
 * @param {object} preProcessor
 * @param {number} priority - guidelines 1 = before import, 1000 = import, 2000 = after import
 */
PluginManager.prototype.addPreProcessor = function(preProcessor, priority) {
    var indexToInsertAt;
    for (indexToInsertAt = 0; indexToInsertAt < this.preProcessors.length; indexToInsertAt++) {
        if (this.preProcessors[indexToInsertAt].priority >= priority) {
            break;
        }
    }
    this.preProcessors.splice(indexToInsertAt, 0, {preProcessor: preProcessor, priority: priority});
};
/**
 * Adds a post processor object
 * @param {object} postProcessor
 * @param {number} priority - guidelines 1 = before compression, 1000 = compression, 2000 = after compression
 */
PluginManager.prototype.addPostProcessor = function(postProcessor, priority) {
    var indexToInsertAt;
    for (indexToInsertAt = 0; indexToInsertAt < this.postProcessors.length; indexToInsertAt++) {
        if (this.postProcessors[indexToInsertAt].priority >= priority) {
            break;
        }
    }
    this.postProcessors.splice(indexToInsertAt, 0, {postProcessor: postProcessor, priority: priority});
};
/**
 *
 * @param manager
 */
PluginManager.prototype.addFileManager = function(manager) {
    this.fileManagers.push(manager);
};
/**
 *
 * @returns {Array}
 * @private
 */
PluginManager.prototype.getPreProcessors = function() {
    var preProcessors = [];
    for (var i = 0; i < this.preProcessors.length; i++) {
        preProcessors.push(this.preProcessors[i].preProcessor);
    }
    return preProcessors;
};
/**
 *
 * @returns {Array}
 * @private
 */
PluginManager.prototype.getPostProcessors = function() {
    var postProcessors = [];
    for (var i = 0; i < this.postProcessors.length; i++) {
        postProcessors.push(this.postProcessors[i].postProcessor);
    }
    return postProcessors;
};
/**
 *
 * @returns {Array}
 * @private
 */
PluginManager.prototype.getVisitors = function() {
    return this.visitors;
};
/**
 *
 * @returns {Array}
 * @private
 */
PluginManager.prototype.getFileManagers = function() {
    return this.fileManagers;
};
module.exports = PluginManager;

},{}],40:[function(require,module,exports){
var LessError = require('../less-error'),
    tree = require("../tree");

var FunctionImporter = module.exports = function FunctionImporter(context, fileInfo) {
    this.fileInfo = fileInfo;
};

FunctionImporter.prototype.eval = function(contents, callback) {
    var loaded = {},
        loader,
        registry;

    registry = {
        add: function(name, func) {
            loaded[name] = func;
        },
        addMultiple: function(functions) {
            Object.keys(functions).forEach(function(name) {
                loaded[name] = functions[name];
            });
        }
    };

    try {
        loader = new Function("functions", "tree", "fileInfo", contents);
        loader(registry, tree, this.fileInfo);
    } catch(e) {
        callback(new LessError({
            message: "Plugin evaluation error: '" + e.name + ': ' + e.message.replace(/["]/g, "'") + "'" ,
            filename: this.fileInfo.filename
        }), null );
    }

    callback(null, { functions: loaded });
};

},{"../less-error":32,"../tree":62}],41:[function(require,module,exports){
var PromiseConstructor;

module.exports = function(environment, ParseTree, ImportManager) {
    var render = function (input, options, callback) {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }

        if (!callback) {
            if (!PromiseConstructor) {
                PromiseConstructor = typeof Promise === 'undefined' ? require('promise') : Promise;
            }
            var self = this;
            return new PromiseConstructor(function (resolve, reject) {
                render.call(self, input, options, function(err, output) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(output);
                    }
                });
            });
        } else {
            this.parse(input, options, function(err, root, imports, options) {
                if (err) { return callback(err); }

                var result;
                try {
                    var parseTree = new ParseTree(root, imports);
                    result = parseTree.toCSS(options);
                }
                catch (err) { return callback(err); }

                callback(null, result);
            });
        }
    };

    return render;
};

},{"promise":undefined}],42:[function(require,module,exports){
module.exports = function (SourceMapOutput, environment) {

    var SourceMapBuilder = function (options) {
        this.options = options;
    };

    SourceMapBuilder.prototype.toCSS = function(rootNode, options, imports) {
        var sourceMapOutput = new SourceMapOutput(
            {
                contentsIgnoredCharsMap: imports.contentsIgnoredChars,
                rootNode: rootNode,
                contentsMap: imports.contents,
                sourceMapFilename: this.options.sourceMapFilename,
                sourceMapURL: this.options.sourceMapURL,
                outputFilename: this.options.sourceMapOutputFilename,
                sourceMapBasepath: this.options.sourceMapBasepath,
                sourceMapRootpath: this.options.sourceMapRootpath,
                outputSourceFiles: this.options.outputSourceFiles,
                sourceMapGenerator: this.options.sourceMapGenerator,
                sourceMapFileInline: this.options.sourceMapFileInline
            });

        var css = sourceMapOutput.toCSS(options);
        this.sourceMap = sourceMapOutput.sourceMap;
        this.sourceMapURL = sourceMapOutput.sourceMapURL;
        if (this.options.sourceMapInputFilename) {
            this.sourceMapInputFilename = sourceMapOutput.normalizeFilename(this.options.sourceMapInputFilename);
        }
        return css + this.getCSSAppendage();
    };

    SourceMapBuilder.prototype.getCSSAppendage = function() {

        var sourceMapURL = this.sourceMapURL;
        if (this.options.sourceMapFileInline) {
            if (this.sourceMap === undefined) {
                return "";
            }
            sourceMapURL = "data:application/json;base64," + environment.encodeBase64(this.sourceMap);
        }

        if (sourceMapURL) {
            return "/*# sourceMappingURL=" + sourceMapURL + " */";
        }
        return "";
    };

    SourceMapBuilder.prototype.getExternalSourceMap = function() {
        return this.sourceMap;
    };
    SourceMapBuilder.prototype.setExternalSourceMap = function(sourceMap) {
        this.sourceMap = sourceMap;
    };

    SourceMapBuilder.prototype.isInline = function() {
        return this.options.sourceMapFileInline;
    };
    SourceMapBuilder.prototype.getSourceMapURL = function() {
        return this.sourceMapURL;
    };
    SourceMapBuilder.prototype.getOutputFilename = function() {
        return this.options.sourceMapOutputFilename;
    };
    SourceMapBuilder.prototype.getInputFilename = function() {
        return this.sourceMapInputFilename;
    };

    return SourceMapBuilder;
};

},{}],43:[function(require,module,exports){
module.exports = function (environment) {

    var SourceMapOutput = function (options) {
        this._css = [];
        this._rootNode = options.rootNode;
        this._contentsMap = options.contentsMap;
        this._contentsIgnoredCharsMap = options.contentsIgnoredCharsMap;
        if (options.sourceMapFilename) {
            this._sourceMapFilename = options.sourceMapFilename.replace(/\\/g, '/');
        }
        this._outputFilename = options.outputFilename;
        this.sourceMapURL = options.sourceMapURL;
        if (options.sourceMapBasepath) {
            this._sourceMapBasepath = options.sourceMapBasepath.replace(/\\/g, '/');
        }
        if (options.sourceMapRootpath) {
            this._sourceMapRootpath = options.sourceMapRootpath.replace(/\\/g, '/');
            if (this._sourceMapRootpath.charAt(this._sourceMapRootpath.length - 1) !== '/') {
                this._sourceMapRootpath += '/';
            }
        } else {
            this._sourceMapRootpath = "";
        }
        this._outputSourceFiles = options.outputSourceFiles;
        this._sourceMapGeneratorConstructor = environment.getSourceMapGenerator();

        this._lineNumber = 0;
        this._column = 0;
    };

    SourceMapOutput.prototype.normalizeFilename = function(filename) {
        filename = filename.replace(/\\/g, '/');

        if (this._sourceMapBasepath && filename.indexOf(this._sourceMapBasepath) === 0) {
            filename = filename.substring(this._sourceMapBasepath.length);
            if (filename.charAt(0) === '\\' || filename.charAt(0) === '/') {
                filename = filename.substring(1);
            }
        }
        return (this._sourceMapRootpath || "") + filename;
    };

    SourceMapOutput.prototype.add = function(chunk, fileInfo, index, mapLines) {

        //ignore adding empty strings
        if (!chunk) {
            return;
        }

        var lines,
            sourceLines,
            columns,
            sourceColumns,
            i;

        if (fileInfo) {
            var inputSource = this._contentsMap[fileInfo.filename];

            // remove vars/banner added to the top of the file
            if (this._contentsIgnoredCharsMap[fileInfo.filename]) {
                // adjust the index
                index -= this._contentsIgnoredCharsMap[fileInfo.filename];
                if (index < 0) { index = 0; }
                // adjust the source
                inputSource = inputSource.slice(this._contentsIgnoredCharsMap[fileInfo.filename]);
            }
            inputSource = inputSource.substring(0, index);
            sourceLines = inputSource.split("\n");
            sourceColumns = sourceLines[sourceLines.length - 1];
        }

        lines = chunk.split("\n");
        columns = lines[lines.length - 1];

        if (fileInfo) {
            if (!mapLines) {
                this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + 1, column: this._column},
                    original: { line: sourceLines.length, column: sourceColumns.length},
                    source: this.normalizeFilename(fileInfo.filename)});
            } else {
                for (i = 0; i < lines.length; i++) {
                    this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + i + 1, column: i === 0 ? this._column : 0},
                        original: { line: sourceLines.length + i, column: i === 0 ? sourceColumns.length : 0},
                        source: this.normalizeFilename(fileInfo.filename)});
                }
            }
        }

        if (lines.length === 1) {
            this._column += columns.length;
        } else {
            this._lineNumber += lines.length - 1;
            this._column = columns.length;
        }

        this._css.push(chunk);
    };

    SourceMapOutput.prototype.isEmpty = function() {
        return this._css.length === 0;
    };

    SourceMapOutput.prototype.toCSS = function(context) {
        this._sourceMapGenerator = new this._sourceMapGeneratorConstructor({ file: this._outputFilename, sourceRoot: null });

        if (this._outputSourceFiles) {
            for (var filename in this._contentsMap) {
                if (this._contentsMap.hasOwnProperty(filename)) {
                    var source = this._contentsMap[filename];
                    if (this._contentsIgnoredCharsMap[filename]) {
                        source = source.slice(this._contentsIgnoredCharsMap[filename]);
                    }
                    this._sourceMapGenerator.setSourceContent(this.normalizeFilename(filename), source);
                }
            }
        }

        this._rootNode.genCSS(context, this);

        if (this._css.length > 0) {
            var sourceMapURL,
                sourceMapContent = JSON.stringify(this._sourceMapGenerator.toJSON());

            if (this.sourceMapURL) {
                sourceMapURL = this.sourceMapURL;
            } else if (this._sourceMapFilename) {
                sourceMapURL = this._sourceMapFilename;
            }
            this.sourceMapURL = sourceMapURL;

            this.sourceMap = sourceMapContent;
        }

        return this._css.join('');
    };

    return SourceMapOutput;
};

},{}],44:[function(require,module,exports){
var contexts = require("./contexts"),
    visitor = require("./visitors"),
    tree = require("./tree");

module.exports = function(root, options) {
    options = options || {};
    var evaldRoot,
        variables = options.variables,
        evalEnv = new contexts.Eval(options);

    //
    // Allows setting variables with a hash, so:
    //
    //   `{ color: new tree.Color('#f01') }` will become:
    //
    //   new tree.Rule('@color',
    //     new tree.Value([
    //       new tree.Expression([
    //         new tree.Color('#f01')
    //       ])
    //     ])
    //   )
    //
    if (typeof variables === 'object' && !Array.isArray(variables)) {
        variables = Object.keys(variables).map(function (k) {
            var value = variables[k];

            if (! (value instanceof tree.Value)) {
                if (! (value instanceof tree.Expression)) {
                    value = new tree.Expression([value]);
                }
                value = new tree.Value([value]);
            }
            return new tree.Rule('@' + k, value, false, null, 0);
        });
        evalEnv.frames = [new tree.Ruleset(null, variables)];
    }

    var preEvalVisitors = [],
        visitors = [
            new visitor.JoinSelectorVisitor(),
            new visitor.MarkVisibleSelectorsVisitor(true),
            new visitor.ExtendVisitor(),
            new visitor.ToCSSVisitor({compress: Boolean(options.compress)})
        ], i;

    if (options.pluginManager) {
        var pluginVisitors = options.pluginManager.getVisitors();
        for (i = 0; i < pluginVisitors.length; i++) {
            var pluginVisitor = pluginVisitors[i];
            if (pluginVisitor.isPreEvalVisitor) {
                preEvalVisitors.push(pluginVisitor);
            } else {
                if (pluginVisitor.isPreVisitor) {
                    visitors.splice(0, 0, pluginVisitor);
                } else {
                    visitors.push(pluginVisitor);
                }
            }
        }
    }

    for (i = 0; i < preEvalVisitors.length; i++) {
        preEvalVisitors[i].run(root);
    }

    evaldRoot = root.eval(evalEnv);

    for (i = 0; i < visitors.length; i++) {
        visitors[i].run(evaldRoot);
    }

    return evaldRoot;
};

},{"./contexts":11,"./tree":62,"./visitors":87}],45:[function(require,module,exports){
var Node = require("./node");

var Alpha = function (val) {
    this.value = val;
};
Alpha.prototype = new Node();
Alpha.prototype.type = "Alpha";

Alpha.prototype.accept = function (visitor) {
    this.value = visitor.visit(this.value);
};
Alpha.prototype.eval = function (context) {
    if (this.value.eval) { return new Alpha(this.value.eval(context)); }
    return this;
};
Alpha.prototype.genCSS = function (context, output) {
    output.add("alpha(opacity=");

    if (this.value.genCSS) {
        this.value.genCSS(context, output);
    } else {
        output.add(this.value);
    }

    output.add(")");
};

module.exports = Alpha;

},{"./node":70}],46:[function(require,module,exports){
var Node = require("./node");

var Anonymous = function (value, index, currentFileInfo, mapLines, rulesetLike, visibilityInfo) {
    this.value = value;
    this.index = index;
    this.mapLines = mapLines;
    this.currentFileInfo = currentFileInfo;
    this.rulesetLike = (typeof rulesetLike === 'undefined') ? false : rulesetLike;
    this.allowRoot = true;
    this.copyVisibilityInfo(visibilityInfo);
};
Anonymous.prototype = new Node();
Anonymous.prototype.type = "Anonymous";
Anonymous.prototype.eval = function () {
    return new Anonymous(this.value, this.index, this.currentFileInfo, this.mapLines, this.rulesetLike, this.visibilityInfo());
};
Anonymous.prototype.compare = function (other) {
    return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;
};
Anonymous.prototype.isRulesetLike = function() {
    return this.rulesetLike;
};
Anonymous.prototype.genCSS = function (context, output) {
    output.add(this.value, this.currentFileInfo, this.index, this.mapLines);
};
module.exports = Anonymous;

},{"./node":70}],47:[function(require,module,exports){
var Node = require("./node");

var Assignment = function (key, val) {
    this.key = key;
    this.value = val;
};

Assignment.prototype = new Node();
Assignment.prototype.type = "Assignment";
Assignment.prototype.accept = function (visitor) {
    this.value = visitor.visit(this.value);
};
Assignment.prototype.eval = function (context) {
    if (this.value.eval) {
        return new Assignment(this.key, this.value.eval(context));
    }
    return this;
};
Assignment.prototype.genCSS = function (context, output) {
    output.add(this.key + '=');
    if (this.value.genCSS) {
        this.value.genCSS(context, output);
    } else {
        output.add(this.value);
    }
};
module.exports = Assignment;

},{"./node":70}],48:[function(require,module,exports){
var Node = require("./node");

var Attribute = function (key, op, value) {
    this.key = key;
    this.op = op;
    this.value = value;
};
Attribute.prototype = new Node();
Attribute.prototype.type = "Attribute";
Attribute.prototype.eval = function (context) {
    return new Attribute(this.key.eval ? this.key.eval(context) : this.key,
        this.op, (this.value && this.value.eval) ? this.value.eval(context) : this.value);
};
Attribute.prototype.genCSS = function (context, output) {
    output.add(this.toCSS(context));
};
Attribute.prototype.toCSS = function (context) {
    var value = this.key.toCSS ? this.key.toCSS(context) : this.key;

    if (this.op) {
        value += this.op;
        value += (this.value.toCSS ? this.value.toCSS(context) : this.value);
    }

    return '[' + value + ']';
};
module.exports = Attribute;

},{"./node":70}],49:[function(require,module,exports){
var Node = require("./node"),
    FunctionCaller = require("../functions/function-caller");
//
// A function call node.
//
var Call = function (name, args, index, currentFileInfo) {
    this.name = name;
    this.args = args;
    this.index = index;
    this.currentFileInfo = currentFileInfo;
};
Call.prototype = new Node();
Call.prototype.type = "Call";
Call.prototype.accept = function (visitor) {
    if (this.args) {
        this.args = visitor.visitArray(this.args);
    }
};
//
// When evaluating a function call,
// we either find the function in the functionRegistry,
// in which case we call it, passing the  evaluated arguments,
// if this returns null or we cannot find the function, we
// simply print it out as it appeared originally [2].
//
// The reason why we evaluate the arguments, is in the case where
// we try to pass a variable to a function, like: `saturate(@color)`.
// The function should receive the value, not the variable.
//
Call.prototype.eval = function (context) {
    var args = this.args.map(function (a) { return a.eval(context); }),
        result, funcCaller = new FunctionCaller(this.name, context, this.index, this.currentFileInfo);

    if (funcCaller.isValid()) {
        try {
            result = funcCaller.call(args);
        } catch (e) {
            throw { type: e.type || "Runtime",
                    message: "error evaluating function `" + this.name + "`" +
                             (e.message ? ': ' + e.message : ''),
                    index: this.index, filename: this.currentFileInfo.filename };
        }

        if (result != null) {
            result.index = this.index;
            result.currentFileInfo = this.currentFileInfo;
            return result;
        }
    }

    return new Call(this.name, args, this.index, this.currentFileInfo);
};
Call.prototype.genCSS = function (context, output) {
    output.add(this.name + "(", this.currentFileInfo, this.index);

    for (var i = 0; i < this.args.length; i++) {
        this.args[i].genCSS(context, output);
        if (i + 1 < this.args.length) {
            output.add(", ");
        }
    }

    output.add(")");
};
module.exports = Call;

},{"../functions/function-caller":21,"./node":70}],50:[function(require,module,exports){
var Node = require("./node"),
    colors = require("../data/colors");

//
// RGB Colors - #ff0014, #eee
//
var Color = function (rgb, a, originalForm) {
    //
    // The end goal here, is to parse the arguments
    // into an integer triplet, such as `128, 255, 0`
    //
    // This facilitates operations and conversions.
    //
    if (Array.isArray(rgb)) {
        this.rgb = rgb;
    } else if (rgb.length == 6) {
        this.rgb = rgb.match(/.{2}/g).map(function (c) {
            return parseInt(c, 16);
        });
    } else {
        this.rgb = rgb.split('').map(function (c) {
            return parseInt(c + c, 16);
        });
    }
    this.alpha = typeof a === 'number' ? a : 1;
    if (typeof originalForm !== 'undefined') {
        this.value = originalForm;
    }
};

Color.prototype = new Node();
Color.prototype.type = "Color";

function clamp(v, max) {
    return Math.min(Math.max(v, 0), max);
}

function toHex(v) {
    return '#' + v.map(function (c) {
        c = clamp(Math.round(c), 255);
        return (c < 16 ? '0' : '') + c.toString(16);
    }).join('');
}

Color.prototype.luma = function () {
    var r = this.rgb[0] / 255,
        g = this.rgb[1] / 255,
        b = this.rgb[2] / 255;

    r = (r <= 0.03928) ? r / 12.92 : Math.pow(((r + 0.055) / 1.055), 2.4);
    g = (g <= 0.03928) ? g / 12.92 : Math.pow(((g + 0.055) / 1.055), 2.4);
    b = (b <= 0.03928) ? b / 12.92 : Math.pow(((b + 0.055) / 1.055), 2.4);

    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
};
Color.prototype.genCSS = function (context, output) {
    output.add(this.toCSS(context));
};
Color.prototype.toCSS = function (context, doNotCompress) {
    var compress = context && context.compress && !doNotCompress, color, alpha;

    // `value` is set if this color was originally
    // converted from a named color string so we need
    // to respect this and try to output named color too.
    if (this.value) {
        return this.value;
    }

    // If we have some transparency, the only way to represent it
    // is via `rgba`. Otherwise, we use the hex representation,
    // which has better compatibility with older browsers.
    // Values are capped between `0` and `255`, rounded and zero-padded.
    alpha = this.fround(context, this.alpha);
    if (alpha < 1) {
        return "rgba(" + this.rgb.map(function (c) {
            return clamp(Math.round(c), 255);
        }).concat(clamp(alpha, 1))
            .join(',' + (compress ? '' : ' ')) + ")";
    }

    color = this.toRGB();

    if (compress) {
        var splitcolor = color.split('');

        // Convert color to short format
        if (splitcolor[1] === splitcolor[2] && splitcolor[3] === splitcolor[4] && splitcolor[5] === splitcolor[6]) {
            color = '#' + splitcolor[1] + splitcolor[3] + splitcolor[5];
        }
    }

    return color;
};

//
// Operations have to be done per-channel, if not,
// channels will spill onto each other. Once we have
// our result, in the form of an integer triplet,
// we create a new Color node to hold the result.
//
Color.prototype.operate = function (context, op, other) {
    var rgb = [];
    var alpha = this.alpha * (1 - other.alpha) + other.alpha;
    for (var c = 0; c < 3; c++) {
        rgb[c] = this._operate(context, op, this.rgb[c], other.rgb[c]);
    }
    return new Color(rgb, alpha);
};
Color.prototype.toRGB = function () {
    return toHex(this.rgb);
};
Color.prototype.toHSL = function () {
    var r = this.rgb[0] / 255,
        g = this.rgb[1] / 255,
        b = this.rgb[2] / 255,
        a = this.alpha;

    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2, d = max - min;

    if (max === min) {
        h = s = 0;
    } else {
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2;               break;
            case b: h = (r - g) / d + 4;               break;
        }
        h /= 6;
    }
    return { h: h * 360, s: s, l: l, a: a };
};
//Adapted from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
Color.prototype.toHSV = function () {
    var r = this.rgb[0] / 255,
        g = this.rgb[1] / 255,
        b = this.rgb[2] / 255,
        a = this.alpha;

    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, v = max;

    var d = max - min;
    if (max === 0) {
        s = 0;
    } else {
        s = d / max;
    }

    if (max === min) {
        h = 0;
    } else {
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h * 360, s: s, v: v, a: a };
};
Color.prototype.toARGB = function () {
    return toHex([this.alpha * 255].concat(this.rgb));
};
Color.prototype.compare = function (x) {
    return (x.rgb &&
        x.rgb[0] === this.rgb[0] &&
        x.rgb[1] === this.rgb[1] &&
        x.rgb[2] === this.rgb[2] &&
        x.alpha  === this.alpha) ? 0 : undefined;
};

Color.fromKeyword = function(keyword) {
    var c, key = keyword.toLowerCase();
    if (colors.hasOwnProperty(key)) {
        c = new Color(colors[key].slice(1));
    }
    else if (key === "transparent") {
        c = new Color([0, 0, 0], 0);
    }

    if (c) {
        c.value = keyword;
        return c;
    }
};
module.exports = Color;

},{"../data/colors":12,"./node":70}],51:[function(require,module,exports){
var Node = require("./node");

var Combinator = function (value) {
    if (value === ' ') {
        this.value = ' ';
        this.emptyOrWhitespace = true;
    } else {
        this.value = value ? value.trim() : "";
        this.emptyOrWhitespace = this.value === "";
    }
};
Combinator.prototype = new Node();
Combinator.prototype.type = "Combinator";
var _noSpaceCombinators = {
    '': true,
    ' ': true,
    '|': true
};
Combinator.prototype.genCSS = function (context, output) {
    var spaceOrEmpty = (context.compress || _noSpaceCombinators[this.value]) ? '' : ' ';
    output.add(spaceOrEmpty + this.value + spaceOrEmpty);
};
module.exports = Combinator;

},{"./node":70}],52:[function(require,module,exports){
var Node = require("./node"),
    getDebugInfo = require("./debug-info");

var Comment = function (value, isLineComment, index, currentFileInfo) {
    this.value = value;
    this.isLineComment = isLineComment;
    this.index = index;
    this.currentFileInfo = currentFileInfo;
    this.allowRoot = true;
};
Comment.prototype = new Node();
Comment.prototype.type = "Comment";
Comment.prototype.genCSS = function (context, output) {
    if (this.debugInfo) {
        output.add(getDebugInfo(context, this), this.currentFileInfo, this.index);
    }
    output.add(this.value);
};
Comment.prototype.isSilent = function(context) {
    var isCompressed = context.compress && this.value[2] !== "!";
    return this.isLineComment || isCompressed;
};
module.exports = Comment;

},{"./debug-info":54,"./node":70}],53:[function(require,module,exports){
var Node = require("./node");

var Condition = function (op, l, r, i, negate) {
    this.op = op.trim();
    this.lvalue = l;
    this.rvalue = r;
    this.index = i;
    this.negate = negate;
};
Condition.prototype = new Node();
Condition.prototype.type = "Condition";
Condition.prototype.accept = function (visitor) {
    this.lvalue = visitor.visit(this.lvalue);
    this.rvalue = visitor.visit(this.rvalue);
};
Condition.prototype.eval = function (context) {
    var result = (function (op, a, b) {
        switch (op) {
            case 'and': return a && b;
            case 'or':  return a || b;
            default:
                switch (Node.compare(a, b)) {
                    case -1:
                        return op === '<' || op === '=<' || op === '<=';
                    case 0:
                        return op === '=' || op === '>=' || op === '=<' || op === '<=';
                    case 1:
                        return op === '>' || op === '>=';
                    default:
                        return false;
                }
        }
    })(this.op, this.lvalue.eval(context), this.rvalue.eval(context));

    return this.negate ? !result : result;
};
module.exports = Condition;

},{"./node":70}],54:[function(require,module,exports){
var debugInfo = function(context, ctx, lineSeparator) {
    var result = "";
    if (context.dumpLineNumbers && !context.compress) {
        switch(context.dumpLineNumbers) {
            case 'comments':
                result = debugInfo.asComment(ctx);
                break;
            case 'mediaquery':
                result = debugInfo.asMediaQuery(ctx);
                break;
            case 'all':
                result = debugInfo.asComment(ctx) + (lineSeparator || "") + debugInfo.asMediaQuery(ctx);
                break;
        }
    }
    return result;
};

debugInfo.asComment = function(ctx) {
    return '/* line ' + ctx.debugInfo.lineNumber + ', ' + ctx.debugInfo.fileName + ' */\n';
};

debugInfo.asMediaQuery = function(ctx) {
    var filenameWithProtocol = ctx.debugInfo.fileName;
    if (!/^[a-z]+:\/\//i.test(filenameWithProtocol)) {
        filenameWithProtocol = 'file://' + filenameWithProtocol;
    }
    return '@media -sass-debug-info{filename{font-family:' +
        filenameWithProtocol.replace(/([.:\/\\])/g, function (a) {
            if (a == '\\') {
                a = '\/';
            }
            return '\\' + a;
        }) +
        '}line{font-family:\\00003' + ctx.debugInfo.lineNumber + '}}\n';
};

module.exports = debugInfo;

},{}],55:[function(require,module,exports){
var Node = require("./node"),
    contexts = require("../contexts");

var DetachedRuleset = function (ruleset, frames) {
    this.ruleset = ruleset;
    this.frames = frames;
};
DetachedRuleset.prototype = new Node();
DetachedRuleset.prototype.type = "DetachedRuleset";
DetachedRuleset.prototype.evalFirst = true;
DetachedRuleset.prototype.accept = function (visitor) {
    this.ruleset = visitor.visit(this.ruleset);
};
DetachedRuleset.prototype.eval = function (context) {
    var frames = this.frames || context.frames.slice(0);
    return new DetachedRuleset(this.ruleset, frames);
};
DetachedRuleset.prototype.callEval = function (context) {
    return this.ruleset.eval(this.frames ? new contexts.Eval(context, this.frames.concat(context.frames)) : context);
};
module.exports = DetachedRuleset;

},{"../contexts":11,"./node":70}],56:[function(require,module,exports){
var Node = require("./node"),
    unitConversions = require("../data/unit-conversions"),
    Unit = require("./unit"),
    Color = require("./color");

//
// A number with a unit
//
var Dimension = function (value, unit) {
    this.value = parseFloat(value);
    this.unit = (unit && unit instanceof Unit) ? unit :
      new Unit(unit ? [unit] : undefined);
};

Dimension.prototype = new Node();
Dimension.prototype.type = "Dimension";
Dimension.prototype.accept = function (visitor) {
    this.unit = visitor.visit(this.unit);
};
Dimension.prototype.eval = function (context) {
    return this;
};
Dimension.prototype.toColor = function () {
    return new Color([this.value, this.value, this.value]);
};
Dimension.prototype.genCSS = function (context, output) {
    if ((context && context.strictUnits) && !this.unit.isSingular()) {
        throw new Error("Multiple units in dimension. Correct the units or use the unit function. Bad unit: " + this.unit.toString());
    }

    var value = this.fround(context, this.value),
        strValue = String(value);

    if (value !== 0 && value < 0.000001 && value > -0.000001) {
        // would be output 1e-6 etc.
        strValue = value.toFixed(20).replace(/0+$/, "");
    }

    if (context && context.compress) {
        // Zero values doesn't need a unit
        if (value === 0 && this.unit.isLength()) {
            output.add(strValue);
            return;
        }

        // Float values doesn't need a leading zero
        if (value > 0 && value < 1) {
            strValue = (strValue).substr(1);
        }
    }

    output.add(strValue);
    this.unit.genCSS(context, output);
};

// In an operation between two Dimensions,
// we default to the first Dimension's unit,
// so `1px + 2` will yield `3px`.
Dimension.prototype.operate = function (context, op, other) {
    /*jshint noempty:false */
    var value = this._operate(context, op, this.value, other.value),
        unit = this.unit.clone();

    if (op === '+' || op === '-') {
        if (unit.numerator.length === 0 && unit.denominator.length === 0) {
            unit = other.unit.clone();
            if (this.unit.backupUnit) {
                unit.backupUnit = this.unit.backupUnit;
            }
        } else if (other.unit.numerator.length === 0 && unit.denominator.length === 0) {
            // do nothing
        } else {
            other = other.convertTo(this.unit.usedUnits());

            if (context.strictUnits && other.unit.toString() !== unit.toString()) {
                throw new Error("Incompatible units. Change the units or use the unit function. Bad units: '" + unit.toString() +
                    "' and '" + other.unit.toString() + "'.");
            }

            value = this._operate(context, op, this.value, other.value);
        }
    } else if (op === '*') {
        unit.numerator = unit.numerator.concat(other.unit.numerator).sort();
        unit.denominator = unit.denominator.concat(other.unit.denominator).sort();
        unit.cancel();
    } else if (op === '/') {
        unit.numerator = unit.numerator.concat(other.unit.denominator).sort();
        unit.denominator = unit.denominator.concat(other.unit.numerator).sort();
        unit.cancel();
    }
    return new Dimension(value, unit);
};
Dimension.prototype.compare = function (other) {
    var a, b;

    if (!(other instanceof Dimension)) {
        return undefined;
    }

    if (this.unit.isEmpty() || other.unit.isEmpty()) {
        a = this;
        b = other;
    } else {
        a = this.unify();
        b = other.unify();
        if (a.unit.compare(b.unit) !== 0) {
            return undefined;
        }
    }

    return Node.numericCompare(a.value, b.value);
};
Dimension.prototype.unify = function () {
    return this.convertTo({ length: 'px', duration: 's', angle: 'rad' });
};
Dimension.prototype.convertTo = function (conversions) {
    var value = this.value, unit = this.unit.clone(),
        i, groupName, group, targetUnit, derivedConversions = {}, applyUnit;

    if (typeof conversions === 'string') {
        for (i in unitConversions) {
            if (unitConversions[i].hasOwnProperty(conversions)) {
                derivedConversions = {};
                derivedConversions[i] = conversions;
            }
        }
        conversions = derivedConversions;
    }
    applyUnit = function (atomicUnit, denominator) {
        /* jshint loopfunc:true */
        if (group.hasOwnProperty(atomicUnit)) {
            if (denominator) {
                value = value / (group[atomicUnit] / group[targetUnit]);
            } else {
                value = value * (group[atomicUnit] / group[targetUnit]);
            }

            return targetUnit;
        }

        return atomicUnit;
    };

    for (groupName in conversions) {
        if (conversions.hasOwnProperty(groupName)) {
            targetUnit = conversions[groupName];
            group = unitConversions[groupName];

            unit.map(applyUnit);
        }
    }

    unit.cancel();

    return new Dimension(value, unit);
};
module.exports = Dimension;

},{"../data/unit-conversions":14,"./color":50,"./node":70,"./unit":79}],57:[function(require,module,exports){
var Node = require("./node"),
    Selector = require("./selector"),
    Ruleset = require("./ruleset");

var Directive = function (name, value, rules, index, currentFileInfo, debugInfo, isRooted, visibilityInfo) {
    var i;

    this.name  = name;
    this.value = value;
    if (rules) {
        if (Array.isArray(rules)) {
            this.rules = rules;
        } else {
            this.rules = [rules];
            this.rules[0].selectors = (new Selector([], null, null, this.index, currentFileInfo)).createEmptySelectors();
        }
        for (i = 0; i < this.rules.length; i++) {
            this.rules[i].allowImports = true;
        }
    }
    this.index = index;
    this.currentFileInfo = currentFileInfo;
    this.debugInfo = debugInfo;
    this.isRooted = isRooted || false;
    this.copyVisibilityInfo(visibilityInfo);
    this.allowRoot = true;
};

Directive.prototype = new Node();
Directive.prototype.type = "Directive";
Directive.prototype.accept = function (visitor) {
    var value = this.value, rules = this.rules;
    if (rules) {
        this.rules = visitor.visitArray(rules);
    }
    if (value) {
        this.value = visitor.visit(value);
    }
};
Directive.prototype.isRulesetLike = function() {
    return this.rules || !this.isCharset();
};
Directive.prototype.isCharset = function() {
    return "@charset" === this.name;
};
Directive.prototype.genCSS = function (context, output) {
    var value = this.value, rules = this.rules;
    output.add(this.name, this.currentFileInfo, this.index);
    if (value) {
        output.add(' ');
        value.genCSS(context, output);
    }
    if (rules) {
        this.outputRuleset(context, output, rules);
    } else {
        output.add(';');
    }
};
Directive.prototype.eval = function (context) {
    var mediaPathBackup, mediaBlocksBackup, value = this.value, rules = this.rules;

    //media stored inside other directive should not bubble over it
    //backpup media bubbling information
    mediaPathBackup = context.mediaPath;
    mediaBlocksBackup = context.mediaBlocks;
    //deleted media bubbling information
    context.mediaPath = [];
    context.mediaBlocks = [];

    if (value) {
        value = value.eval(context);
    }
    if (rules) {
        // assuming that there is only one rule at this point - that is how parser constructs the rule
        rules = [rules[0].eval(context)];
        rules[0].root = true;
    }
    //restore media bubbling information
    context.mediaPath = mediaPathBackup;
    context.mediaBlocks = mediaBlocksBackup;

    return new Directive(this.name, value, rules,
        this.index, this.currentFileInfo, this.debugInfo, this.isRooted, this.visibilityInfo());
};
Directive.prototype.variable = function (name) {
    if (this.rules) {
        // assuming that there is only one rule at this point - that is how parser constructs the rule
        return Ruleset.prototype.variable.call(this.rules[0], name);
    }
};
Directive.prototype.find = function () {
    if (this.rules) {
        // assuming that there is only one rule at this point - that is how parser constructs the rule
        return Ruleset.prototype.find.apply(this.rules[0], arguments);
    }
};
Directive.prototype.rulesets = function () {
    if (this.rules) {
        // assuming that there is only one rule at this point - that is how parser constructs the rule
        return Ruleset.prototype.rulesets.apply(this.rules[0]);
    }
};
Directive.prototype.outputRuleset = function (context, output, rules) {
    var ruleCnt = rules.length, i;
    context.tabLevel = (context.tabLevel | 0) + 1;

    // Compressed
    if (context.compress) {
        output.add('{');
        for (i = 0; i < ruleCnt; i++) {
            rules[i].genCSS(context, output);
        }
        output.add('}');
        context.tabLevel--;
        return;
    }

    // Non-compressed
    var tabSetStr = '\n' + Array(context.tabLevel).join("  "), tabRuleStr = tabSetStr + "  ";
    if (!ruleCnt) {
        output.add(" {" + tabSetStr + '}');
    } else {
        output.add(" {" + tabRuleStr);
        rules[0].genCSS(context, output);
        for (i = 1; i < ruleCnt; i++) {
            output.add(tabRuleStr);
            rules[i].genCSS(context, output);
        }
        output.add(tabSetStr + '}');
    }

    context.tabLevel--;
};
module.exports = Directive;

},{"./node":70,"./ruleset":76,"./selector":77}],58:[function(require,module,exports){
var Node = require("./node"),
    Paren = require("./paren"),
    Combinator = require("./combinator");

var Element = function (combinator, value, index, currentFileInfo, info) {
    this.combinator = combinator instanceof Combinator ?
                      combinator : new Combinator(combinator);

    if (typeof value === 'string') {
        this.value = value.trim();
    } else if (value) {
        this.value = value;
    } else {
        this.value = "";
    }
    this.index = index;
    this.currentFileInfo = currentFileInfo;
    this.copyVisibilityInfo(info);
};
Element.prototype = new Node();
Element.prototype.type = "Element";
Element.prototype.accept = function (visitor) {
    var value = this.value;
    this.combinator = visitor.visit(this.combinator);
    if (typeof value === "object") {
        this.value = visitor.visit(value);
    }
};
Element.prototype.eval = function (context) {
    return new Element(this.combinator,
                             this.value.eval ? this.value.eval(context) : this.value,
                             this.index,
                             this.currentFileInfo, this.visibilityInfo());
};
Element.prototype.clone = function () {
    return new Element(this.combinator,
        this.value,
        this.index,
        this.currentFileInfo, this.visibilityInfo());
};
Element.prototype.genCSS = function (context, output) {
    output.add(this.toCSS(context), this.currentFileInfo, this.index);
};
Element.prototype.toCSS = function (context) {
    context = context || {};
    var value = this.value, firstSelector = context.firstSelector;
    if (value instanceof Paren) {
        // selector in parens should not be affected by outer selector
        // flags (breaks only interpolated selectors - see #1973)
        context.firstSelector = true;
    }
    value = value.toCSS ? value.toCSS(context) : value;
    context.firstSelector = firstSelector;
    if (value === '' && this.combinator.value.charAt(0) === '&') {
        return '';
    } else {
        return this.combinator.toCSS(context) + value;
    }
};
module.exports = Element;

},{"./combinator":51,"./node":70,"./paren":72}],59:[function(require,module,exports){
var Node = require("./node"),
    Paren = require("./paren"),
    Comment = require("./comment");

var Expression = function (value) {
    this.value = value;
    if (!value) {
        throw new Error("Expression requires an array parameter");
    }
};
Expression.prototype = new Node();
Expression.prototype.type = "Expression";
Expression.prototype.accept = function (visitor) {
    this.value = visitor.visitArray(this.value);
};
Expression.prototype.eval = function (context) {
    var returnValue,
        inParenthesis = this.parens && !this.parensInOp,
        doubleParen = false;
    if (inParenthesis) {
        context.inParenthesis();
    }
    if (this.value.length > 1) {
        returnValue = new Expression(this.value.map(function (e) {
            return e.eval(context);
        }));
    } else if (this.value.length === 1) {
        if (this.value[0].parens && !this.value[0].parensInOp) {
            doubleParen = true;
        }
        returnValue = this.value[0].eval(context);
    } else {
        returnValue = this;
    }
    if (inParenthesis) {
        context.outOfParenthesis();
    }
    if (this.parens && this.parensInOp && !(context.isMathOn()) && !doubleParen) {
        returnValue = new Paren(returnValue);
    }
    return returnValue;
};
Expression.prototype.genCSS = function (context, output) {
    for (var i = 0; i < this.value.length; i++) {
        this.value[i].genCSS(context, output);
        if (i + 1 < this.value.length) {
            output.add(" ");
        }
    }
};
Expression.prototype.throwAwayComments = function () {
    this.value = this.value.filter(function(v) {
        return !(v instanceof Comment);
    });
};
module.exports = Expression;

},{"./comment":52,"./node":70,"./paren":72}],60:[function(require,module,exports){
var Node = require("./node"),
    Selector = require("./selector");

var Extend = function Extend(selector, option, index, currentFileInfo, visibilityInfo) {
    this.selector = selector;
    this.option = option;
    this.index = index;
    this.object_id = Extend.next_id++;
    this.parent_ids = [this.object_id];
    this.currentFileInfo = currentFileInfo || {};
    this.copyVisibilityInfo(visibilityInfo);
    this.allowRoot = true;

    switch(option) {
        case "all":
            this.allowBefore = true;
            this.allowAfter = true;
            break;
        default:
            this.allowBefore = false;
            this.allowAfter = false;
            break;
    }
};
Extend.next_id = 0;

Extend.prototype = new Node();
Extend.prototype.type = "Extend";
Extend.prototype.accept = function (visitor) {
    this.selector = visitor.visit(this.selector);
};
Extend.prototype.eval = function (context) {
    return new Extend(this.selector.eval(context), this.option, this.index, this.currentFileInfo, this.visibilityInfo());
};
Extend.prototype.clone = function (context) {
    return new Extend(this.selector, this.option, this.index, this.currentFileInfo, this.visibilityInfo());
};
//it concatenates (joins) all selectors in selector array
Extend.prototype.findSelfSelectors = function (selectors) {
    var selfElements = [],
        i,
        selectorElements;

    for (i = 0; i < selectors.length; i++) {
        selectorElements = selectors[i].elements;
        // duplicate the logic in genCSS function inside the selector node.
        // future TODO - move both logics into the selector joiner visitor
        if (i > 0 && selectorElements.length && selectorElements[0].combinator.value === "") {
            selectorElements[0].combinator.value = ' ';
        }
        selfElements = selfElements.concat(selectors[i].elements);
    }

    this.selfSelectors = [new Selector(selfElements)];
    this.selfSelectors[0].copyVisibilityInfo(this.visibilityInfo());
};
module.exports = Extend;

},{"./node":70,"./selector":77}],61:[function(require,module,exports){
var Node = require("./node"),
    Media = require("./media"),
    URL = require("./url"),
    Quoted = require("./quoted"),
    Ruleset = require("./ruleset"),
    Anonymous = require("./anonymous");

//
// CSS @import node
//
// The general strategy here is that we don't want to wait
// for the parsing to be completed, before we start importing
// the file. That's because in the context of a browser,
// most of the time will be spent waiting for the server to respond.
//
// On creation, we push the import path to our import queue, though
// `import,push`, we also pass it a callback, which it'll call once
// the file has been fetched, and parsed.
//
var Import = function (path, features, options, index, currentFileInfo, visibilityInfo) {
    this.options = options;
    this.index = index;
    this.path = path;
    this.features = features;
    this.currentFileInfo = currentFileInfo;
    this.allowRoot = true;

    if (this.options.less !== undefined || this.options.inline) {
        this.css = !this.options.less || this.options.inline;
    } else {
        var pathValue = this.getPath();
        if (pathValue && /[#\.\&\?\/]css([\?;].*)?$/.test(pathValue)) {
            this.css = true;
        }
    }
    this.copyVisibilityInfo(visibilityInfo);
};

//
// The actual import node doesn't return anything, when converted to CSS.
// The reason is that it's used at the evaluation stage, so that the rules
// it imports can be treated like any other rules.
//
// In `eval`, we make sure all Import nodes get evaluated, recursively, so
// we end up with a flat structure, which can easily be imported in the parent
// ruleset.
//
Import.prototype = new Node();
Import.prototype.type = "Import";
Import.prototype.accept = function (visitor) {
    if (this.features) {
        this.features = visitor.visit(this.features);
    }
    this.path = visitor.visit(this.path);
    if (!this.options.plugin && !this.options.inline && this.root) {
        this.root = visitor.visit(this.root);
    }
};
Import.prototype.genCSS = function (context, output) {
    if (this.css && this.path.currentFileInfo.reference === undefined) {
        output.add("@import ", this.currentFileInfo, this.index);
        this.path.genCSS(context, output);
        if (this.features) {
            output.add(" ");
            this.features.genCSS(context, output);
        }
        output.add(';');
    }
};
Import.prototype.getPath = function () {
    return (this.path instanceof URL) ?
        this.path.value.value : this.path.value;
};
Import.prototype.isVariableImport = function () {
    var path = this.path;
    if (path instanceof URL) {
        path = path.value;
    }
    if (path instanceof Quoted) {
        return path.containsVariables();
    }

    return true;
};
Import.prototype.evalForImport = function (context) {
    var path = this.path;

    if (path instanceof URL) {
        path = path.value;
    }

    return new Import(path.eval(context), this.features, this.options, this.index, this.currentFileInfo, this.visibilityInfo());
};
Import.prototype.evalPath = function (context) {
    var path = this.path.eval(context);
    var rootpath = this.currentFileInfo && this.currentFileInfo.rootpath;

    if (!(path instanceof URL)) {
        if (rootpath) {
            var pathValue = path.value;
            // Add the base path if the import is relative
            if (pathValue && context.isPathRelative(pathValue)) {
                path.value = rootpath + pathValue;
            }
        }
        path.value = context.normalizePath(path.value);
    }

    return path;
};
Import.prototype.eval = function (context) {
    var result = this.doEval(context);
    if (this.options.reference || this.blocksVisibility()) {
        if (result.length || result.length === 0) {
            result.forEach(function (node) {
                    node.addVisibilityBlock();
                }
            );
        } else {
            result.addVisibilityBlock();
        }
    }
    return result;
};
Import.prototype.doEval = function (context) {
    var ruleset, registry,
        features = this.features && this.features.eval(context);

    if (this.options.plugin) {
        registry = context.frames[0] && context.frames[0].functionRegistry;
        if ( registry && this.root && this.root.functions ) {
            registry.addMultiple( this.root.functions );
        }
        return [];
    }

    if (this.skip) {
        if (typeof this.skip === "function") {
            this.skip = this.skip();
        }
        if (this.skip) {
            return [];
        }
    }
    if (this.options.inline) {
        var contents = new Anonymous(this.root, 0,
          {
              filename: this.importedFilename,
              reference: this.path.currentFileInfo && this.path.currentFileInfo.reference
          }, true, true);

        return this.features ? new Media([contents], this.features.value) : [contents];
    } else if (this.css) {
        var newImport = new Import(this.evalPath(context), features, this.options, this.index);
        if (!newImport.css && this.error) {
            throw this.error;
        }
        return newImport;
    } else {
        ruleset = new Ruleset(null, this.root.rules.slice(0));
        ruleset.evalImports(context);

        return this.features ? new Media(ruleset.rules, this.features.value) : ruleset.rules;
    }
};
module.exports = Import;

},{"./anonymous":46,"./media":66,"./node":70,"./quoted":73,"./ruleset":76,"./url":80}],62:[function(require,module,exports){
var tree = {};

tree.Node = require('./node');
tree.Alpha = require('./alpha');
tree.Color = require('./color');
tree.Directive = require('./directive');
tree.DetachedRuleset = require('./detached-ruleset');
tree.Operation = require('./operation');
tree.Dimension = require('./dimension');
tree.Unit = require('./unit');
tree.Keyword = require('./keyword');
tree.Variable = require('./variable');
tree.Ruleset = require('./ruleset');
tree.Element = require('./element');
tree.Attribute = require('./attribute');
tree.Combinator = require('./combinator');
tree.Selector = require('./selector');
tree.Quoted = require('./quoted');
tree.Expression = require('./expression');
tree.Rule = require('./rule');
tree.Call = require('./call');
tree.URL = require('./url');
tree.Import = require('./import');
tree.mixin = {
    Call: require('./mixin-call'),
    Definition: require('./mixin-definition')
};
tree.Comment = require('./comment');
tree.Anonymous = require('./anonymous');
tree.Value = require('./value');
tree.JavaScript = require('./javascript');
tree.Assignment = require('./assignment');
tree.Condition = require('./condition');
tree.Paren = require('./paren');
tree.Media = require('./media');
tree.UnicodeDescriptor = require('./unicode-descriptor');
tree.Negative = require('./negative');
tree.Extend = require('./extend');
tree.RulesetCall = require('./ruleset-call');

module.exports = tree;

},{"./alpha":45,"./anonymous":46,"./assignment":47,"./attribute":48,"./call":49,"./color":50,"./combinator":51,"./comment":52,"./condition":53,"./detached-ruleset":55,"./dimension":56,"./directive":57,"./element":58,"./expression":59,"./extend":60,"./import":61,"./javascript":63,"./keyword":65,"./media":66,"./mixin-call":67,"./mixin-definition":68,"./negative":69,"./node":70,"./operation":71,"./paren":72,"./quoted":73,"./rule":74,"./ruleset":76,"./ruleset-call":75,"./selector":77,"./unicode-descriptor":78,"./unit":79,"./url":80,"./value":81,"./variable":82}],63:[function(require,module,exports){
var JsEvalNode = require("./js-eval-node"),
    Dimension = require("./dimension"),
    Quoted = require("./quoted"),
    Anonymous = require("./anonymous");

var JavaScript = function (string, escaped, index, currentFileInfo) {
    this.escaped = escaped;
    this.expression = string;
    this.index = index;
    this.currentFileInfo = currentFileInfo;
};
JavaScript.prototype = new JsEvalNode();
JavaScript.prototype.type = "JavaScript";
JavaScript.prototype.eval = function(context) {
    var result = this.evaluateJavaScript(this.expression, context);

    if (typeof result === 'number') {
        return new Dimension(result);
    } else if (typeof result === 'string') {
        return new Quoted('"' + result + '"', result, this.escaped, this.index);
    } else if (Array.isArray(result)) {
        return new Anonymous(result.join(', '));
    } else {
        return new Anonymous(result);
    }
};

module.exports = JavaScript;

},{"./anonymous":46,"./dimension":56,"./js-eval-node":64,"./quoted":73}],64:[function(require,module,exports){
var Node = require("./node"),
    Variable = require("./variable");

var JsEvalNode = function() {
};
JsEvalNode.prototype = new Node();

JsEvalNode.prototype.evaluateJavaScript = function (expression, context) {
    var result,
        that = this,
        evalContext = {};

    if (context.javascriptEnabled !== undefined && !context.javascriptEnabled) {
        throw { message: "You are using JavaScript, which has been disabled.",
            filename: this.currentFileInfo.filename,
            index: this.index };
    }

    expression = expression.replace(/@\{([\w-]+)\}/g, function (_, name) {
        return that.jsify(new Variable('@' + name, that.index, that.currentFileInfo).eval(context));
    });

    try {
        expression = new Function('return (' + expression + ')');
    } catch (e) {
        throw { message: "JavaScript evaluation error: " + e.message + " from `" + expression + "`" ,
            filename: this.currentFileInfo.filename,
            index: this.index };
    }

    var variables = context.frames[0].variables();
    for (var k in variables) {
        if (variables.hasOwnProperty(k)) {
            /*jshint loopfunc:true */
            evalContext[k.slice(1)] = {
                value: variables[k].value,
                toJS: function () {
                    return this.value.eval(context).toCSS();
                }
            };
        }
    }

    try {
        result = expression.call(evalContext);
    } catch (e) {
        throw { message: "JavaScript evaluation error: '" + e.name + ': ' + e.message.replace(/["]/g, "'") + "'" ,
            filename: this.currentFileInfo.filename,
            index: this.index };
    }
    return result;
};
JsEvalNode.prototype.jsify = function (obj) {
    if (Array.isArray(obj.value) && (obj.value.length > 1)) {
        return '[' + obj.value.map(function (v) { return v.toCSS(); }).join(', ') + ']';
    } else {
        return obj.toCSS();
    }
};

module.exports = JsEvalNode;

},{"./node":70,"./variable":82}],65:[function(require,module,exports){
var Node = require("./node");

var Keyword = function (value) { this.value = value; };
Keyword.prototype = new Node();
Keyword.prototype.type = "Keyword";
Keyword.prototype.genCSS = function (context, output) {
    if (this.value === '%') { throw { type: "Syntax", message: "Invalid % without number" }; }
    output.add(this.value);
};

Keyword.True = new Keyword('true');
Keyword.False = new Keyword('false');

module.exports = Keyword;

},{"./node":70}],66:[function(require,module,exports){
var Ruleset = require("./ruleset"),
    Value = require("./value"),
    Selector = require("./selector"),
    Anonymous = require("./anonymous"),
    Expression = require("./expression"),
    Directive = require("./directive");

var Media = function (value, features, index, currentFileInfo, visibilityInfo) {
    this.index = index;
    this.currentFileInfo = currentFileInfo;

    var selectors = (new Selector([], null, null, this.index, this.currentFileInfo)).createEmptySelectors();

    this.features = new Value(features);
    this.rules = [new Ruleset(selectors, value)];
    this.rules[0].allowImports = true;
    this.copyVisibilityInfo(visibilityInfo);
    this.allowRoot = true;
};
Media.prototype = new Directive();
Media.prototype.type = "Media";
Media.prototype.isRulesetLike = true;
Media.prototype.accept = function (visitor) {
    if (this.features) {
        this.features = visitor.visit(this.features);
    }
    if (this.rules) {
        this.rules = visitor.visitArray(this.rules);
    }
};
Media.prototype.genCSS = function (context, output) {
    output.add('@media ', this.currentFileInfo, this.index);
    this.features.genCSS(context, output);
    this.outputRuleset(context, output, this.rules);
};
Media.prototype.eval = function (context) {
    if (!context.mediaBlocks) {
        context.mediaBlocks = [];
        context.mediaPath = [];
    }

    var media = new Media(null, [], this.index, this.currentFileInfo, this.visibilityInfo());
    if (this.debugInfo) {
        this.rules[0].debugInfo = this.debugInfo;
        media.debugInfo = this.debugInfo;
    }
    var strictMathBypass = false;
    if (!context.strictMath) {
        strictMathBypass = true;
        context.strictMath = true;
    }
    try {
        media.features = this.features.eval(context);
    }
    finally {
        if (strictMathBypass) {
            context.strictMath = false;
        }
    }

    context.mediaPath.push(media);
    context.mediaBlocks.push(media);

    this.rules[0].functionRegistry = context.frames[0].functionRegistry.inherit();
    context.frames.unshift(this.rules[0]);
    media.rules = [this.rules[0].eval(context)];
    context.frames.shift();

    context.mediaPath.pop();

    return context.mediaPath.length === 0 ? media.evalTop(context) :
                media.evalNested(context);
};
Media.prototype.evalTop = function (context) {
    var result = this;

    // Render all dependent Media blocks.
    if (context.mediaBlocks.length > 1) {
        var selectors = (new Selector([], null, null, this.index, this.currentFileInfo)).createEmptySelectors();
        result = new Ruleset(selectors, context.mediaBlocks);
        result.multiMedia = true;
        result.copyVisibilityInfo(this.visibilityInfo());
    }

    delete context.mediaBlocks;
    delete context.mediaPath;

    return result;
};
Media.prototype.evalNested = function (context) {
    var i, value,
        path = context.mediaPath.concat([this]);

    // Extract the media-query conditions separated with `,` (OR).
    for (i = 0; i < path.length; i++) {
        value = path[i].features instanceof Value ?
                    path[i].features.value : path[i].features;
        path[i] = Array.isArray(value) ? value : [value];
    }

    // Trace all permutations to generate the resulting media-query.
    //
    // (a, b and c) with nested (d, e) ->
    //    a and d
    //    a and e
    //    b and c and d
    //    b and c and e
    this.features = new Value(this.permute(path).map(function (path) {
        path = path.map(function (fragment) {
            return fragment.toCSS ? fragment : new Anonymous(fragment);
        });

        for (i = path.length - 1; i > 0; i--) {
            path.splice(i, 0, new Anonymous("and"));
        }

        return new Expression(path);
    }));

    // Fake a tree-node that doesn't output anything.
    return new Ruleset([], []);
};
Media.prototype.permute = function (arr) {
    if (arr.length === 0) {
        return [];
    } else if (arr.length === 1) {
        return arr[0];
    } else {
        var result = [];
        var rest = this.permute(arr.slice(1));
        for (var i = 0; i < rest.length; i++) {
            for (var j = 0; j < arr[0].length; j++) {
                result.push([arr[0][j]].concat(rest[i]));
            }
        }
        return result;
    }
};
Media.prototype.bubbleSelectors = function (selectors) {
    if (!selectors) {
        return;
    }
    this.rules = [new Ruleset(selectors.slice(0), [this.rules[0]])];
};
module.exports = Media;

},{"./anonymous":46,"./directive":57,"./expression":59,"./ruleset":76,"./selector":77,"./value":81}],67:[function(require,module,exports){
var Node = require("./node"),
    Selector = require("./selector"),
    MixinDefinition = require("./mixin-definition"),
    defaultFunc = require("../functions/default");

var MixinCall = function (elements, args, index, currentFileInfo, important) {
    this.selector = new Selector(elements);
    this.arguments = args || [];
    this.index = index;
    this.currentFileInfo = currentFileInfo;
    this.important = important;
    this.allowRoot = true;
};
MixinCall.prototype = new Node();
MixinCall.prototype.type = "MixinCall";
MixinCall.prototype.accept = function (visitor) {
    if (this.selector) {
        this.selector = visitor.visit(this.selector);
    }
    if (this.arguments.length) {
        this.arguments = visitor.visitArray(this.arguments);
    }
};
MixinCall.prototype.eval = function (context) {
    var mixins, mixin, mixinPath, args = [], arg, argValue,
        rules = [], match = false, i, m, f, isRecursive, isOneFound,
        candidates = [], candidate, conditionResult = [], defaultResult, defFalseEitherCase = -1,
        defNone = 0, defTrue = 1, defFalse = 2, count, originalRuleset, noArgumentsFilter;

    function calcDefGroup(mixin, mixinPath) {
        var f, p, namespace;

        for (f = 0; f < 2; f++) {
            conditionResult[f] = true;
            defaultFunc.value(f);
            for (p = 0; p < mixinPath.length && conditionResult[f]; p++) {
                namespace = mixinPath[p];
                if (namespace.matchCondition) {
                    conditionResult[f] = conditionResult[f] && namespace.matchCondition(null, context);
                }
            }
            if (mixin.matchCondition) {
                conditionResult[f] = conditionResult[f] && mixin.matchCondition(args, context);
            }
        }
        if (conditionResult[0] || conditionResult[1]) {
            if (conditionResult[0] != conditionResult[1]) {
                return conditionResult[1] ?
                    defTrue : defFalse;
            }

            return defNone;
        }
        return defFalseEitherCase;
    }

    for (i = 0; i < this.arguments.length; i++) {
        arg = this.arguments[i];
        argValue = arg.value.eval(context);
        if (arg.expand && Array.isArray(argValue.value)) {
            argValue = argValue.value;
            for (m = 0; m < argValue.length; m++) {
                args.push({value: argValue[m]});
            }
        } else {
            args.push({name: arg.name, value: argValue});
        }
    }

    noArgumentsFilter = function(rule) {return rule.matchArgs(null, context);};

    for (i = 0; i < context.frames.length; i++) {
        if ((mixins = context.frames[i].find(this.selector, null, noArgumentsFilter)).length > 0) {
            isOneFound = true;

            // To make `default()` function independent of definition order we have two "subpasses" here.
            // At first we evaluate each guard *twice* (with `default() == true` and `default() == false`),
            // and build candidate list with corresponding flags. Then, when we know all possible matches,
            // we make a final decision.

            for (m = 0; m < mixins.length; m++) {
                mixin = mixins[m].rule;
                mixinPath = mixins[m].path;
                isRecursive = false;
                for (f = 0; f < context.frames.length; f++) {
                    if ((!(mixin instanceof MixinDefinition)) && mixin === (context.frames[f].originalRuleset || context.frames[f])) {
                        isRecursive = true;
                        break;
                    }
                }
                if (isRecursive) {
                    continue;
                }

                if (mixin.matchArgs(args, context)) {
                    candidate = {mixin: mixin, group: calcDefGroup(mixin, mixinPath)};

                    if (candidate.group !== defFalseEitherCase) {
                        candidates.push(candidate);
                    }

                    match = true;
                }
            }

            defaultFunc.reset();

            count = [0, 0, 0];
            for (m = 0; m < candidates.length; m++) {
                count[candidates[m].group]++;
            }

            if (count[defNone] > 0) {
                defaultResult = defFalse;
            } else {
                defaultResult = defTrue;
                if ((count[defTrue] + count[defFalse]) > 1) {
                    throw { type: 'Runtime',
                        message: 'Ambiguous use of `default()` found when matching for `' + this.format(args) + '`',
                        index: this.index, filename: this.currentFileInfo.filename };
                }
            }

            for (m = 0; m < candidates.length; m++) {
                candidate = candidates[m].group;
                if ((candidate === defNone) || (candidate === defaultResult)) {
                    try {
                        mixin = candidates[m].mixin;
                        if (!(mixin instanceof MixinDefinition)) {
                            originalRuleset = mixin.originalRuleset || mixin;
                            mixin = new MixinDefinition("", [], mixin.rules, null, false, null, originalRuleset.visibilityInfo());
                            mixin.originalRuleset = originalRuleset;
                        }
                        var newRules = mixin.evalCall(context, args, this.important).rules;
                        this._setVisibilityToReplacement(newRules);
                        Array.prototype.push.apply(rules, newRules);
                    } catch (e) {
                        throw { message: e.message, index: this.index, filename: this.currentFileInfo.filename, stack: e.stack };
                    }
                }
            }

            if (match) {
                return rules;
            }
        }
    }
    if (isOneFound) {
        throw { type:    'Runtime',
            message: 'No matching definition was found for `' + this.format(args) + '`',
            index:   this.index, filename: this.currentFileInfo.filename };
    } else {
        throw { type:    'Name',
            message: this.selector.toCSS().trim() + " is undefined",
            index:   this.index, filename: this.currentFileInfo.filename };
    }
};

MixinCall.prototype._setVisibilityToReplacement = function (replacement) {
    var i, rule;
    if (this.blocksVisibility()) {
        for (i = 0; i < replacement.length; i++) {
            rule = replacement[i];
            rule.addVisibilityBlock();
        }
    }
};
MixinCall.prototype.format = function (args) {
    return this.selector.toCSS().trim() + '(' +
        (args ? args.map(function (a) {
            var argValue = "";
            if (a.name) {
                argValue += a.name + ":";
            }
            if (a.value.toCSS) {
                argValue += a.value.toCSS();
            } else {
                argValue += "???";
            }
            return argValue;
        }).join(', ') : "") + ")";
};
module.exports = MixinCall;

},{"../functions/default":20,"./mixin-definition":68,"./node":70,"./selector":77}],68:[function(require,module,exports){
var Selector = require("./selector"),
    Element = require("./element"),
    Ruleset = require("./ruleset"),
    Rule = require("./rule"),
    Expression = require("./expression"),
    contexts = require("../contexts");

var Definition = function (name, params, rules, condition, variadic, frames, visibilityInfo) {
    this.name = name;
    this.selectors = [new Selector([new Element(null, name, this.index, this.currentFileInfo)])];
    this.params = params;
    this.condition = condition;
    this.variadic = variadic;
    this.arity = params.length;
    this.rules = rules;
    this._lookups = {};
    var optionalParameters = [];
    this.required = params.reduce(function (count, p) {
        if (!p.name || (p.name && !p.value)) {
            return count + 1;
        }
        else {
            optionalParameters.push(p.name);
            return count;
        }
    }, 0);
    this.optionalParameters = optionalParameters;
    this.frames = frames;
    this.copyVisibilityInfo(visibilityInfo);
    this.allowRoot = true;
};
Definition.prototype = new Ruleset();
Definition.prototype.type = "MixinDefinition";
Definition.prototype.evalFirst = true;
Definition.prototype.accept = function (visitor) {
    if (this.params && this.params.length) {
        this.params = visitor.visitArray(this.params);
    }
    this.rules = visitor.visitArray(this.rules);
    if (this.condition) {
        this.condition = visitor.visit(this.condition);
    }
};
Definition.prototype.evalParams = function (context, mixinEnv, args, evaldArguments) {
    /*jshint boss:true */
    var frame = new Ruleset(null, null),
        varargs, arg,
        params = this.params.slice(0),
        i, j, val, name, isNamedFound, argIndex, argsLength = 0;

    if (mixinEnv.frames && mixinEnv.frames[0] && mixinEnv.frames[0].functionRegistry) {
        frame.functionRegistry = mixinEnv.frames[0].functionRegistry.inherit();
    }
    mixinEnv = new contexts.Eval(mixinEnv, [frame].concat(mixinEnv.frames));

    if (args) {
        args = args.slice(0);
        argsLength = args.length;

        for (i = 0; i < argsLength; i++) {
            arg = args[i];
            if (name = (arg && arg.name)) {
                isNamedFound = false;
                for (j = 0; j < params.length; j++) {
                    if (!evaldArguments[j] && name === params[j].name) {
                        evaldArguments[j] = arg.value.eval(context);
                        frame.prependRule(new Rule(name, arg.value.eval(context)));
                        isNamedFound = true;
                        break;
                    }
                }
                if (isNamedFound) {
                    args.splice(i, 1);
                    i--;
                    continue;
                } else {
                    throw { type: 'Runtime', message: "Named argument for " + this.name +
                        ' ' + args[i].name + ' not found' };
                }
            }
        }
    }
    argIndex = 0;
    for (i = 0; i < params.length; i++) {
        if (evaldArguments[i]) { continue; }

        arg = args && args[argIndex];

        if (name = params[i].name) {
            if (params[i].variadic) {
                varargs = [];
                for (j = argIndex; j < argsLength; j++) {
                    varargs.push(args[j].value.eval(context));
                }
                frame.prependRule(new Rule(name, new Expression(varargs).eval(context)));
            } else {
                val = arg && arg.value;
                if (val) {
                    val = val.eval(context);
                } else if (params[i].value) {
                    val = params[i].value.eval(mixinEnv);
                    frame.resetCache();
                } else {
                    throw { type: 'Runtime', message: "wrong number of arguments for " + this.name +
                        ' (' + argsLength + ' for ' + this.arity + ')' };
                }

                frame.prependRule(new Rule(name, val));
                evaldArguments[i] = val;
            }
        }

        if (params[i].variadic && args) {
            for (j = argIndex; j < argsLength; j++) {
                evaldArguments[j] = args[j].value.eval(context);
            }
        }
        argIndex++;
    }

    return frame;
};
Definition.prototype.makeImportant = function() {
    var rules = !this.rules ? this.rules : this.rules.map(function (r) {
        if (r.makeImportant) {
            return r.makeImportant(true);
        } else {
            return r;
        }
    });
    var result = new Definition(this.name, this.params, rules, this.condition, this.variadic, this.frames);
    return result;
};
Definition.prototype.eval = function (context) {
    return new Definition(this.name, this.params, this.rules, this.condition, this.variadic, this.frames || context.frames.slice(0));
};
Definition.prototype.evalCall = function (context, args, important) {
    var _arguments = [],
        mixinFrames = this.frames ? this.frames.concat(context.frames) : context.frames,
        frame = this.evalParams(context, new contexts.Eval(context, mixinFrames), args, _arguments),
        rules, ruleset;

    frame.prependRule(new Rule('@arguments', new Expression(_arguments).eval(context)));

    rules = this.rules.slice(0);

    ruleset = new Ruleset(null, rules);
    ruleset.originalRuleset = this;
    ruleset = ruleset.eval(new contexts.Eval(context, [this, frame].concat(mixinFrames)));
    if (important) {
        ruleset = ruleset.makeImportant();
    }
    return ruleset;
};
Definition.prototype.matchCondition = function (args, context) {
    if (this.condition && !this.condition.eval(
        new contexts.Eval(context,
            [this.evalParams(context, /* the parameter variables*/
                new contexts.Eval(context, this.frames ? this.frames.concat(context.frames) : context.frames), args, [])]
            .concat(this.frames || []) // the parent namespace/mixin frames
            .concat(context.frames)))) { // the current environment frames
        return false;
    }
    return true;
};
Definition.prototype.matchArgs = function (args, context) {
    var allArgsCnt = (args && args.length) || 0, len, optionalParameters = this.optionalParameters;
    var requiredArgsCnt = !args ? 0 : args.reduce(function (count, p) {
        if (optionalParameters.indexOf(p.name) < 0) {
            return count + 1;
        } else {
            return count;
        }
    }, 0);

    if (! this.variadic) {
        if (requiredArgsCnt < this.required) {
            return false;
        }
        if (allArgsCnt > this.params.length) {
            return false;
        }
    } else {
        if (requiredArgsCnt < (this.required - 1)) {
            return false;
        }
    }

    // check patterns
    len = Math.min(requiredArgsCnt, this.arity);

    for (var i = 0; i < len; i++) {
        if (!this.params[i].name && !this.params[i].variadic) {
            if (args[i].value.eval(context).toCSS() != this.params[i].value.eval(context).toCSS()) {
                return false;
            }
        }
    }
    return true;
};
module.exports = Definition;

},{"../contexts":11,"./element":58,"./expression":59,"./rule":74,"./ruleset":76,"./selector":77}],69:[function(require,module,exports){
var Node = require("./node"),
    Operation = require("./operation"),
    Dimension = require("./dimension");

var Negative = function (node) {
    this.value = node;
};
Negative.prototype = new Node();
Negative.prototype.type = "Negative";
Negative.prototype.genCSS = function (context, output) {
    output.add('-');
    this.value.genCSS(context, output);
};
Negative.prototype.eval = function (context) {
    if (context.isMathOn()) {
        return (new Operation('*', [new Dimension(-1), this.value])).eval(context);
    }
    return new Negative(this.value.eval(context));
};
module.exports = Negative;

},{"./dimension":56,"./node":70,"./operation":71}],70:[function(require,module,exports){
var Node = function() {
};
Node.prototype.toCSS = function (context) {
    var strs = [];
    this.genCSS(context, {
        add: function(chunk, fileInfo, index) {
            strs.push(chunk);
        },
        isEmpty: function () {
            return strs.length === 0;
        }
    });
    return strs.join('');
};
Node.prototype.genCSS = function (context, output) {
    output.add(this.value);
};
Node.prototype.accept = function (visitor) {
    this.value = visitor.visit(this.value);
};
Node.prototype.eval = function () { return this; };
Node.prototype._operate = function (context, op, a, b) {
    switch (op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return a / b;
    }
};
Node.prototype.fround = function(context, value) {
    var precision = context && context.numPrecision;
    //add "epsilon" to ensure numbers like 1.000000005 (represented as 1.000000004999....) are properly rounded...
    return (precision == null) ? value : Number((value + 2e-16).toFixed(precision));
};
Node.compare = function (a, b) {
    /* returns:
     -1: a < b
     0: a = b
     1: a > b
     and *any* other value for a != b (e.g. undefined, NaN, -2 etc.) */

    if ((a.compare) &&
        // for "symmetric results" force toCSS-based comparison
        // of Quoted or Anonymous if either value is one of those
        !(b.type === "Quoted" || b.type === "Anonymous")) {
        return a.compare(b);
    } else if (b.compare) {
        return -b.compare(a);
    } else if (a.type !== b.type) {
        return undefined;
    }

    a = a.value;
    b = b.value;
    if (!Array.isArray(a)) {
        return a === b ? 0 : undefined;
    }
    if (a.length !== b.length) {
        return undefined;
    }
    for (var i = 0; i < a.length; i++) {
        if (Node.compare(a[i], b[i]) !== 0) {
            return undefined;
        }
    }
    return 0;
};

Node.numericCompare = function (a, b) {
    return a  <  b ? -1
        : a === b ?  0
        : a  >  b ?  1 : undefined;
};
// Returns true if this node represents root of ast imported by reference
Node.prototype.blocksVisibility = function () {
    if (this.visibilityBlocks == null) {
        this.visibilityBlocks = 0;
    }
    return this.visibilityBlocks !== 0;
};
Node.prototype.addVisibilityBlock = function () {
    if (this.visibilityBlocks == null) {
        this.visibilityBlocks = 0;
    }
    this.visibilityBlocks = this.visibilityBlocks + 1;
};
Node.prototype.removeVisibilityBlock = function () {
    if (this.visibilityBlocks == null) {
        this.visibilityBlocks = 0;
    }
    this.visibilityBlocks = this.visibilityBlocks - 1;
};
//Turns on node visibility - if called node will be shown in output regardless
//of whether it comes from import by reference or not
Node.prototype.ensureVisibility = function () {
    this.nodeVisible = true;
};
//Turns off node visibility - if called node will NOT be shown in output regardless
//of whether it comes from import by reference or not
Node.prototype.ensureInvisibility = function () {
    this.nodeVisible = false;
};
// return values:
// false - the node must not be visible
// true - the node must be visible
// undefined or null - the node has the same visibility as its parent
Node.prototype.isVisible = function () {
    return this.nodeVisible;
};
Node.prototype.visibilityInfo = function() {
    return {
        visibilityBlocks: this.visibilityBlocks,
        nodeVisible: this.nodeVisible
    };
};
Node.prototype.copyVisibilityInfo = function(info) {
    if (!info) {
        return;
    }
    this.visibilityBlocks = info.visibilityBlocks;
    this.nodeVisible = info.nodeVisible;
};
module.exports = Node;

},{}],71:[function(require,module,exports){
var Node = require("./node"),
    Color = require("./color"),
    Dimension = require("./dimension");

var Operation = function (op, operands, isSpaced) {
    this.op = op.trim();
    this.operands = operands;
    this.isSpaced = isSpaced;
};
Operation.prototype = new Node();
Operation.prototype.type = "Operation";
Operation.prototype.accept = function (visitor) {
    this.operands = visitor.visit(this.operands);
};
Operation.prototype.eval = function (context) {
    var a = this.operands[0].eval(context),
        b = this.operands[1].eval(context);

    if (context.isMathOn()) {
        if (a instanceof Dimension && b instanceof Color) {
            a = a.toColor();
        }
        if (b instanceof Dimension && a instanceof Color) {
            b = b.toColor();
        }
        if (!a.operate) {
            throw { type: "Operation",
                    message: "Operation on an invalid type" };
        }

        return a.operate(context, this.op, b);
    } else {
        return new Operation(this.op, [a, b], this.isSpaced);
    }
};
Operation.prototype.genCSS = function (context, output) {
    this.operands[0].genCSS(context, output);
    if (this.isSpaced) {
        output.add(" ");
    }
    output.add(this.op);
    if (this.isSpaced) {
        output.add(" ");
    }
    this.operands[1].genCSS(context, output);
};

module.exports = Operation;

},{"./color":50,"./dimension":56,"./node":70}],72:[function(require,module,exports){
var Node = require("./node");

var Paren = function (node) {
    this.value = node;
};
Paren.prototype = new Node();
Paren.prototype.type = "Paren";
Paren.prototype.genCSS = function (context, output) {
    output.add('(');
    this.value.genCSS(context, output);
    output.add(')');
};
Paren.prototype.eval = function (context) {
    return new Paren(this.value.eval(context));
};
module.exports = Paren;

},{"./node":70}],73:[function(require,module,exports){
var Node = require("./node"),
    JsEvalNode = require("./js-eval-node"),
    Variable = require("./variable");

var Quoted = function (str, content, escaped, index, currentFileInfo) {
    this.escaped = (escaped == null) ? true : escaped;
    this.value = content || '';
    this.quote = str.charAt(0);
    this.index = index;
    this.currentFileInfo = currentFileInfo;
};
Quoted.prototype = new JsEvalNode();
Quoted.prototype.type = "Quoted";
Quoted.prototype.genCSS = function (context, output) {
    if (!this.escaped) {
        output.add(this.quote, this.currentFileInfo, this.index);
    }
    output.add(this.value);
    if (!this.escaped) {
        output.add(this.quote);
    }
};
Quoted.prototype.containsVariables = function() {
    return this.value.match(/(`([^`]+)`)|@\{([\w-]+)\}/);
};
Quoted.prototype.eval = function (context) {
    var that = this, value = this.value;
    var javascriptReplacement = function (_, exp) {
        return String(that.evaluateJavaScript(exp, context));
    };
    var interpolationReplacement = function (_, name) {
        var v = new Variable('@' + name, that.index, that.currentFileInfo).eval(context, true);
        return (v instanceof Quoted) ? v.value : v.toCSS();
    };
    function iterativeReplace(value, regexp, replacementFnc) {
        var evaluatedValue = value;
        do {
            value = evaluatedValue;
            evaluatedValue = value.replace(regexp, replacementFnc);
        } while (value !== evaluatedValue);
        return evaluatedValue;
    }
    value = iterativeReplace(value, /`([^`]+)`/g, javascriptReplacement);
    value = iterativeReplace(value, /@\{([\w-]+)\}/g, interpolationReplacement);
    return new Quoted(this.quote + value + this.quote, value, this.escaped, this.index, this.currentFileInfo);
};
Quoted.prototype.compare = function (other) {
    // when comparing quoted strings allow the quote to differ
    if (other.type === "Quoted" && !this.escaped && !other.escaped) {
        return Node.numericCompare(this.value, other.value);
    } else {
        return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;
    }
};
module.exports = Quoted;

},{"./js-eval-node":64,"./node":70,"./variable":82}],74:[function(require,module,exports){
var Node = require("./node"),
    Value = require("./value"),
    Keyword = require("./keyword");

var Rule = function (name, value, important, merge, index, currentFileInfo, inline, variable) {
    this.name = name;
    this.value = (value instanceof Node) ? value : new Value([value]); //value instanceof tree.Value || value instanceof tree.Ruleset ??
    this.important = important ? ' ' + important.trim() : '';
    this.merge = merge;
    this.index = index;
    this.currentFileInfo = currentFileInfo;
    this.inline = inline || false;
    this.variable = (variable !== undefined) ? variable
        : (name.charAt && (name.charAt(0) === '@'));
    this.allowRoot = true;
};

function evalName(context, name) {
    var value = "", i, n = name.length,
        output = {add: function (s) {value += s;}};
    for (i = 0; i < n; i++) {
        name[i].eval(context).genCSS(context, output);
    }
    return value;
}

Rule.prototype = new Node();
Rule.prototype.type = "Rule";
Rule.prototype.genCSS = function (context, output) {
    output.add(this.name + (context.compress ? ':' : ': '), this.currentFileInfo, this.index);
    try {
        this.value.genCSS(context, output);
    }
    catch(e) {
        e.index = this.index;
        e.filename = this.currentFileInfo.filename;
        throw e;
    }
    output.add(this.important + ((this.inline || (context.lastRule && context.compress)) ? "" : ";"), this.currentFileInfo, this.index);
};
Rule.prototype.eval = function (context) {
    var strictMathBypass = false, name = this.name, evaldValue, variable = this.variable;
    if (typeof name !== "string") {
        // expand 'primitive' name directly to get
        // things faster (~10% for benchmark.less):
        name = (name.length === 1) && (name[0] instanceof Keyword) ?
                name[0].value : evalName(context, name);
        variable = false; // never treat expanded interpolation as new variable name
    }
    if (name === "font" && !context.strictMath) {
        strictMathBypass = true;
        context.strictMath = true;
    }
    try {
        context.importantScope.push({});
        evaldValue = this.value.eval(context);

        if (!this.variable && evaldValue.type === "DetachedRuleset") {
            throw { message: "Rulesets cannot be evaluated on a property.",
                    index: this.index, filename: this.currentFileInfo.filename };
        }
        var important = this.important,
            importantResult = context.importantScope.pop();
        if (!important && importantResult.important) {
            important = importantResult.important;
        }

        return new Rule(name,
                          evaldValue,
                          important,
                          this.merge,
                          this.index, this.currentFileInfo, this.inline,
                              variable);
    }
    catch(e) {
        if (typeof e.index !== 'number') {
            e.index = this.index;
            e.filename = this.currentFileInfo.filename;
        }
        throw e;
    }
    finally {
        if (strictMathBypass) {
            context.strictMath = false;
        }
    }
};
Rule.prototype.makeImportant = function () {
    return new Rule(this.name,
                          this.value,
                          "!important",
                          this.merge,
                          this.index, this.currentFileInfo, this.inline);
};

module.exports = Rule;
},{"./keyword":65,"./node":70,"./value":81}],75:[function(require,module,exports){
var Node = require("./node"),
    Variable = require("./variable");

var RulesetCall = function (variable) {
    this.variable = variable;
    this.allowRoot = true;
};
RulesetCall.prototype = new Node();
RulesetCall.prototype.type = "RulesetCall";
RulesetCall.prototype.eval = function (context) {
    var detachedRuleset = new Variable(this.variable).eval(context);
    return detachedRuleset.callEval(context);
};
module.exports = RulesetCall;

},{"./node":70,"./variable":82}],76:[function(require,module,exports){
var Node = require("./node"),
    Rule = require("./rule"),
    Selector = require("./selector"),
    Element = require("./element"),
    Paren = require("./paren"),
    contexts = require("../contexts"),
    globalFunctionRegistry = require("../functions/function-registry"),
    defaultFunc = require("../functions/default"),
    getDebugInfo = require("./debug-info");

var Ruleset = function (selectors, rules, strictImports, visibilityInfo) {
    this.selectors = selectors;
    this.rules = rules;
    this._lookups = {};
    this.strictImports = strictImports;
    this.copyVisibilityInfo(visibilityInfo);
    this.allowRoot = true;
};
Ruleset.prototype = new Node();
Ruleset.prototype.type = "Ruleset";
Ruleset.prototype.isRuleset = true;
Ruleset.prototype.isRulesetLike = true;
Ruleset.prototype.accept = function (visitor) {
    if (this.paths) {
        this.paths = visitor.visitArray(this.paths, true);
    } else if (this.selectors) {
        this.selectors = visitor.visitArray(this.selectors);
    }
    if (this.rules && this.rules.length) {
        this.rules = visitor.visitArray(this.rules);
    }
};
Ruleset.prototype.eval = function (context) {
    var thisSelectors = this.selectors, selectors,
        selCnt, selector, i, hasOnePassingSelector = false;

    if (thisSelectors && (selCnt = thisSelectors.length)) {
        selectors = [];
        defaultFunc.error({
            type: "Syntax",
            message: "it is currently only allowed in parametric mixin guards,"
        });
        for (i = 0; i < selCnt; i++) {
            selector = thisSelectors[i].eval(context);
            selectors.push(selector);
            if (selector.evaldCondition) {
                hasOnePassingSelector = true;
            }
        }
        defaultFunc.reset();
    } else {
        hasOnePassingSelector = true;
    }

    var rules = this.rules ? this.rules.slice(0) : null,
        ruleset = new Ruleset(selectors, rules, this.strictImports, this.visibilityInfo()),
        rule, subRule;

    ruleset.originalRuleset = this;
    ruleset.root = this.root;
    ruleset.firstRoot = this.firstRoot;
    ruleset.allowImports = this.allowImports;

    if (this.debugInfo) {
        ruleset.debugInfo = this.debugInfo;
    }

    if (!hasOnePassingSelector) {
        rules.length = 0;
    }

    // inherit a function registry from the frames stack when possible;
    // otherwise from the global registry
    ruleset.functionRegistry = (function (frames) {
        var i = 0,
            n = frames.length,
            found;
        for ( ; i !== n ; ++i ) {
            found = frames[ i ].functionRegistry;
            if ( found ) { return found; }
        }
        return globalFunctionRegistry;
    }(context.frames)).inherit();

    // push the current ruleset to the frames stack
    var ctxFrames = context.frames;
    ctxFrames.unshift(ruleset);

    // currrent selectors
    var ctxSelectors = context.selectors;
    if (!ctxSelectors) {
        context.selectors = ctxSelectors = [];
    }
    ctxSelectors.unshift(this.selectors);

    // Evaluate imports
    if (ruleset.root || ruleset.allowImports || !ruleset.strictImports) {
        ruleset.evalImports(context);
    }

    // Store the frames around mixin definitions,
    // so they can be evaluated like closures when the time comes.
    var rsRules = ruleset.rules, rsRuleCnt = rsRules ? rsRules.length : 0;
    for (i = 0; i < rsRuleCnt; i++) {
        if (rsRules[i].evalFirst) {
            rsRules[i] = rsRules[i].eval(context);
        }
    }

    var mediaBlockCount = (context.mediaBlocks && context.mediaBlocks.length) || 0;

    // Evaluate mixin calls.
    for (i = 0; i < rsRuleCnt; i++) {
        if (rsRules[i].type === "MixinCall") {
            /*jshint loopfunc:true */
            rules = rsRules[i].eval(context).filter(function(r) {
                if ((r instanceof Rule) && r.variable) {
                    // do not pollute the scope if the variable is
                    // already there. consider returning false here
                    // but we need a way to "return" variable from mixins
                    return !(ruleset.variable(r.name));
                }
                return true;
            });
            rsRules.splice.apply(rsRules, [i, 1].concat(rules));
            rsRuleCnt += rules.length - 1;
            i += rules.length - 1;
            ruleset.resetCache();
        } else if (rsRules[i].type === "RulesetCall") {
            /*jshint loopfunc:true */
            rules = rsRules[i].eval(context).rules.filter(function(r) {
                if ((r instanceof Rule) && r.variable) {
                    // do not pollute the scope at all
                    return false;
                }
                return true;
            });
            rsRules.splice.apply(rsRules, [i, 1].concat(rules));
            rsRuleCnt += rules.length - 1;
            i += rules.length - 1;
            ruleset.resetCache();
        }
    }

    // Evaluate everything else
    for (i = 0; i < rsRules.length; i++) {
        rule = rsRules[i];
        if (!rule.evalFirst) {
            rsRules[i] = rule = rule.eval ? rule.eval(context) : rule;
        }
    }

    // Evaluate everything else
    for (i = 0; i < rsRules.length; i++) {
        rule = rsRules[i];
        // for rulesets, check if it is a css guard and can be removed
        if (rule instanceof Ruleset && rule.selectors && rule.selectors.length === 1) {
            // check if it can be folded in (e.g. & where)
            if (rule.selectors[0].isJustParentSelector()) {
                rsRules.splice(i--, 1);

                for (var j = 0; j < rule.rules.length; j++) {
                    subRule = rule.rules[j];
                    subRule.copyVisibilityInfo(rule.visibilityInfo());
                    if (!(subRule instanceof Rule) || !subRule.variable) {
                        rsRules.splice(++i, 0, subRule);
                    }
                }
            }
        }
    }

    // Pop the stack
    ctxFrames.shift();
    ctxSelectors.shift();

    if (context.mediaBlocks) {
        for (i = mediaBlockCount; i < context.mediaBlocks.length; i++) {
            context.mediaBlocks[i].bubbleSelectors(selectors);
        }
    }

    return ruleset;
};
Ruleset.prototype.evalImports = function(context) {
    var rules = this.rules, i, importRules;
    if (!rules) { return; }

    for (i = 0; i < rules.length; i++) {
        if (rules[i].type === "Import") {
            importRules = rules[i].eval(context);
            if (importRules && (importRules.length || importRules.length === 0)) {
                rules.splice.apply(rules, [i, 1].concat(importRules));
                i+= importRules.length - 1;
            } else {
                rules.splice(i, 1, importRules);
            }
            this.resetCache();
        }
    }
};
Ruleset.prototype.makeImportant = function() {
    var result = new Ruleset(this.selectors, this.rules.map(function (r) {
        if (r.makeImportant) {
            return r.makeImportant();
        } else {
            return r;
        }
    }), this.strictImports, this.visibilityInfo());

    return result;
};
Ruleset.prototype.matchArgs = function (args) {
    return !args || args.length === 0;
};
// lets you call a css selector with a guard
Ruleset.prototype.matchCondition = function (args, context) {
    var lastSelector = this.selectors[this.selectors.length - 1];
    if (!lastSelector.evaldCondition) {
        return false;
    }
    if (lastSelector.condition &&
        !lastSelector.condition.eval(
            new contexts.Eval(context,
                context.frames))) {
        return false;
    }
    return true;
};
Ruleset.prototype.resetCache = function () {
    this._rulesets = null;
    this._variables = null;
    this._lookups = {};
};
Ruleset.prototype.variables = function () {
    if (!this._variables) {
        this._variables = !this.rules ? {} : this.rules.reduce(function (hash, r) {
            if (r instanceof Rule && r.variable === true) {
                hash[r.name] = r;
            }
            // when evaluating variables in an import statement, imports have not been eval'd
            // so we need to go inside import statements.
            // guard against root being a string (in the case of inlined less)
            if (r.type === "Import" && r.root && r.root.variables) {
                var vars = r.root.variables();
                for (var name in vars) {
                    if (vars.hasOwnProperty(name)) {
                        hash[name] = vars[name];
                    }
                }
            }
            return hash;
        }, {});
    }
    return this._variables;
};
Ruleset.prototype.variable = function (name) {
    return this.variables()[name];
};
Ruleset.prototype.rulesets = function () {
    if (!this.rules) { return []; }

    var filtRules = [], rules = this.rules, cnt = rules.length,
        i, rule;

    for (i = 0; i < cnt; i++) {
        rule = rules[i];
        if (rule.isRuleset) {
            filtRules.push(rule);
        }
    }

    return filtRules;
};
Ruleset.prototype.prependRule = function (rule) {
    var rules = this.rules;
    if (rules) {
        rules.unshift(rule);
    } else {
        this.rules = [ rule ];
    }
};
Ruleset.prototype.find = function (selector, self, filter) {
    self = self || this;
    var rules = [], match, foundMixins,
        key = selector.toCSS();

    if (key in this._lookups) { return this._lookups[key]; }

    this.rulesets().forEach(function (rule) {
        if (rule !== self) {
            for (var j = 0; j < rule.selectors.length; j++) {
                match = selector.match(rule.selectors[j]);
                if (match) {
                    if (selector.elements.length > match) {
                        if (!filter || filter(rule)) {
                            foundMixins = rule.find(new Selector(selector.elements.slice(match)), self, filter);
                            for (var i = 0; i < foundMixins.length; ++i) {
                                foundMixins[i].path.push(rule);
                            }
                            Array.prototype.push.apply(rules, foundMixins);
                        }
                    } else {
                        rules.push({ rule: rule, path: []});
                    }
                    break;
                }
            }
        }
    });
    this._lookups[key] = rules;
    return rules;
};
Ruleset.prototype.genCSS = function (context, output) {
    var i, j,
        charsetRuleNodes = [],
        ruleNodes = [],
        debugInfo,     // Line number debugging
        rule,
        path;

    context.tabLevel = (context.tabLevel || 0);

    if (!this.root) {
        context.tabLevel++;
    }

    var tabRuleStr = context.compress ? '' : Array(context.tabLevel + 1).join("  "),
        tabSetStr = context.compress ? '' : Array(context.tabLevel).join("  "),
        sep;

    function isRulesetLikeNode(rule) {
        // if it has nested rules, then it should be treated like a ruleset
        // medias and comments do not have nested rules, but should be treated like rulesets anyway
        // some directives and anonymous nodes are ruleset like, others are not
        if (typeof rule.isRulesetLike === "boolean") {
            return rule.isRulesetLike;
        } else if (typeof rule.isRulesetLike === "function") {
            return rule.isRulesetLike();
        }

        //anything else is assumed to be a rule
        return false;
    }

    var charsetNodeIndex = 0;
    var importNodeIndex = 0;
    for (i = 0; i < this.rules.length; i++) {
        rule = this.rules[i];
        if (rule.type === "Comment") {
            if (importNodeIndex === i) {
                importNodeIndex++;
            }
            ruleNodes.push(rule);
        } else if (rule.isCharset && rule.isCharset()) {
            ruleNodes.splice(charsetNodeIndex, 0, rule);
            charsetNodeIndex++;
            importNodeIndex++;
        } else if (rule.type === "Import") {
            ruleNodes.splice(importNodeIndex, 0, rule);
            importNodeIndex++;
        } else {
            ruleNodes.push(rule);
        }
    }
    ruleNodes = charsetRuleNodes.concat(ruleNodes);

    // If this is the root node, we don't render
    // a selector, or {}.
    if (!this.root) {
        debugInfo = getDebugInfo(context, this, tabSetStr);

        if (debugInfo) {
            output.add(debugInfo);
            output.add(tabSetStr);
        }

        var paths = this.paths, pathCnt = paths.length,
            pathSubCnt;

        sep = context.compress ? ',' : (',\n' + tabSetStr);

        for (i = 0; i < pathCnt; i++) {
            path = paths[i];
            if (!(pathSubCnt = path.length)) { continue; }
            if (i > 0) { output.add(sep); }

            context.firstSelector = true;
            path[0].genCSS(context, output);

            context.firstSelector = false;
            for (j = 1; j < pathSubCnt; j++) {
                path[j].genCSS(context, output);
            }
        }

        output.add((context.compress ? '{' : ' {\n') + tabRuleStr);
    }

    // Compile rules and rulesets
    for (i = 0; i < ruleNodes.length; i++) {
        rule = ruleNodes[i];

        if (i + 1 === ruleNodes.length) {
            context.lastRule = true;
        }

        var currentLastRule = context.lastRule;
        if (isRulesetLikeNode(rule)) {
            context.lastRule = false;
        }

        if (rule.genCSS) {
            rule.genCSS(context, output);
        } else if (rule.value) {
            output.add(rule.value.toString());
        }

        context.lastRule = currentLastRule;

        if (!context.lastRule) {
            output.add(context.compress ? '' : ('\n' + tabRuleStr));
        } else {
            context.lastRule = false;
        }
    }

    if (!this.root) {
        output.add((context.compress ? '}' : '\n' + tabSetStr + '}'));
        context.tabLevel--;
    }

    if (!output.isEmpty() && !context.compress && this.firstRoot) {
        output.add('\n');
    }
};

Ruleset.prototype.joinSelectors = function (paths, context, selectors) {
    for (var s = 0; s < selectors.length; s++) {
        this.joinSelector(paths, context, selectors[s]);
    }
};

Ruleset.prototype.joinSelector = function (paths, context, selector) {

    function createParenthesis(elementsToPak, originalElement) {
        var replacementParen, j;
        if (elementsToPak.length === 0) {
            replacementParen = new Paren(elementsToPak[0]);
        } else {
            var insideParent = [];
            for (j = 0; j < elementsToPak.length; j++) {
                insideParent.push(new Element(null, elementsToPak[j], originalElement.index, originalElement.currentFileInfo));
            }
            replacementParen = new Paren(new Selector(insideParent));
        }
        return replacementParen;
    }

    function createSelector(containedElement, originalElement) {
        var element, selector;
        element = new Element(null, containedElement, originalElement.index, originalElement.currentFileInfo);
        selector = new Selector([element]);
        return selector;
    }

    // joins selector path from `beginningPath` with selector path in `addPath`
    // `replacedElement` contains element that is being replaced by `addPath`
    // returns concatenated path
    function addReplacementIntoPath(beginningPath, addPath, replacedElement, originalSelector) {
        var newSelectorPath, lastSelector, newJoinedSelector;
        // our new selector path
        newSelectorPath = [];

        //construct the joined selector - if & is the first thing this will be empty,
        // if not newJoinedSelector will be the last set of elements in the selector
        if (beginningPath.length > 0) {
            newSelectorPath = beginningPath.slice(0);
            lastSelector = newSelectorPath.pop();
            newJoinedSelector = originalSelector.createDerived(lastSelector.elements.slice(0));
        }
        else {
            newJoinedSelector = originalSelector.createDerived([]);
        }

        if (addPath.length > 0) {
            // /deep/ is a combinator that is valid without anything in front of it
            // so if the & does not have a combinator that is "" or " " then
            // and there is a combinator on the parent, then grab that.
            // this also allows + a { & .b { .a & { ... though not sure why you would want to do that
            var combinator = replacedElement.combinator, parentEl = addPath[0].elements[0];
            if (combinator.emptyOrWhitespace && !parentEl.combinator.emptyOrWhitespace) {
                combinator = parentEl.combinator;
            }
            // join the elements so far with the first part of the parent
            newJoinedSelector.elements.push(new Element(combinator, parentEl.value, replacedElement.index, replacedElement.currentFileInfo));
            newJoinedSelector.elements = newJoinedSelector.elements.concat(addPath[0].elements.slice(1));
        }

        // now add the joined selector - but only if it is not empty
        if (newJoinedSelector.elements.length !== 0) {
            newSelectorPath.push(newJoinedSelector);
        }

        //put together the parent selectors after the join (e.g. the rest of the parent)
        if (addPath.length > 1) {
            var restOfPath = addPath.slice(1);
            restOfPath = restOfPath.map(function (selector) {
                return selector.createDerived(selector.elements, []);
            });
            newSelectorPath = newSelectorPath.concat(restOfPath);
        }
        return newSelectorPath;
    }

    // joins selector path from `beginningPath` with every selector path in `addPaths` array
    // `replacedElement` contains element that is being replaced by `addPath`
    // returns array with all concatenated paths
    function addAllReplacementsIntoPath( beginningPath, addPaths, replacedElement, originalSelector, result) {
        var j;
        for (j = 0; j < beginningPath.length; j++) {
            var newSelectorPath = addReplacementIntoPath(beginningPath[j], addPaths, replacedElement, originalSelector);
            result.push(newSelectorPath);
        }
        return result;
    }

    function mergeElementsOnToSelectors(elements, selectors) {
        var i, sel;

        if (elements.length === 0) {
            return ;
        }
        if (selectors.length === 0) {
            selectors.push([ new Selector(elements) ]);
            return;
        }

        for (i = 0; i < selectors.length; i++) {
            sel = selectors[i];

            // if the previous thing in sel is a parent this needs to join on to it
            if (sel.length > 0) {
                sel[sel.length - 1] = sel[sel.length - 1].createDerived(sel[sel.length - 1].elements.concat(elements));
            }
            else {
                sel.push(new Selector(elements));
            }
        }
    }

    // replace all parent selectors inside `inSelector` by content of `context` array
    // resulting selectors are returned inside `paths` array
    // returns true if `inSelector` contained at least one parent selector
    function replaceParentSelector(paths, context, inSelector) {
        // The paths are [[Selector]]
        // The first list is a list of comma separated selectors
        // The inner list is a list of inheritance separated selectors
        // e.g.
        // .a, .b {
        //   .c {
        //   }
        // }
        // == [[.a] [.c]] [[.b] [.c]]
        //
        var i, j, k, currentElements, newSelectors, selectorsMultiplied, sel, el, hadParentSelector = false, length, lastSelector;
        function findNestedSelector(element) {
            var maybeSelector;
            if (element.value.type !== 'Paren') {
                return null;
            }

            maybeSelector = element.value.value;
            if (maybeSelector.type !== 'Selector') {
                return null;
            }

            return maybeSelector;
        }

        // the elements from the current selector so far
        currentElements = [];
        // the current list of new selectors to add to the path.
        // We will build it up. We initiate it with one empty selector as we "multiply" the new selectors
        // by the parents
        newSelectors = [
            []
        ];

        for (i = 0; i < inSelector.elements.length; i++) {
            el = inSelector.elements[i];
            // non parent reference elements just get added
            if (el.value !== "&") {
                var nestedSelector = findNestedSelector(el);
                if (nestedSelector != null) {
                    // merge the current list of non parent selector elements
                    // on to the current list of selectors to add
                    mergeElementsOnToSelectors(currentElements, newSelectors);

                    var nestedPaths = [], replaced, replacedNewSelectors = [];
                    replaced = replaceParentSelector(nestedPaths, context, nestedSelector);
                    hadParentSelector = hadParentSelector || replaced;
                    //the nestedPaths array should have only one member - replaceParentSelector does not multiply selectors
                    for (k = 0; k < nestedPaths.length; k++) {
                        var replacementSelector = createSelector(createParenthesis(nestedPaths[k], el), el);
                        addAllReplacementsIntoPath(newSelectors, [replacementSelector], el, inSelector, replacedNewSelectors);
                    }
                    newSelectors = replacedNewSelectors;
                    currentElements = [];

                } else {
                    currentElements.push(el);
                }

            } else {
                hadParentSelector = true;
                // the new list of selectors to add
                selectorsMultiplied = [];

                // merge the current list of non parent selector elements
                // on to the current list of selectors to add
                mergeElementsOnToSelectors(currentElements, newSelectors);

                // loop through our current selectors
                for (j = 0; j < newSelectors.length; j++) {
                    sel = newSelectors[j];
                    // if we don't have any parent paths, the & might be in a mixin so that it can be used
                    // whether there are parents or not
                    if (context.length === 0) {
                        // the combinator used on el should now be applied to the next element instead so that
                        // it is not lost
                        if (sel.length > 0) {
                            sel[0].elements.push(new Element(el.combinator, '', el.index, el.currentFileInfo));
                        }
                        selectorsMultiplied.push(sel);
                    }
                    else {
                        // and the parent selectors
                        for (k = 0; k < context.length; k++) {
                            // We need to put the current selectors
                            // then join the last selector's elements on to the parents selectors
                            var newSelectorPath = addReplacementIntoPath(sel, context[k], el, inSelector);
                            // add that to our new set of selectors
                            selectorsMultiplied.push(newSelectorPath);
                        }
                    }
                }

                // our new selectors has been multiplied, so reset the state
                newSelectors = selectorsMultiplied;
                currentElements = [];
            }
        }

        // if we have any elements left over (e.g. .a& .b == .b)
        // add them on to all the current selectors
        mergeElementsOnToSelectors(currentElements, newSelectors);

        for (i = 0; i < newSelectors.length; i++) {
            length = newSelectors[i].length;
            if (length > 0) {
                paths.push(newSelectors[i]);
                lastSelector = newSelectors[i][length - 1];
                newSelectors[i][length - 1] = lastSelector.createDerived(lastSelector.elements, inSelector.extendList);
                //newSelectors[i][length - 1].copyVisibilityInfo(inSelector.visibilityInfo());
            }
        }

        return hadParentSelector;
    }

    function deriveSelector(visibilityInfo, deriveFrom) {
        var newSelector = deriveFrom.createDerived(deriveFrom.elements, deriveFrom.extendList, deriveFrom.evaldCondition);
        newSelector.copyVisibilityInfo(visibilityInfo);
        return newSelector;
    }

    // joinSelector code follows
    var i, newPaths, hadParentSelector;

    newPaths = [];
    hadParentSelector = replaceParentSelector(newPaths, context, selector);

    if (!hadParentSelector) {
        if (context.length > 0) {
            newPaths = [];
            for (i = 0; i < context.length; i++) {
                //var concatenated = [];
                //context[i].forEach(function(entry) {
                //    var newEntry = entry.createDerived(entry.elements, entry.extendList, entry.evaldCondition);
                //    newEntry.copyVisibilityInfo(selector.visibilityInfo());
                //    concatenated.push(newEntry);
                //}, this);
                var concatenated = context[i].map(deriveSelector.bind(this, selector.visibilityInfo()));

                concatenated.push(selector);
                newPaths.push(concatenated);
            }
        }
        else {
            newPaths = [[selector]];
        }
    }

    for (i = 0; i < newPaths.length; i++) {
        paths.push(newPaths[i]);
    }

};
module.exports = Ruleset;

},{"../contexts":11,"../functions/default":20,"../functions/function-registry":22,"./debug-info":54,"./element":58,"./node":70,"./paren":72,"./rule":74,"./selector":77}],77:[function(require,module,exports){
var Node = require("./node"),
    Element = require("./element");

var Selector = function (elements, extendList, condition, index, currentFileInfo, visibilityInfo) {
    this.elements = elements;
    this.extendList = extendList;
    this.condition = condition;
    this.currentFileInfo = currentFileInfo || {};
    if (!condition) {
        this.evaldCondition = true;
    }
    this.copyVisibilityInfo(visibilityInfo);
};
Selector.prototype = new Node();
Selector.prototype.type = "Selector";
Selector.prototype.accept = function (visitor) {
    if (this.elements) {
        this.elements = visitor.visitArray(this.elements);
    }
    if (this.extendList) {
        this.extendList = visitor.visitArray(this.extendList);
    }
    if (this.condition) {
        this.condition = visitor.visit(this.condition);
    }
};
Selector.prototype.createDerived = function(elements, extendList, evaldCondition) {
    var info = this.visibilityInfo();
    evaldCondition = (evaldCondition != null) ? evaldCondition : this.evaldCondition;
    var newSelector = new Selector(elements, extendList || this.extendList, null, this.index, this.currentFileInfo, info);
    newSelector.evaldCondition = evaldCondition;
    newSelector.mediaEmpty = this.mediaEmpty;
    return newSelector;
};
Selector.prototype.createEmptySelectors = function() {
    var el = new Element('', '&', this.index, this.currentFileInfo),
        sels = [new Selector([el], null, null, this.index, this.currentFileInfo)];
    sels[0].mediaEmpty = true;
    return sels;
};
Selector.prototype.match = function (other) {
    var elements = this.elements,
        len = elements.length,
        olen, i;

    other.CacheElements();

    olen = other._elements.length;
    if (olen === 0 || len < olen) {
        return 0;
    } else {
        for (i = 0; i < olen; i++) {
            if (elements[i].value !== other._elements[i]) {
                return 0;
            }
        }
    }

    return olen; // return number of matched elements
};
Selector.prototype.CacheElements = function() {
    if (this._elements) {
        return;
    }

    var elements = this.elements.map( function(v) {
        return v.combinator.value + (v.value.value || v.value);
    }).join("").match(/[,&#\*\.\w-]([\w-]|(\\.))*/g);

    if (elements) {
        if (elements[0] === "&") {
            elements.shift();
        }
    } else {
        elements = [];
    }

    this._elements = elements;
};
Selector.prototype.isJustParentSelector = function() {
    return !this.mediaEmpty &&
        this.elements.length === 1 &&
        this.elements[0].value === '&' &&
        (this.elements[0].combinator.value === ' ' || this.elements[0].combinator.value === '');
};
Selector.prototype.eval = function (context) {
    var evaldCondition = this.condition && this.condition.eval(context),
        elements = this.elements, extendList = this.extendList;

    elements = elements && elements.map(function (e) { return e.eval(context); });
    extendList = extendList && extendList.map(function(extend) { return extend.eval(context); });

    return this.createDerived(elements, extendList, evaldCondition);
};
Selector.prototype.genCSS = function (context, output) {
    var i, element;
    if ((!context || !context.firstSelector) && this.elements[0].combinator.value === "") {
        output.add(' ', this.currentFileInfo, this.index);
    }
    if (!this._css) {
        //TODO caching? speed comparison?
        for (i = 0; i < this.elements.length; i++) {
            element = this.elements[i];
            element.genCSS(context, output);
        }
    }
};
Selector.prototype.getIsOutput = function() {
    return this.evaldCondition;
};
module.exports = Selector;

},{"./element":58,"./node":70}],78:[function(require,module,exports){
var Node = require("./node");

var UnicodeDescriptor = function (value) {
    this.value = value;
};
UnicodeDescriptor.prototype = new Node();
UnicodeDescriptor.prototype.type = "UnicodeDescriptor";

module.exports = UnicodeDescriptor;

},{"./node":70}],79:[function(require,module,exports){
var Node = require("./node"),
    unitConversions = require("../data/unit-conversions");

var Unit = function (numerator, denominator, backupUnit) {
    this.numerator = numerator ? numerator.slice(0).sort() : [];
    this.denominator = denominator ? denominator.slice(0).sort() : [];
    if (backupUnit) {
        this.backupUnit = backupUnit;
    } else if (numerator && numerator.length) {
        this.backupUnit = numerator[0];
    }
};

Unit.prototype = new Node();
Unit.prototype.type = "Unit";
Unit.prototype.clone = function () {
    return new Unit(this.numerator.slice(0), this.denominator.slice(0), this.backupUnit);
};
Unit.prototype.genCSS = function (context, output) {
    // Dimension checks the unit is singular and throws an error if in strict math mode.
    var strictUnits = context && context.strictUnits;
    if (this.numerator.length === 1) {
        output.add(this.numerator[0]); // the ideal situation
    } else if (!strictUnits && this.backupUnit) {
        output.add(this.backupUnit);
    } else if (!strictUnits && this.denominator.length) {
        output.add(this.denominator[0]);
    }
};
Unit.prototype.toString = function () {
    var i, returnStr = this.numerator.join("*");
    for (i = 0; i < this.denominator.length; i++) {
        returnStr += "/" + this.denominator[i];
    }
    return returnStr;
};
Unit.prototype.compare = function (other) {
    return this.is(other.toString()) ? 0 : undefined;
};
Unit.prototype.is = function (unitString) {
    return this.toString().toUpperCase() === unitString.toUpperCase();
};
Unit.prototype.isLength = function () {
    return Boolean(this.toCSS().match(/px|em|%|in|cm|mm|pc|pt|ex/));
};
Unit.prototype.isEmpty = function () {
    return this.numerator.length === 0 && this.denominator.length === 0;
};
Unit.prototype.isSingular = function() {
    return this.numerator.length <= 1 && this.denominator.length === 0;
};
Unit.prototype.map = function(callback) {
    var i;

    for (i = 0; i < this.numerator.length; i++) {
        this.numerator[i] = callback(this.numerator[i], false);
    }

    for (i = 0; i < this.denominator.length; i++) {
        this.denominator[i] = callback(this.denominator[i], true);
    }
};
Unit.prototype.usedUnits = function() {
    var group, result = {}, mapUnit, groupName;

    mapUnit = function (atomicUnit) {
        /*jshint loopfunc:true */
        if (group.hasOwnProperty(atomicUnit) && !result[groupName]) {
            result[groupName] = atomicUnit;
        }

        return atomicUnit;
    };

    for (groupName in unitConversions) {
        if (unitConversions.hasOwnProperty(groupName)) {
            group = unitConversions[groupName];

            this.map(mapUnit);
        }
    }

    return result;
};
Unit.prototype.cancel = function () {
    var counter = {}, atomicUnit, i;

    for (i = 0; i < this.numerator.length; i++) {
        atomicUnit = this.numerator[i];
        counter[atomicUnit] = (counter[atomicUnit] || 0) + 1;
    }

    for (i = 0; i < this.denominator.length; i++) {
        atomicUnit = this.denominator[i];
        counter[atomicUnit] = (counter[atomicUnit] || 0) - 1;
    }

    this.numerator = [];
    this.denominator = [];

    for (atomicUnit in counter) {
        if (counter.hasOwnProperty(atomicUnit)) {
            var count = counter[atomicUnit];

            if (count > 0) {
                for (i = 0; i < count; i++) {
                    this.numerator.push(atomicUnit);
                }
            } else if (count < 0) {
                for (i = 0; i < -count; i++) {
                    this.denominator.push(atomicUnit);
                }
            }
        }
    }

    this.numerator.sort();
    this.denominator.sort();
};
module.exports = Unit;

},{"../data/unit-conversions":14,"./node":70}],80:[function(require,module,exports){
var Node = require("./node");

var URL = function (val, index, currentFileInfo, isEvald) {
    this.value = val;
    this.currentFileInfo = currentFileInfo;
    this.index = index;
    this.isEvald = isEvald;
};
URL.prototype = new Node();
URL.prototype.type = "Url";
URL.prototype.accept = function (visitor) {
    this.value = visitor.visit(this.value);
};
URL.prototype.genCSS = function (context, output) {
    output.add("url(");
    this.value.genCSS(context, output);
    output.add(")");
};
URL.prototype.eval = function (context) {
    var val = this.value.eval(context),
        rootpath;

    if (!this.isEvald) {
        // Add the base path if the URL is relative
        rootpath = this.currentFileInfo && this.currentFileInfo.rootpath;
        if (rootpath &&
            typeof val.value === "string" &&
            context.isPathRelative(val.value)) {

            if (!val.quote) {
                rootpath = rootpath.replace(/[\(\)'"\s]/g, function(match) { return "\\" + match; });
            }
            val.value = rootpath + val.value;
        }

        val.value = context.normalizePath(val.value);

        // Add url args if enabled
        if (context.urlArgs) {
            if (!val.value.match(/^\s*data:/)) {
                var delimiter = val.value.indexOf('?') === -1 ? '?' : '&';
                var urlArgs = delimiter + context.urlArgs;
                if (val.value.indexOf('#') !== -1) {
                    val.value = val.value.replace('#', urlArgs + '#');
                } else {
                    val.value += urlArgs;
                }
            }
        }
    }

    return new URL(val, this.index, this.currentFileInfo, true);
};
module.exports = URL;

},{"./node":70}],81:[function(require,module,exports){
var Node = require("./node");

var Value = function (value) {
    this.value = value;
    if (!value) {
        throw new Error("Value requires an array argument");
    }
};
Value.prototype = new Node();
Value.prototype.type = "Value";
Value.prototype.accept = function (visitor) {
    if (this.value) {
        this.value = visitor.visitArray(this.value);
    }
};
Value.prototype.eval = function (context) {
    if (this.value.length === 1) {
        return this.value[0].eval(context);
    } else {
        return new Value(this.value.map(function (v) {
            return v.eval(context);
        }));
    }
};
Value.prototype.genCSS = function (context, output) {
    var i;
    for (i = 0; i < this.value.length; i++) {
        this.value[i].genCSS(context, output);
        if (i + 1 < this.value.length) {
            output.add((context && context.compress) ? ',' : ', ');
        }
    }
};
module.exports = Value;

},{"./node":70}],82:[function(require,module,exports){
var Node = require("./node");

var Variable = function (name, index, currentFileInfo) {
    this.name = name;
    this.index = index;
    this.currentFileInfo = currentFileInfo || {};
};
Variable.prototype = new Node();
Variable.prototype.type = "Variable";
Variable.prototype.eval = function (context) {
    var variable, name = this.name;

    if (name.indexOf('@@') === 0) {
        name = '@' + new Variable(name.slice(1), this.index, this.currentFileInfo).eval(context).value;
    }

    if (this.evaluating) {
        throw { type: 'Name',
                message: "Recursive variable definition for " + name,
                filename: this.currentFileInfo.filename,
                index: this.index };
    }

    this.evaluating = true;

    variable = this.find(context.frames, function (frame) {
        var v = frame.variable(name);
        if (v) {
            if (v.important) {
                var importantScope = context.importantScope[context.importantScope.length - 1];
                importantScope.important = v.important;
            }
            return v.value.eval(context);
        }
    });
    if (variable) {
        this.evaluating = false;
        return variable;
    } else {
        throw { type: 'Name',
                message: "variable " + name + " is undefined",
                filename: this.currentFileInfo.filename,
                index: this.index };
    }
};
Variable.prototype.find = function (obj, fun) {
    for (var i = 0, r; i < obj.length; i++) {
        r = fun.call(obj, obj[i]);
        if (r) { return r; }
    }
    return null;
};
module.exports = Variable;

},{"./node":70}],83:[function(require,module,exports){
module.exports = {
    getLocation: function(index, inputStream) {
        var n = index + 1,
            line = null,
            column = -1;

        while (--n >= 0 && inputStream.charAt(n) !== '\n') {
            column++;
        }

        if (typeof index === 'number') {
            line = (inputStream.slice(0, index).match(/\n/g) || "").length;
        }

        return {
            line: line,
            column: column
        };
    }
};

},{}],84:[function(require,module,exports){
var tree = require("../tree"),
    Visitor = require("./visitor"),
    logger = require("../logger");

/*jshint loopfunc:true */

var ExtendFinderVisitor = function() {
    this._visitor = new Visitor(this);
    this.contexts = [];
    this.allExtendsStack = [[]];
};

ExtendFinderVisitor.prototype = {
    run: function (root) {
        root = this._visitor.visit(root);
        root.allExtends = this.allExtendsStack[0];
        return root;
    },
    visitRule: function (ruleNode, visitArgs) {
        visitArgs.visitDeeper = false;
    },
    visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {
        visitArgs.visitDeeper = false;
    },
    visitRuleset: function (rulesetNode, visitArgs) {
        if (rulesetNode.root) {
            return;
        }

        var i, j, extend, allSelectorsExtendList = [], extendList;

        // get &:extend(.a); rules which apply to all selectors in this ruleset
        var rules = rulesetNode.rules, ruleCnt = rules ? rules.length : 0;
        for (i = 0; i < ruleCnt; i++) {
            if (rulesetNode.rules[i] instanceof tree.Extend) {
                allSelectorsExtendList.push(rules[i]);
                rulesetNode.extendOnEveryPath = true;
            }
        }

        // now find every selector and apply the extends that apply to all extends
        // and the ones which apply to an individual extend
        var paths = rulesetNode.paths;
        for (i = 0; i < paths.length; i++) {
            var selectorPath = paths[i],
                selector = selectorPath[selectorPath.length - 1],
                selExtendList = selector.extendList;

            extendList = selExtendList ? selExtendList.slice(0).concat(allSelectorsExtendList)
                                       : allSelectorsExtendList;

            if (extendList) {
                extendList = extendList.map(function(allSelectorsExtend) {
                    return allSelectorsExtend.clone();
                });
            }

            for (j = 0; j < extendList.length; j++) {
                this.foundExtends = true;
                extend = extendList[j];
                extend.findSelfSelectors(selectorPath);
                extend.ruleset = rulesetNode;
                if (j === 0) { extend.firstExtendOnThisSelectorPath = true; }
                this.allExtendsStack[this.allExtendsStack.length - 1].push(extend);
            }
        }

        this.contexts.push(rulesetNode.selectors);
    },
    visitRulesetOut: function (rulesetNode) {
        if (!rulesetNode.root) {
            this.contexts.length = this.contexts.length - 1;
        }
    },
    visitMedia: function (mediaNode, visitArgs) {
        mediaNode.allExtends = [];
        this.allExtendsStack.push(mediaNode.allExtends);
    },
    visitMediaOut: function (mediaNode) {
        this.allExtendsStack.length = this.allExtendsStack.length - 1;
    },
    visitDirective: function (directiveNode, visitArgs) {
        directiveNode.allExtends = [];
        this.allExtendsStack.push(directiveNode.allExtends);
    },
    visitDirectiveOut: function (directiveNode) {
        this.allExtendsStack.length = this.allExtendsStack.length - 1;
    }
};

var ProcessExtendsVisitor = function() {
    this._visitor = new Visitor(this);
};

ProcessExtendsVisitor.prototype = {
    run: function(root) {
        var extendFinder = new ExtendFinderVisitor();
        this.extendIndices = {};
        extendFinder.run(root);
        if (!extendFinder.foundExtends) { return root; }
        root.allExtends = root.allExtends.concat(this.doExtendChaining(root.allExtends, root.allExtends));
        this.allExtendsStack = [root.allExtends];
        var newRoot = this._visitor.visit(root);
        this.checkExtendsForNonMatched(root.allExtends);
        return newRoot;
    },
    checkExtendsForNonMatched: function(extendList) {
        var indices = this.extendIndices;
        extendList.filter(function(extend) {
            return !extend.hasFoundMatches && extend.parent_ids.length == 1;
        }).forEach(function(extend) {
                var selector = "_unknown_";
                try {
                    selector = extend.selector.toCSS({});
                }
                catch(_) {}

                if (!indices[extend.index + ' ' + selector]) {
                    indices[extend.index + ' ' + selector] = true;
                    logger.warn("extend '" + selector + "' has no matches");
                }
            });
    },
    doExtendChaining: function (extendsList, extendsListTarget, iterationCount) {
        //
        // chaining is different from normal extension.. if we extend an extend then we are not just copying, altering
        // and pasting the selector we would do normally, but we are also adding an extend with the same target selector
        // this means this new extend can then go and alter other extends
        //
        // this method deals with all the chaining work - without it, extend is flat and doesn't work on other extend selectors
        // this is also the most expensive.. and a match on one selector can cause an extension of a selector we had already
        // processed if we look at each selector at a time, as is done in visitRuleset

        var extendIndex, targetExtendIndex, matches, extendsToAdd = [], newSelector, extendVisitor = this, selectorPath,
            extend, targetExtend, newExtend;

        iterationCount = iterationCount || 0;

        //loop through comparing every extend with every target extend.
        // a target extend is the one on the ruleset we are looking at copy/edit/pasting in place
        // e.g.  .a:extend(.b) {}  and .b:extend(.c) {} then the first extend extends the second one
        // and the second is the target.
        // the separation into two lists allows us to process a subset of chains with a bigger set, as is the
        // case when processing media queries
        for (extendIndex = 0; extendIndex < extendsList.length; extendIndex++) {
            for (targetExtendIndex = 0; targetExtendIndex < extendsListTarget.length; targetExtendIndex++) {

                extend = extendsList[extendIndex];
                targetExtend = extendsListTarget[targetExtendIndex];

                // look for circular references
                if ( extend.parent_ids.indexOf( targetExtend.object_id ) >= 0 ) { continue; }

                // find a match in the target extends self selector (the bit before :extend)
                selectorPath = [targetExtend.selfSelectors[0]];
                matches = extendVisitor.findMatch(extend, selectorPath);

                if (matches.length) {
                    extend.hasFoundMatches = true;

                    // we found a match, so for each self selector..
                    extend.selfSelectors.forEach(function(selfSelector) {
                        var info = targetExtend.visibilityInfo();

                        // process the extend as usual
                        newSelector = extendVisitor.extendSelector(matches, selectorPath, selfSelector, extend.isVisible());

                        // but now we create a new extend from it
                        newExtend = new(tree.Extend)(targetExtend.selector, targetExtend.option, 0, targetExtend.currentFileInfo, info);
                        newExtend.selfSelectors = newSelector;

                        // add the extend onto the list of extends for that selector
                        newSelector[newSelector.length - 1].extendList = [newExtend];

                        // record that we need to add it.
                        extendsToAdd.push(newExtend);
                        newExtend.ruleset = targetExtend.ruleset;

                        //remember its parents for circular references
                        newExtend.parent_ids = newExtend.parent_ids.concat(targetExtend.parent_ids, extend.parent_ids);

                        // only process the selector once.. if we have :extend(.a,.b) then multiple
                        // extends will look at the same selector path, so when extending
                        // we know that any others will be duplicates in terms of what is added to the css
                        if (targetExtend.firstExtendOnThisSelectorPath) {
                            newExtend.firstExtendOnThisSelectorPath = true;
                            targetExtend.ruleset.paths.push(newSelector);
                        }
                    });
                }
            }
        }

        if (extendsToAdd.length) {
            // try to detect circular references to stop a stack overflow.
            // may no longer be needed.
            this.extendChainCount++;
            if (iterationCount > 100) {
                var selectorOne = "{unable to calculate}";
                var selectorTwo = "{unable to calculate}";
                try {
                    selectorOne = extendsToAdd[0].selfSelectors[0].toCSS();
                    selectorTwo = extendsToAdd[0].selector.toCSS();
                }
                catch(e) {}
                throw { message: "extend circular reference detected. One of the circular extends is currently:" +
                    selectorOne + ":extend(" + selectorTwo + ")"};
            }

            // now process the new extends on the existing rules so that we can handle a extending b extending c extending
            // d extending e...
            return extendsToAdd.concat(extendVisitor.doExtendChaining(extendsToAdd, extendsListTarget, iterationCount + 1));
        } else {
            return extendsToAdd;
        }
    },
    visitRule: function (ruleNode, visitArgs) {
        visitArgs.visitDeeper = false;
    },
    visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {
        visitArgs.visitDeeper = false;
    },
    visitSelector: function (selectorNode, visitArgs) {
        visitArgs.visitDeeper = false;
    },
    visitRuleset: function (rulesetNode, visitArgs) {
        if (rulesetNode.root) {
            return;
        }
        var matches, pathIndex, extendIndex, allExtends = this.allExtendsStack[this.allExtendsStack.length - 1],
            selectorsToAdd = [], extendVisitor = this, selectorPath;

        // look at each selector path in the ruleset, find any extend matches and then copy, find and replace

        for (extendIndex = 0; extendIndex < allExtends.length; extendIndex++) {
            for (pathIndex = 0; pathIndex < rulesetNode.paths.length; pathIndex++) {
                selectorPath = rulesetNode.paths[pathIndex];

                // extending extends happens initially, before the main pass
                if (rulesetNode.extendOnEveryPath) { continue; }
                var extendList = selectorPath[selectorPath.length - 1].extendList;
                if (extendList && extendList.length) { continue; }

                matches = this.findMatch(allExtends[extendIndex], selectorPath);

                if (matches.length) {
                    allExtends[extendIndex].hasFoundMatches = true;

                    allExtends[extendIndex].selfSelectors.forEach(function(selfSelector) {
                        var extendedSelectors;
                        extendedSelectors = extendVisitor.extendSelector(matches, selectorPath, selfSelector, allExtends[extendIndex].isVisible());
                        selectorsToAdd.push(extendedSelectors);
                    });
                }
            }
        }
        rulesetNode.paths = rulesetNode.paths.concat(selectorsToAdd);
    },
    findMatch: function (extend, haystackSelectorPath) {
        //
        // look through the haystack selector path to try and find the needle - extend.selector
        // returns an array of selector matches that can then be replaced
        //
        var haystackSelectorIndex, hackstackSelector, hackstackElementIndex, haystackElement,
            targetCombinator, i,
            extendVisitor = this,
            needleElements = extend.selector.elements,
            potentialMatches = [], potentialMatch, matches = [];

        // loop through the haystack elements
        for (haystackSelectorIndex = 0; haystackSelectorIndex < haystackSelectorPath.length; haystackSelectorIndex++) {
            hackstackSelector = haystackSelectorPath[haystackSelectorIndex];

            for (hackstackElementIndex = 0; hackstackElementIndex < hackstackSelector.elements.length; hackstackElementIndex++) {

                haystackElement = hackstackSelector.elements[hackstackElementIndex];

                // if we allow elements before our match we can add a potential match every time. otherwise only at the first element.
                if (extend.allowBefore || (haystackSelectorIndex === 0 && hackstackElementIndex === 0)) {
                    potentialMatches.push({pathIndex: haystackSelectorIndex, index: hackstackElementIndex, matched: 0,
                        initialCombinator: haystackElement.combinator});
                }

                for (i = 0; i < potentialMatches.length; i++) {
                    potentialMatch = potentialMatches[i];

                    // selectors add " " onto the first element. When we use & it joins the selectors together, but if we don't
                    // then each selector in haystackSelectorPath has a space before it added in the toCSS phase. so we need to
                    // work out what the resulting combinator will be
                    targetCombinator = haystackElement.combinator.value;
                    if (targetCombinator === '' && hackstackElementIndex === 0) {
                        targetCombinator = ' ';
                    }

                    // if we don't match, null our match to indicate failure
                    if (!extendVisitor.isElementValuesEqual(needleElements[potentialMatch.matched].value, haystackElement.value) ||
                        (potentialMatch.matched > 0 && needleElements[potentialMatch.matched].combinator.value !== targetCombinator)) {
                        potentialMatch = null;
                    } else {
                        potentialMatch.matched++;
                    }

                    // if we are still valid and have finished, test whether we have elements after and whether these are allowed
                    if (potentialMatch) {
                        potentialMatch.finished = potentialMatch.matched === needleElements.length;
                        if (potentialMatch.finished &&
                            (!extend.allowAfter &&
                                (hackstackElementIndex + 1 < hackstackSelector.elements.length || haystackSelectorIndex + 1 < haystackSelectorPath.length))) {
                            potentialMatch = null;
                        }
                    }
                    // if null we remove, if not, we are still valid, so either push as a valid match or continue
                    if (potentialMatch) {
                        if (potentialMatch.finished) {
                            potentialMatch.length = needleElements.length;
                            potentialMatch.endPathIndex = haystackSelectorIndex;
                            potentialMatch.endPathElementIndex = hackstackElementIndex + 1; // index after end of match
                            potentialMatches.length = 0; // we don't allow matches to overlap, so start matching again
                            matches.push(potentialMatch);
                        }
                    } else {
                        potentialMatches.splice(i, 1);
                        i--;
                    }
                }
            }
        }
        return matches;
    },
    isElementValuesEqual: function(elementValue1, elementValue2) {
        if (typeof elementValue1 === "string" || typeof elementValue2 === "string") {
            return elementValue1 === elementValue2;
        }
        if (elementValue1 instanceof tree.Attribute) {
            if (elementValue1.op !== elementValue2.op || elementValue1.key !== elementValue2.key) {
                return false;
            }
            if (!elementValue1.value || !elementValue2.value) {
                if (elementValue1.value || elementValue2.value) {
                    return false;
                }
                return true;
            }
            elementValue1 = elementValue1.value.value || elementValue1.value;
            elementValue2 = elementValue2.value.value || elementValue2.value;
            return elementValue1 === elementValue2;
        }
        elementValue1 = elementValue1.value;
        elementValue2 = elementValue2.value;
        if (elementValue1 instanceof tree.Selector) {
            if (!(elementValue2 instanceof tree.Selector) || elementValue1.elements.length !== elementValue2.elements.length) {
                return false;
            }
            for (var i = 0; i  < elementValue1.elements.length; i++) {
                if (elementValue1.elements[i].combinator.value !== elementValue2.elements[i].combinator.value) {
                    if (i !== 0 || (elementValue1.elements[i].combinator.value || ' ') !== (elementValue2.elements[i].combinator.value || ' ')) {
                        return false;
                    }
                }
                if (!this.isElementValuesEqual(elementValue1.elements[i].value, elementValue2.elements[i].value)) {
                    return false;
                }
            }
            return true;
        }
        return false;
    },
    extendSelector:function (matches, selectorPath, replacementSelector, isVisible) {

        //for a set of matches, replace each match with the replacement selector

        var currentSelectorPathIndex = 0,
            currentSelectorPathElementIndex = 0,
            path = [],
            matchIndex,
            selector,
            firstElement,
            match,
            newElements;

        for (matchIndex = 0; matchIndex < matches.length; matchIndex++) {
            match = matches[matchIndex];
            selector = selectorPath[match.pathIndex];
            firstElement = new tree.Element(
                match.initialCombinator,
                replacementSelector.elements[0].value,
                replacementSelector.elements[0].index,
                replacementSelector.elements[0].currentFileInfo
            );

            if (match.pathIndex > currentSelectorPathIndex && currentSelectorPathElementIndex > 0) {
                path[path.length - 1].elements = path[path.length - 1]
                    .elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));
                currentSelectorPathElementIndex = 0;
                currentSelectorPathIndex++;
            }

            newElements = selector.elements
                .slice(currentSelectorPathElementIndex, match.index)
                .concat([firstElement])
                .concat(replacementSelector.elements.slice(1));

            if (currentSelectorPathIndex === match.pathIndex && matchIndex > 0) {
                path[path.length - 1].elements =
                    path[path.length - 1].elements.concat(newElements);
            } else {
                path = path.concat(selectorPath.slice(currentSelectorPathIndex, match.pathIndex));

                path.push(new tree.Selector(
                    newElements
                ));
            }
            currentSelectorPathIndex = match.endPathIndex;
            currentSelectorPathElementIndex = match.endPathElementIndex;
            if (currentSelectorPathElementIndex >= selectorPath[currentSelectorPathIndex].elements.length) {
                currentSelectorPathElementIndex = 0;
                currentSelectorPathIndex++;
            }
        }

        if (currentSelectorPathIndex < selectorPath.length && currentSelectorPathElementIndex > 0) {
            path[path.length - 1].elements = path[path.length - 1]
                .elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));
            currentSelectorPathIndex++;
        }

        path = path.concat(selectorPath.slice(currentSelectorPathIndex, selectorPath.length));
        path = path.map(function (currentValue) {
            // we can re-use elements here, because the visibility property matters only for selectors
            var derived = currentValue.createDerived(currentValue.elements);
            if (isVisible) {
                derived.ensureVisibility();
            } else {
                derived.ensureInvisibility();
            }
            return derived;
        });
        return path;
    },
    visitMedia: function (mediaNode, visitArgs) {
        var newAllExtends = mediaNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);
        newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, mediaNode.allExtends));
        this.allExtendsStack.push(newAllExtends);
    },
    visitMediaOut: function (mediaNode) {
        var lastIndex = this.allExtendsStack.length - 1;
        this.allExtendsStack.length = lastIndex;
    },
    visitDirective: function (directiveNode, visitArgs) {
        var newAllExtends = directiveNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);
        newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, directiveNode.allExtends));
        this.allExtendsStack.push(newAllExtends);
    },
    visitDirectiveOut: function (directiveNode) {
        var lastIndex = this.allExtendsStack.length - 1;
        this.allExtendsStack.length = lastIndex;
    }
};

module.exports = ProcessExtendsVisitor;

},{"../logger":33,"../tree":62,"./visitor":91}],85:[function(require,module,exports){
function ImportSequencer(onSequencerEmpty) {
    this.imports = [];
    this.variableImports = [];
    this._onSequencerEmpty = onSequencerEmpty;
    this._currentDepth = 0;
}

ImportSequencer.prototype.addImport = function(callback) {
    var importSequencer = this,
        importItem = {
            callback: callback,
            args: null,
            isReady: false
        };
    this.imports.push(importItem);
    return function() {
        importItem.args = Array.prototype.slice.call(arguments, 0);
        importItem.isReady = true;
        importSequencer.tryRun();
    };
};

ImportSequencer.prototype.addVariableImport = function(callback) {
    this.variableImports.push(callback);
};

ImportSequencer.prototype.tryRun = function() {
    this._currentDepth++;
    try {
        while (true) {
            while (this.imports.length > 0) {
                var importItem = this.imports[0];
                if (!importItem.isReady) {
                    return;
                }
                this.imports = this.imports.slice(1);
                importItem.callback.apply(null, importItem.args);
            }
            if (this.variableImports.length === 0) {
                break;
            }
            var variableImport = this.variableImports[0];
            this.variableImports = this.variableImports.slice(1);
            variableImport();
        }
    } finally {
        this._currentDepth--;
    }
    if (this._currentDepth === 0 && this._onSequencerEmpty) {
        this._onSequencerEmpty();
    }
};

module.exports = ImportSequencer;

},{}],86:[function(require,module,exports){
var contexts = require("../contexts"),
    Visitor = require("./visitor"),
    ImportSequencer = require("./import-sequencer");

var ImportVisitor = function(importer, finish) {

    this._visitor = new Visitor(this);
    this._importer = importer;
    this._finish = finish;
    this.context = new contexts.Eval();
    this.importCount = 0;
    this.onceFileDetectionMap = {};
    this.recursionDetector = {};
    this._sequencer = new ImportSequencer(this._onSequencerEmpty.bind(this));
};

ImportVisitor.prototype = {
    isReplacing: false,
    run: function (root) {
        try {
            // process the contents
            this._visitor.visit(root);
        }
        catch(e) {
            this.error = e;
        }

        this.isFinished = true;
        this._sequencer.tryRun();
    },
    _onSequencerEmpty: function() {
        if (!this.isFinished) {
            return;
        }
        this._finish(this.error);
    },
    visitImport: function (importNode, visitArgs) {
        var inlineCSS = importNode.options.inline;

        if (!importNode.css || inlineCSS) {

            var context = new contexts.Eval(this.context, this.context.frames.slice(0));
            var importParent = context.frames[0];

            this.importCount++;
            if (importNode.isVariableImport()) {
                this._sequencer.addVariableImport(this.processImportNode.bind(this, importNode, context, importParent));
            } else {
                this.processImportNode(importNode, context, importParent);
            }
        }
        visitArgs.visitDeeper = false;
    },
    processImportNode: function(importNode, context, importParent) {
        var evaldImportNode,
            inlineCSS = importNode.options.inline;

        try {
            evaldImportNode = importNode.evalForImport(context);
        } catch(e) {
            if (!e.filename) { e.index = importNode.index; e.filename = importNode.currentFileInfo.filename; }
            // attempt to eval properly and treat as css
            importNode.css = true;
            // if that fails, this error will be thrown
            importNode.error = e;
        }

        if (evaldImportNode && (!evaldImportNode.css || inlineCSS)) {

            if (evaldImportNode.options.multiple) {
                context.importMultiple = true;
            }

            // try appending if we haven't determined if it is css or not
            var tryAppendLessExtension = evaldImportNode.css === undefined;

            for (var i = 0; i < importParent.rules.length; i++) {
                if (importParent.rules[i] === importNode) {
                    importParent.rules[i] = evaldImportNode;
                    break;
                }
            }

            var onImported = this.onImported.bind(this, evaldImportNode, context),
                sequencedOnImported = this._sequencer.addImport(onImported);

            this._importer.push(evaldImportNode.getPath(), tryAppendLessExtension, evaldImportNode.currentFileInfo,
                evaldImportNode.options, sequencedOnImported);
        } else {
            this.importCount--;
            if (this.isFinished) {
                this._sequencer.tryRun();
            }
        }
    },
    onImported: function (importNode, context, e, root, importedAtRoot, fullPath) {
        if (e) {
            if (!e.filename) {
                e.index = importNode.index; e.filename = importNode.currentFileInfo.filename;
            }
            this.error = e;
        }

        var importVisitor = this,
            inlineCSS = importNode.options.inline,
            isPlugin = importNode.options.plugin,
            isOptional = importNode.options.optional,
            duplicateImport = importedAtRoot || fullPath in importVisitor.recursionDetector;

        if (!context.importMultiple) {
            if (duplicateImport) {
                importNode.skip = true;
            } else {
                importNode.skip = function() {
                    if (fullPath in importVisitor.onceFileDetectionMap) {
                        return true;
                    }
                    importVisitor.onceFileDetectionMap[fullPath] = true;
                    return false;
                };
            }
        }

        if (!fullPath && isOptional) {
            importNode.skip = true;
        }

        if (root) {
            importNode.root = root;
            importNode.importedFilename = fullPath;

            if (!inlineCSS && !isPlugin && (context.importMultiple || !duplicateImport)) {
                importVisitor.recursionDetector[fullPath] = true;

                var oldContext = this.context;
                this.context = context;
                try {
                    this._visitor.visit(root);
                } catch (e) {
                    this.error = e;
                }
                this.context = oldContext;
            }
        }

        importVisitor.importCount--;

        if (importVisitor.isFinished) {
            importVisitor._sequencer.tryRun();
        }
    },
    visitRule: function (ruleNode, visitArgs) {
        if (ruleNode.value.type === "DetachedRuleset") {
            this.context.frames.unshift(ruleNode);
        } else {
            visitArgs.visitDeeper = false;
        }
    },
    visitRuleOut : function(ruleNode) {
        if (ruleNode.value.type === "DetachedRuleset") {
            this.context.frames.shift();
        }
    },
    visitDirective: function (directiveNode, visitArgs) {
        this.context.frames.unshift(directiveNode);
    },
    visitDirectiveOut: function (directiveNode) {
        this.context.frames.shift();
    },
    visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {
        this.context.frames.unshift(mixinDefinitionNode);
    },
    visitMixinDefinitionOut: function (mixinDefinitionNode) {
        this.context.frames.shift();
    },
    visitRuleset: function (rulesetNode, visitArgs) {
        this.context.frames.unshift(rulesetNode);
    },
    visitRulesetOut: function (rulesetNode) {
        this.context.frames.shift();
    },
    visitMedia: function (mediaNode, visitArgs) {
        this.context.frames.unshift(mediaNode.rules[0]);
    },
    visitMediaOut: function (mediaNode) {
        this.context.frames.shift();
    }
};
module.exports = ImportVisitor;

},{"../contexts":11,"./import-sequencer":85,"./visitor":91}],87:[function(require,module,exports){
var visitors = {
    Visitor: require("./visitor"),
    ImportVisitor: require('./import-visitor'),
    MarkVisibleSelectorsVisitor: require("./set-tree-visibility-visitor"),
    ExtendVisitor: require('./extend-visitor'),
    JoinSelectorVisitor: require('./join-selector-visitor'),
    ToCSSVisitor: require('./to-css-visitor')
};

module.exports = visitors;

},{"./extend-visitor":84,"./import-visitor":86,"./join-selector-visitor":88,"./set-tree-visibility-visitor":89,"./to-css-visitor":90,"./visitor":91}],88:[function(require,module,exports){
var Visitor = require("./visitor");

var JoinSelectorVisitor = function() {
    this.contexts = [[]];
    this._visitor = new Visitor(this);
};

JoinSelectorVisitor.prototype = {
    run: function (root) {
        return this._visitor.visit(root);
    },
    visitRule: function (ruleNode, visitArgs) {
        visitArgs.visitDeeper = false;
    },
    visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {
        visitArgs.visitDeeper = false;
    },

    visitRuleset: function (rulesetNode, visitArgs) {
        var context = this.contexts[this.contexts.length - 1],
            paths = [], selectors;

        this.contexts.push(paths);

        if (! rulesetNode.root) {
            selectors = rulesetNode.selectors;
            if (selectors) {
                selectors = selectors.filter(function(selector) { return selector.getIsOutput(); });
                rulesetNode.selectors = selectors.length ? selectors : (selectors = null);
                if (selectors) { rulesetNode.joinSelectors(paths, context, selectors); }
            }
            if (!selectors) { rulesetNode.rules = null; }
            rulesetNode.paths = paths;
        }
    },
    visitRulesetOut: function (rulesetNode) {
        this.contexts.length = this.contexts.length - 1;
    },
    visitMedia: function (mediaNode, visitArgs) {
        var context = this.contexts[this.contexts.length - 1];
        mediaNode.rules[0].root = (context.length === 0 || context[0].multiMedia);
    },
    visitDirective: function (directiveNode, visitArgs) {
        var context = this.contexts[this.contexts.length - 1];
        if (directiveNode.rules && directiveNode.rules.length) {
            directiveNode.rules[0].root = (directiveNode.isRooted || context.length === 0 || null);
        }
    }
};

module.exports = JoinSelectorVisitor;

},{"./visitor":91}],89:[function(require,module,exports){
var SetTreeVisibilityVisitor = function(visible) {
    this.visible = visible;
};
SetTreeVisibilityVisitor.prototype.run = function(root) {
    this.visit(root);
};
SetTreeVisibilityVisitor.prototype.visitArray = function(nodes) {
    if (!nodes) {
        return nodes;
    }

    var cnt = nodes.length, i;
    for (i = 0; i < cnt; i++) {
        this.visit(nodes[i]);
    }
    return nodes;
};
SetTreeVisibilityVisitor.prototype.visit = function(node) {
    if (!node) {
        return node;
    }
    if (node.constructor === Array) {
        return this.visitArray(node);
    }

    if (!node.blocksVisibility || node.blocksVisibility()) {
        return node;
    }
    if (this.visible) {
        node.ensureVisibility();
    } else {
        node.ensureInvisibility();
    }

    node.accept(this);
    return node;
};
module.exports = SetTreeVisibilityVisitor;
},{}],90:[function(require,module,exports){
var tree = require("../tree"),
    Visitor = require("./visitor");

var CSSVisitorUtils = function(context) {
    this._visitor = new Visitor(this);
    this._context = context;
};

CSSVisitorUtils.prototype = {
    containsSilentNonBlockedChild: function(bodyRules) {
        var rule;
        if (bodyRules == null) {
            return false;
        }
        for (var r = 0; r < bodyRules.length; r++) {
            rule = bodyRules[r];
            if (rule.isSilent && rule.isSilent(this._context) && !rule.blocksVisibility()) {
                //the directive contains something that was referenced (likely by extend)
                //therefore it needs to be shown in output too
                return true;
            }
        }
        return false;
    },

    keepOnlyVisibleChilds: function(owner) {
        if (owner == null || owner.rules == null) {
            return ;
        }

        owner.rules = owner.rules.filter(function(thing) {
                return thing.isVisible();
            }
        );
    },

    isEmpty: function(owner) {
        if (owner == null || owner.rules == null) {
            return true;
        }
        return owner.rules.length === 0;
    },

    hasVisibleSelector: function(rulesetNode) {
        if (rulesetNode == null || rulesetNode.paths == null) {
            return false;
        }
        return rulesetNode.paths.length > 0;
    },

    resolveVisibility: function (node, originalRules) {
        if (!node.blocksVisibility()) {
            if (this.isEmpty(node) && !this.containsSilentNonBlockedChild(originalRules)) {
                return ;
            }

            return node;
        }

        var compiledRulesBody = node.rules[0];
        this.keepOnlyVisibleChilds(compiledRulesBody);

        if (this.isEmpty(compiledRulesBody)) {
            return ;
        }

        node.ensureVisibility();
        node.removeVisibilityBlock();

        return node;
    },

    isVisibleRuleset: function(rulesetNode) {
        if (rulesetNode.firstRoot) {
            return true;
        }

        if (this.isEmpty(rulesetNode)) {
            return false;
        }

        if (!rulesetNode.root && !this.hasVisibleSelector(rulesetNode)) {
            return false;
        }

        return true;
    }

};

var ToCSSVisitor = function(context) {
    this._visitor = new Visitor(this);
    this._context = context;
    this.utils = new CSSVisitorUtils(context);
};

ToCSSVisitor.prototype = {
    isReplacing: true,
    run: function (root) {
        return this._visitor.visit(root);
    },

    visitRule: function (ruleNode, visitArgs) {
        if (ruleNode.blocksVisibility() || ruleNode.variable) {
            return;
        }
        return ruleNode;
    },

    visitMixinDefinition: function (mixinNode, visitArgs) {
        // mixin definitions do not get eval'd - this means they keep state
        // so we have to clear that state here so it isn't used if toCSS is called twice
        mixinNode.frames = [];
    },

    visitExtend: function (extendNode, visitArgs) {
    },

    visitComment: function (commentNode, visitArgs) {
        if (commentNode.blocksVisibility() || commentNode.isSilent(this._context)) {
            return;
        }
        return commentNode;
    },

    visitMedia: function(mediaNode, visitArgs) {
        var originalRules = mediaNode.rules[0].rules;
        mediaNode.accept(this._visitor);
        visitArgs.visitDeeper = false;

        return this.utils.resolveVisibility(mediaNode, originalRules);
    },

    visitImport: function (importNode, visitArgs) {
        if (importNode.blocksVisibility()) {
            return ;
        }
        return importNode;
    },

    visitDirective: function(directiveNode, visitArgs) {
        if (directiveNode.rules && directiveNode.rules.length) {
            return this.visitDirectiveWithBody(directiveNode, visitArgs);
        } else {
            return this.visitDirectiveWithoutBody(directiveNode, visitArgs);
        }
    },

    visitDirectiveWithBody: function(directiveNode, visitArgs) {
        //if there is only one nested ruleset and that one has no path, then it is
        //just fake ruleset
        function hasFakeRuleset(directiveNode) {
            var bodyRules = directiveNode.rules;
            return bodyRules.length === 1 && (!bodyRules[0].paths || bodyRules[0].paths.length === 0);
        }
        function getBodyRules(directiveNode) {
            var nodeRules = directiveNode.rules;
            if (hasFakeRuleset(directiveNode)) {
                return nodeRules[0].rules;
            }

            return nodeRules;
        }
        //it is still true that it is only one ruleset in array
        //this is last such moment
        //process childs
        var originalRules = getBodyRules(directiveNode);
        directiveNode.accept(this._visitor);
        visitArgs.visitDeeper = false;

        if (!this.utils.isEmpty(directiveNode)) {
            this._mergeRules(directiveNode.rules[0].rules);
        }

        return this.utils.resolveVisibility(directiveNode, originalRules);
    },

    visitDirectiveWithoutBody: function(directiveNode, visitArgs) {
        if (directiveNode.blocksVisibility()) {
            return;
        }

        if (directiveNode.name === "@charset") {
            // Only output the debug info together with subsequent @charset definitions
            // a comment (or @media statement) before the actual @charset directive would
            // be considered illegal css as it has to be on the first line
            if (this.charset) {
                if (directiveNode.debugInfo) {
                    var comment = new tree.Comment("/* " + directiveNode.toCSS(this._context).replace(/\n/g, "") + " */\n");
                    comment.debugInfo = directiveNode.debugInfo;
                    return this._visitor.visit(comment);
                }
                return;
            }
            this.charset = true;
        }

        return directiveNode;
    },

    checkValidNodes: function(rules, isRoot) {
        if (!rules) {
            return;
        }

        for (var i = 0; i < rules.length; i++) {
            var ruleNode = rules[i];
            if (isRoot && ruleNode instanceof tree.Rule && !ruleNode.variable) {
                throw { message: "Properties must be inside selector blocks. They cannot be in the root",
                    index: ruleNode.index, filename: ruleNode.currentFileInfo && ruleNode.currentFileInfo.filename};
            }
            if (ruleNode instanceof tree.Call) {
                throw { message: "Function '" + ruleNode.name + "' is undefined",
                    index: ruleNode.index, filename: ruleNode.currentFileInfo && ruleNode.currentFileInfo.filename};
            }
            if (ruleNode.type && !ruleNode.allowRoot) {
                throw { message: ruleNode.type + " node returned by a function is not valid here",
                    index: ruleNode.index, filename: ruleNode.currentFileInfo && ruleNode.currentFileInfo.filename};
            }
        }
    },

    visitRuleset: function (rulesetNode, visitArgs) {
        //at this point rulesets are nested into each other
        var rule, rulesets = [];

        this.checkValidNodes(rulesetNode.rules, rulesetNode.firstRoot);

        if (! rulesetNode.root) {
            //remove invisible paths
            this._compileRulesetPaths(rulesetNode);

            // remove rulesets from this ruleset body and compile them separately
            var nodeRules = rulesetNode.rules, nodeRuleCnt = nodeRules ? nodeRules.length : 0;
            for (var i = 0; i < nodeRuleCnt; ) {
                rule = nodeRules[i];
                if (rule && rule.rules) {
                    // visit because we are moving them out from being a child
                    rulesets.push(this._visitor.visit(rule));
                    nodeRules.splice(i, 1);
                    nodeRuleCnt--;
                    continue;
                }
                i++;
            }
            // accept the visitor to remove rules and refactor itself
            // then we can decide nogw whether we want it or not
            // compile body
            if (nodeRuleCnt > 0) {
                rulesetNode.accept(this._visitor);
            } else {
                rulesetNode.rules = null;
            }
            visitArgs.visitDeeper = false;

        } else { //if (! rulesetNode.root) {
            rulesetNode.accept(this._visitor);
            visitArgs.visitDeeper = false;
        }

        if (rulesetNode.rules) {
            this._mergeRules(rulesetNode.rules);
            this._removeDuplicateRules(rulesetNode.rules);
        }

        //now decide whether we keep the ruleset
        if (this.utils.isVisibleRuleset(rulesetNode)) {
            rulesetNode.ensureVisibility();
            rulesets.splice(0, 0, rulesetNode);
        }

        if (rulesets.length === 1) {
            return rulesets[0];
        }
        return rulesets;
    },

    _compileRulesetPaths: function(rulesetNode) {
        if (rulesetNode.paths) {
            rulesetNode.paths = rulesetNode.paths
                .filter(function(p) {
                    var i;
                    if (p[0].elements[0].combinator.value === ' ') {
                        p[0].elements[0].combinator = new(tree.Combinator)('');
                    }
                    for (i = 0; i < p.length; i++) {
                        if (p[i].isVisible() && p[i].getIsOutput()) {
                            return true;
                        }
                    }
                    return false;
                });
        }
    },

    _removeDuplicateRules: function(rules) {
        if (!rules) { return; }

        // remove duplicates
        var ruleCache = {},
            ruleList, rule, i;

        for (i = rules.length - 1; i >= 0 ; i--) {
            rule = rules[i];
            if (rule instanceof tree.Rule) {
                if (!ruleCache[rule.name]) {
                    ruleCache[rule.name] = rule;
                } else {
                    ruleList = ruleCache[rule.name];
                    if (ruleList instanceof tree.Rule) {
                        ruleList = ruleCache[rule.name] = [ruleCache[rule.name].toCSS(this._context)];
                    }
                    var ruleCSS = rule.toCSS(this._context);
                    if (ruleList.indexOf(ruleCSS) !== -1) {
                        rules.splice(i, 1);
                    } else {
                        ruleList.push(ruleCSS);
                    }
                }
            }
        }
    },

    _mergeRules: function (rules) {
        if (!rules) { return; }

        var groups = {},
            parts,
            rule,
            key;

        for (var i = 0; i < rules.length; i++) {
            rule = rules[i];

            if ((rule instanceof tree.Rule) && rule.merge) {
                key = [rule.name,
                    rule.important ? "!" : ""].join(",");

                if (!groups[key]) {
                    groups[key] = [];
                } else {
                    rules.splice(i--, 1);
                }

                groups[key].push(rule);
            }
        }

        Object.keys(groups).map(function (k) {

            function toExpression(values) {
                return new (tree.Expression)(values.map(function (p) {
                    return p.value;
                }));
            }

            function toValue(values) {
                return new (tree.Value)(values.map(function (p) {
                    return p;
                }));
            }

            parts = groups[k];

            if (parts.length > 1) {
                rule = parts[0];
                var spacedGroups = [];
                var lastSpacedGroup = [];
                parts.map(function (p) {
                    if (p.merge === "+") {
                        if (lastSpacedGroup.length > 0) {
                            spacedGroups.push(toExpression(lastSpacedGroup));
                        }
                        lastSpacedGroup = [];
                    }
                    lastSpacedGroup.push(p);
                });
                spacedGroups.push(toExpression(lastSpacedGroup));
                rule.value = toValue(spacedGroups);
            }
        });
    },

    visitAnonymous: function(anonymousNode, visitArgs) {
        if (anonymousNode.blocksVisibility()) {
            return ;
        }
        anonymousNode.accept(this._visitor);
        return anonymousNode;
    }
};

module.exports = ToCSSVisitor;

},{"../tree":62,"./visitor":91}],91:[function(require,module,exports){
var tree = require("../tree");

var _visitArgs = { visitDeeper: true },
    _hasIndexed = false;

function _noop(node) {
    return node;
}

function indexNodeTypes(parent, ticker) {
    // add .typeIndex to tree node types for lookup table
    var key, child;
    for (key in parent) {
        if (parent.hasOwnProperty(key)) {
            child = parent[key];
            switch (typeof child) {
                case "function":
                    // ignore bound functions directly on tree which do not have a prototype
                    // or aren't nodes
                    if (child.prototype && child.prototype.type) {
                        child.prototype.typeIndex = ticker++;
                    }
                    break;
                case "object":
                    ticker = indexNodeTypes(child, ticker);
                    break;
            }
        }
    }
    return ticker;
}

var Visitor = function(implementation) {
    this._implementation = implementation;
    this._visitFnCache = [];

    if (!_hasIndexed) {
        indexNodeTypes(tree, 1);
        _hasIndexed = true;
    }
};

Visitor.prototype = {
    visit: function(node) {
        if (!node) {
            return node;
        }

        var nodeTypeIndex = node.typeIndex;
        if (!nodeTypeIndex) {
            return node;
        }

        var visitFnCache = this._visitFnCache,
            impl = this._implementation,
            aryIndx = nodeTypeIndex << 1,
            outAryIndex = aryIndx | 1,
            func = visitFnCache[aryIndx],
            funcOut = visitFnCache[outAryIndex],
            visitArgs = _visitArgs,
            fnName;

        visitArgs.visitDeeper = true;

        if (!func) {
            fnName = "visit" + node.type;
            func = impl[fnName] || _noop;
            funcOut = impl[fnName + "Out"] || _noop;
            visitFnCache[aryIndx] = func;
            visitFnCache[outAryIndex] = funcOut;
        }

        if (func !== _noop) {
            var newNode = func.call(impl, node, visitArgs);
            if (impl.isReplacing) {
                node = newNode;
            }
        }

        if (visitArgs.visitDeeper && node && node.accept) {
            node.accept(this);
        }

        if (funcOut != _noop) {
            funcOut.call(impl, node);
        }

        return node;
    },
    visitArray: function(nodes, nonReplacing) {
        if (!nodes) {
            return nodes;
        }

        var cnt = nodes.length, i;

        // Non-replacing
        if (nonReplacing || !this._implementation.isReplacing) {
            for (i = 0; i < cnt; i++) {
                this.visit(nodes[i]);
            }
            return nodes;
        }

        // Replacing
        var out = [];
        for (i = 0; i < cnt; i++) {
            var evald = this.visit(nodes[i]);
            if (evald === undefined) { continue; }
            if (!evald.splice) {
                out.push(evald);
            } else if (evald.length) {
                this.flatten(evald, out);
            }
        }
        return out;
    },
    flatten: function(arr, out) {
        if (!out) {
            out = [];
        }

        var cnt, i, item,
            nestedCnt, j, nestedItem;

        for (i = 0, cnt = arr.length; i < cnt; i++) {
            item = arr[i];
            if (item === undefined) {
                continue;
            }
            if (!item.splice) {
                out.push(item);
                continue;
            }

            for (j = 0, nestedCnt = item.length; j < nestedCnt; j++) {
                nestedItem = item[j];
                if (nestedItem === undefined) {
                    continue;
                }
                if (!nestedItem.splice) {
                    out.push(nestedItem);
                } else if (nestedItem.length) {
                    this.flatten(nestedItem, out);
                }
            }
        }

        return out;
    }
};
module.exports = Visitor;

},{"../tree":62}],92:[function(require,module,exports){
"use strict";

// rawAsap provides everything we need except exception management.
var rawAsap = require("./raw");
// RawTasks are recycled to reduce GC churn.
var freeTasks = [];
// We queue errors to ensure they are thrown in right order (FIFO).
// Array-as-queue is good enough here, since we are just dealing with exceptions.
var pendingErrors = [];
var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

function throwFirstError() {
    if (pendingErrors.length) {
        throw pendingErrors.shift();
    }
}

/**
 * Calls a task as soon as possible after returning, in its own event, with priority
 * over other events like animation, reflow, and repaint. An error thrown from an
 * event will not interrupt, nor even substantially slow down the processing of
 * other events, but will be rather postponed to a lower priority event.
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */
module.exports = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) {
        rawTask = freeTasks.pop();
    } else {
        rawTask = new RawTask();
    }
    rawTask.task = task;
    rawAsap(rawTask);
}

// We wrap tasks with recyclable task objects.  A task object implements
// `call`, just like a function.
function RawTask() {
    this.task = null;
}

// The sole purpose of wrapping the task is to catch the exception and recycle
// the task object after its single use.
RawTask.prototype.call = function () {
    try {
        this.task.call();
    } catch (error) {
        if (asap.onerror) {
            // This hook exists purely for testing purposes.
            // Its name will be periodically randomized to break any code that
            // depends on its existence.
            asap.onerror(error);
        } else {
            // In a web browser, exceptions are not fatal. However, to avoid
            // slowing down the queue of pending tasks, we rethrow the error in a
            // lower priority turn.
            pendingErrors.push(error);
            requestErrorThrow();
        }
    } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
    }
};

},{"./raw":93}],93:[function(require,module,exports){
(function (global){
"use strict";

// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including IO, animation, reflow, and redraw
// events in browsers.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Equivalent to push, but avoids a function call.
    queue[queue.length] = task;
}

var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// `requestFlush` is an implementation-specific method that attempts to kick
// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
// the event queue before yielding to the browser's own event loop.
var requestFlush;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory exhaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while (index < queue.length) {
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}

// `requestFlush` is implemented using a strategy based on data collected from
// every available SauceLabs Selenium web driver worker at time of writing.
// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
// have WebKitMutationObserver but not un-prefixed MutationObserver.
// Must use `global` instead of `window` to work in both frames and web
// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
var BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;

// MutationObservers are desirable because they have high priority and work
// reliably everywhere they are implemented.
// They are implemented in all modern browsers.
//
// - Android 4-4.3
// - Chrome 26-34
// - Firefox 14-29
// - Internet Explorer 11
// - iPad Safari 6-7.1
// - iPhone Safari 7-7.1
// - Safari 6-7
if (typeof BrowserMutationObserver === "function") {
    requestFlush = makeRequestCallFromMutationObserver(flush);

// MessageChannels are desirable because they give direct access to the HTML
// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
// 11-12, and in web workers in many engines.
// Although message channels yield to any queued rendering and IO tasks, they
// would be better than imposing the 4ms delay of timers.
// However, they do not work reliably in Internet Explorer or Safari.

// Internet Explorer 10 is the only browser that has setImmediate but does
// not have MutationObservers.
// Although setImmediate yields to the browser's renderer, it would be
// preferrable to falling back to setTimeout since it does not have
// the minimum 4ms penalty.
// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
// Desktop to a lesser extent) that renders both setImmediate and
// MessageChannel useless for the purposes of ASAP.
// https://github.com/kriskowal/q/issues/396

// Timers are implemented universally.
// We fall back to timers in workers in most engines, and in foreground
// contexts in the following browsers.
// However, note that even this simple case requires nuances to operate in a
// broad spectrum of browsers.
//
// - Firefox 3-13
// - Internet Explorer 6-9
// - iPad Safari 4.3
// - Lynx 2.8.7
} else {
    requestFlush = makeRequestCallFromTimer(flush);
}

// `requestFlush` requests that the high priority event queue be flushed as
// soon as possible.
// This is useful to prevent an error thrown in a task from stalling the event
// queue if the exception handled by Node.jss
// `process.on("uncaughtException")` or by a domain.
rawAsap.requestFlush = requestFlush;

// To request a high priority event, we induce a mutation observer by toggling
// the text of a text node between "1" and "-1".
function makeRequestCallFromMutationObserver(callback) {
    var toggle = 1;
    var observer = new BrowserMutationObserver(callback);
    var node = document.createTextNode("");
    observer.observe(node, {characterData: true});
    return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
    };
}

// The message channel technique was discovered by Malte Ubl and was the
// original foundation for this library.
// http://www.nonblocking.io/2011/06/windownexttick.html

// Safari 6.0.5 (at least) intermittently fails to create message ports on a
// page's first load. Thankfully, this version of Safari supports
// MutationObservers, so we don't need to fall back in that case.

// function makeRequestCallFromMessageChannel(callback) {
//     var channel = new MessageChannel();
//     channel.port1.onmessage = callback;
//     return function requestCall() {
//         channel.port2.postMessage(0);
//     };
// }

// For reasons explained above, we are also unable to use `setImmediate`
// under any circumstances.
// Even if we were, there is another bug in Internet Explorer 10.
// It is not sufficient to assign `setImmediate` to `requestFlush` because
// `setImmediate` must be called *by name* and therefore must be wrapped in a
// closure.
// Never forget.

// function makeRequestCallFromSetImmediate(callback) {
//     return function requestCall() {
//         setImmediate(callback);
//     };
// }

// Safari 6.0 has a problem where timers will get lost while the user is
// scrolling. This problem does not impact ASAP because Safari 6.0 supports
// mutation observers, so that implementation is used instead.
// However, if we ever elect to use timers in Safari, the prevalent work-around
// is to add a scroll event listener that calls for a flush.

// `setTimeout` does not call the passed callback if the delay is less than
// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
// even then.

function makeRequestCallFromTimer(callback) {
    return function requestCall() {
        // We dispatch a timeout with a specified delay of 0 for engines that
        // can reliably accommodate that request. This will usually be snapped
        // to a 4 milisecond delay, but once we're flushing, there's no delay
        // between events.
        var timeoutHandle = setTimeout(handleTimer, 0);
        // However, since this timer gets frequently dropped in Firefox
        // workers, we enlist an interval handle that will try to fire
        // an event 20 times per second until it succeeds.
        var intervalHandle = setInterval(handleTimer, 50);

        function handleTimer() {
            // Whichever timer succeeds will cancel both timers and
            // execute the callback.
            clearTimeout(timeoutHandle);
            clearInterval(intervalHandle);
            callback();
        }
    };
}

// This is for `asap.js` only.
// Its name will be periodically randomized to break any code that depends on
// its existence.
rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

// ASAP was originally a nextTick shim included in Q. This was factored out
// into this ASAP package. It was later adapted to RSVP which made further
// amendments. These decisions, particularly to marginalize MessageChannel and
// to capture the MutationObserver implementation in a closure, were integrated
// back into ASAP proper.
// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],94:[function(require,module,exports){
'use strict';

var asap = require('asap/raw');

function noop() {}

// States:
//
// 0 - pending
// 1 - fulfilled with _value
// 2 - rejected with _value
// 3 - adopted the state of another promise, _value
//
// once the state is no longer pending (0) it is immutable

// All `_` prefixed properties will be reduced to `_{random number}`
// at build time to obfuscate them and discourage their use.
// We don't use symbols or Object.defineProperty to fully hide them
// because the performance isn't good enough.


// to avoid using try/catch inside critical functions, we
// extract them to here.
var LAST_ERROR = null;
var IS_ERROR = {};
function getThen(obj) {
  try {
    return obj.then;
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

function tryCallOne(fn, a) {
  try {
    return fn(a);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}
function tryCallTwo(fn, a, b) {
  try {
    fn(a, b);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

module.exports = Promise;

function Promise(fn) {
  if (typeof this !== 'object') {
    throw new TypeError('Promises must be constructed via new');
  }
  if (typeof fn !== 'function') {
    throw new TypeError('not a function');
  }
  this._45 = 0;
  this._81 = 0;
  this._65 = null;
  this._54 = null;
  if (fn === noop) return;
  doResolve(fn, this);
}
Promise._10 = null;
Promise._97 = null;
Promise._61 = noop;

Promise.prototype.then = function(onFulfilled, onRejected) {
  if (this.constructor !== Promise) {
    return safeThen(this, onFulfilled, onRejected);
  }
  var res = new Promise(noop);
  handle(this, new Handler(onFulfilled, onRejected, res));
  return res;
};

function safeThen(self, onFulfilled, onRejected) {
  return new self.constructor(function (resolve, reject) {
    var res = new Promise(noop);
    res.then(resolve, reject);
    handle(self, new Handler(onFulfilled, onRejected, res));
  });
};
function handle(self, deferred) {
  while (self._81 === 3) {
    self = self._65;
  }
  if (Promise._10) {
    Promise._10(self);
  }
  if (self._81 === 0) {
    if (self._45 === 0) {
      self._45 = 1;
      self._54 = deferred;
      return;
    }
    if (self._45 === 1) {
      self._45 = 2;
      self._54 = [self._54, deferred];
      return;
    }
    self._54.push(deferred);
    return;
  }
  handleResolved(self, deferred);
}

function handleResolved(self, deferred) {
  asap(function() {
    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      if (self._81 === 1) {
        resolve(deferred.promise, self._65);
      } else {
        reject(deferred.promise, self._65);
      }
      return;
    }
    var ret = tryCallOne(cb, self._65);
    if (ret === IS_ERROR) {
      reject(deferred.promise, LAST_ERROR);
    } else {
      resolve(deferred.promise, ret);
    }
  });
}
function resolve(self, newValue) {
  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
  if (newValue === self) {
    return reject(
      self,
      new TypeError('A promise cannot be resolved with itself.')
    );
  }
  if (
    newValue &&
    (typeof newValue === 'object' || typeof newValue === 'function')
  ) {
    var then = getThen(newValue);
    if (then === IS_ERROR) {
      return reject(self, LAST_ERROR);
    }
    if (
      then === self.then &&
      newValue instanceof Promise
    ) {
      self._81 = 3;
      self._65 = newValue;
      finale(self);
      return;
    } else if (typeof then === 'function') {
      doResolve(then.bind(newValue), self);
      return;
    }
  }
  self._81 = 1;
  self._65 = newValue;
  finale(self);
}

function reject(self, newValue) {
  self._81 = 2;
  self._65 = newValue;
  if (Promise._97) {
    Promise._97(self, newValue);
  }
  finale(self);
}
function finale(self) {
  if (self._45 === 1) {
    handle(self, self._54);
    self._54 = null;
  }
  if (self._45 === 2) {
    for (var i = 0; i < self._54.length; i++) {
      handle(self, self._54[i]);
    }
    self._54 = null;
  }
}

function Handler(onFulfilled, onRejected, promise){
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, promise) {
  var done = false;
  var res = tryCallTwo(fn, function (value) {
    if (done) return;
    done = true;
    resolve(promise, value);
  }, function (reason) {
    if (done) return;
    done = true;
    reject(promise, reason);
  })
  if (!done && res === IS_ERROR) {
    done = true;
    reject(promise, LAST_ERROR);
  }
}

},{"asap/raw":93}],95:[function(require,module,exports){
'use strict';

//This file contains the ES6 extensions to the core Promises/A+ API

var Promise = require('./core.js');

module.exports = Promise;

/* Static Functions */

var TRUE = valuePromise(true);
var FALSE = valuePromise(false);
var NULL = valuePromise(null);
var UNDEFINED = valuePromise(undefined);
var ZERO = valuePromise(0);
var EMPTYSTRING = valuePromise('');

function valuePromise(value) {
  var p = new Promise(Promise._61);
  p._81 = 1;
  p._65 = value;
  return p;
}
Promise.resolve = function (value) {
  if (value instanceof Promise) return value;

  if (value === null) return NULL;
  if (value === undefined) return UNDEFINED;
  if (value === true) return TRUE;
  if (value === false) return FALSE;
  if (value === 0) return ZERO;
  if (value === '') return EMPTYSTRING;

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then;
      if (typeof then === 'function') {
        return new Promise(then.bind(value));
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        reject(ex);
      });
    }
  }
  return valuePromise(value);
};

Promise.all = function (arr) {
  var args = Array.prototype.slice.call(arr);

  return new Promise(function (resolve, reject) {
    if (args.length === 0) return resolve([]);
    var remaining = args.length;
    function res(i, val) {
      if (val && (typeof val === 'object' || typeof val === 'function')) {
        if (val instanceof Promise && val.then === Promise.prototype.then) {
          while (val._81 === 3) {
            val = val._65;
          }
          if (val._81 === 1) return res(i, val._65);
          if (val._81 === 2) reject(val._65);
          val.then(function (val) {
            res(i, val);
          }, reject);
          return;
        } else {
          var then = val.then;
          if (typeof then === 'function') {
            var p = new Promise(then.bind(val));
            p.then(function (val) {
              res(i, val);
            }, reject);
            return;
          }
        }
      }
      args[i] = val;
      if (--remaining === 0) {
        resolve(args);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) {
    reject(value);
  });
};

Promise.race = function (values) {
  return new Promise(function (resolve, reject) {
    values.forEach(function(value){
      Promise.resolve(value).then(resolve, reject);
    });
  });
};

/* Prototype Methods */

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
};

},{"./core.js":94}],96:[function(require,module,exports){
// should work in any browser without browserify

if (typeof Promise.prototype.done !== 'function') {
  Promise.prototype.done = function (onFulfilled, onRejected) {
    var self = arguments.length ? this.then.apply(this, arguments) : this
    self.then(null, function (err) {
      setTimeout(function () {
        throw err
      }, 0)
    })
  }
}
},{}],97:[function(require,module,exports){
// not "use strict" so we can declare global "Promise"

var asap = require('asap');

if (typeof Promise === 'undefined') {
  Promise = require('./lib/core.js')
  require('./lib/es6-extensions.js')
}

require('./polyfill-done.js');

},{"./lib/core.js":94,"./lib/es6-extensions.js":95,"./polyfill-done.js":96,"asap":92}]},{},[2])(2)
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(92)))

/***/ }),
/* 576 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(577);


/***/ }),
/* 577 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__resourceQuery) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getPrototypeOf = __webpack_require__(60);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(33);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(34);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(61);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(63);

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__(27);

var _react2 = _interopRequireDefault(_react);

var _store = __webpack_require__(568);

var _store2 = _interopRequireDefault(_store);

var _actions = __webpack_require__(569);

var _Result = __webpack_require__(594);

var _Result2 = _interopRequireDefault(_Result);

var _Css = __webpack_require__(595);

var _Css2 = _interopRequireDefault(_Css);

var _JS = __webpack_require__(596);

var _JS2 = _interopRequireDefault(_JS);

var _Html = __webpack_require__(597);

var _Html2 = _interopRequireDefault(_Html);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _jsxFileName = 'E:\\Projects and Ideas\\Startversity\\networq\\pages\\index.js?entry';


var Index = function (_React$Component) {
    (0, _inherits3.default)(Index, _React$Component);

    function Index() {
        (0, _classCallCheck3.default)(this, Index);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Index.__proto__ || (0, _getPrototypeOf2.default)(Index)).call(this));

        _this.state = {
            type: 'result'
        };
        return _this;
    }

    (0, _createClass3.default)(Index, [{
        key: '_changeTitle',
        value: function _changeTitle(type) {
            this.setState({ type: type });
        }
    }, {
        key: '_getInitialContentFromServer',
        value: function _getInitialContentFromServer() {
            // gets initial contents from the database and then dispatches it to the store
            var initialContent = {
                html: "<p>yo</p>",
                css: 'p{\n  color:red;\n }',
                js: 'console.log("Hello Gentleman");'
            };
            _store2.default.dispatch((0, _actions.HTML_SUBMIT)(initialContent.html));
            _store2.default.dispatch((0, _actions.CSS_SUBMIT)(initialContent.css));
            _store2.default.dispatch((0, _actions.JS_SUBMIT)(initialContent.js));
            // mock initial content

            initialContent;
        }
    }, {
        key: 'componentWillMount',
        value: function componentWillMount() {
            this._getInitialContentFromServer();
        }
    }, {
        key: '_renderElement',
        value: function _renderElement() {

            switch (this.state.type) {
                case 'result':
                    return _react2.default.createElement(_Result2.default, {
                        __source: {
                            fileName: _jsxFileName,
                            lineNumber: 44
                        }
                    });
                case 'html':
                    return _react2.default.createElement(_Html2.default, {
                        __source: {
                            fileName: _jsxFileName,
                            lineNumber: 46
                        }
                    });
                case 'css':
                    return _react2.default.createElement(_Css2.default, {
                        __source: {
                            fileName: _jsxFileName,
                            lineNumber: 48
                        }
                    });
                default:
                    return _react2.default.createElement(_JS2.default, {
                        __source: {
                            fileName: _jsxFileName,
                            lineNumber: 50
                        }
                    });

            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            return _react2.default.createElement('div', {
                __source: {
                    fileName: _jsxFileName,
                    lineNumber: 57
                }
            }, _react2.default.createElement('button', { onClick: function onClick() {
                    return _this2._changeTitle('result');
                }, __source: {
                    fileName: _jsxFileName,
                    lineNumber: 58
                }
            }, 'Result'), _react2.default.createElement('button', { onClick: function onClick() {
                    return _this2._changeTitle('html');
                }, __source: {
                    fileName: _jsxFileName,
                    lineNumber: 59
                }
            }, 'HTML'), _react2.default.createElement('button', { onClick: function onClick() {
                    return _this2._changeTitle('css');
                }, __source: {
                    fileName: _jsxFileName,
                    lineNumber: 60
                }
            }, 'CSS'), _react2.default.createElement('button', { onClick: function onClick() {
                    return _this2._changeTitle('js');
                }, __source: {
                    fileName: _jsxFileName,
                    lineNumber: 61
                }
            }, 'JavaScript'), this._renderElement(), _react2.default.createElement('button', { onClick: function onClick() {
                    return _store2.default.dispatch((0, _actions.SAVE_TO_DATABASE)());
                }, __source: {
                    fileName: _jsxFileName,
                    lineNumber: 63
                }
            }, 'Publish your Snippet!'));
        }
    }]);

    return Index;
}(_react2.default.Component);

exports.default = Index;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzXFxpbmRleC5qcyJdLCJuYW1lcyI6WyJzdG9yZSIsIlNBVkVfVE9fREFUQUJBU0UiLCJIVE1MX1NVQk1JVCIsIkNTU19TVUJNSVQiLCJKU19TVUJNSVQiLCJSZXN1bHQiLCJDc3MiLCJKcyIsIkh0bWwiLCJJbmRleCIsInN0YXRlIiwidHlwZSIsInNldFN0YXRlIiwiaW5pdGlhbENvbnRlbnQiLCJodG1sIiwiY3NzIiwianMiLCJkaXNwYXRjaCIsIl9nZXRJbml0aWFsQ29udGVudEZyb21TZXJ2ZXIiLCJfY2hhbmdlVGl0bGUiLCJfcmVuZGVyRWxlbWVudCIsIlJlYWN0IiwiQ29tcG9uZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxBQUFPOzs7O0FBQ1AsQUFBUSxBQUFrQixBQUFhLEFBQVk7O0FBRW5ELEFBQU87Ozs7QUFDUCxBQUFPOzs7O0FBQ1AsQUFBTzs7OztBQUNQLEFBQU87Ozs7Ozs7OztJQUVELEE7bUNBQ0Y7O3FCQUFjOzRDQUFBOztrSUFFVjs7Y0FBQSxBQUFLO2tCQUZLLEFBRVYsQUFBYSxBQUNIO0FBREcsQUFDVDtlQUVQOzs7OztxQyxBQUVZLE1BQU0sQUFDZjtpQkFBQSxBQUFLLFNBQVMsRUFBQyxNQUFmLEFBQWMsQUFDakI7Ozs7dURBRThCLEFBQzNCO0FBQ0E7Z0JBQUk7c0JBQWlCLEFBQ1gsQUFDTjtxQkFGaUIsQUFHakI7b0JBSEosQUFBcUIsQUFLckI7QUFMcUIsQUFDakI7NEJBSUosQUFBTSxTQUFTLDBCQUFZLGVBQTNCLEFBQWUsQUFBMkIsQUFDMUM7NEJBQUEsQUFBTSxTQUFTLHlCQUFXLGVBQTFCLEFBQWUsQUFBMEIsQUFDekM7NEJBQUEsQUFBTSxTQUFTLHdCQUFVLGVBQXpCLEFBQWUsQUFBeUIsQUFDeEM7QUFFQTs7QUFDSDs7Ozs2Q0FFb0IsQUFDakI7aUJBQUEsQUFBSyxBQUNSOzs7O3lDQUVnQixBQUViOztvQkFBUSxLQUFBLEFBQUssTUFBYixBQUFtQixBQUNmO3FCQUFBLEFBQUssQUFDRDsyQ0FBUSxBQUFDOztzQ0FBRDt3Q0FBUixBQUFRLEFBQ1o7QUFEWTtBQUFBLHFCQUFBO3FCQUNaLEFBQUssQUFDRDsyQ0FBUSxBQUFDOztzQ0FBRDt3Q0FBUixBQUFRLEFBQ1o7QUFEWTtBQUFBLHFCQUFBO3FCQUNaLEFBQUssQUFDRDsyQ0FBUSxBQUFDOztzQ0FBRDt3Q0FBUixBQUFRLEFBQ1o7QUFEWTtBQUFBLHFCQUFBO0FBRVI7MkNBQVEsQUFBQzs7c0NBQUQ7d0NBUmhCLEFBUVEsQUFBUSxBQUduQjtBQUhtQjtBQUFBLHFCQUFBOzs7Ozs7aUNBS1g7eUJBQ0w7O21DQUNJLGNBQUE7OzhCQUFBO2dDQUFBLEFBQ0k7QUFESjtBQUFBLGFBQUEsa0JBQ0ksY0FBQSxZQUFRLFNBQVMsbUJBQUE7MkJBQU0sT0FBQSxBQUFLLGFBQVgsQUFBTSxBQUFrQjtBQUF6Qzs4QkFBQTtnQ0FBQTtBQUFBO2VBREosQUFDSSxBQUNBLDJCQUFBLGNBQUEsWUFBUSxTQUFTLG1CQUFBOzJCQUFNLE9BQUEsQUFBSyxhQUFYLEFBQU0sQUFBa0I7QUFBekM7OEJBQUE7Z0NBQUE7QUFBQTtlQUZKLEFBRUksQUFDQSx5QkFBQSxjQUFBLFlBQVEsU0FBUyxtQkFBQTsyQkFBTSxPQUFBLEFBQUssYUFBWCxBQUFNLEFBQWtCO0FBQXpDOzhCQUFBO2dDQUFBO0FBQUE7ZUFISixBQUdJLEFBQ0Esd0JBQUEsY0FBQSxZQUFRLFNBQVMsbUJBQUE7MkJBQU0sT0FBQSxBQUFLLGFBQVgsQUFBTSxBQUFrQjtBQUF6Qzs4QkFBQTtnQ0FBQTtBQUFBO2VBSkosQUFJSSxBQUNDLG9CQUxMLEFBS0ssQUFBSyxBQUNOLGtDQUFBLGNBQUEsWUFBUSxTQUFXLG1CQUFBOzJCQUFNLGdCQUFBLEFBQU0sU0FBWixBQUFNLEFBQWU7QUFBeEM7OEJBQUE7Z0NBQUE7QUFBQTtlQVBSLEFBQ0ksQUFNSSxBQUtYOzs7OztFQTNEZSxnQkFBTSxBLEFBK0QxQjs7a0JBQUEsQUFBZSIsImZpbGUiOiJpbmRleC5qcz9lbnRyeSIsInNvdXJjZVJvb3QiOiJFOi9Qcm9qZWN0cyBhbmQgSWRlYXMvU3RhcnR2ZXJzaXR5L25ldHdvcnEifQ==

 ;(function register() { /* react-hot-loader/webpack */ if (true) { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } if (typeof module.exports === 'function') { __REACT_HOT_LOADER__.register(module.exports, 'module.exports', "E:\\Projects and Ideas\\Startversity\\networq\\pages\\index.js"); return; } for (var key in module.exports) { if (!Object.prototype.hasOwnProperty.call(module.exports, key)) { continue; } var namedExport = void 0; try { namedExport = module.exports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, "E:\\Projects and Ideas\\Startversity\\networq\\pages\\index.js"); } } })();
    (function (Component, route) {
      if (false) return
      if (false) return

      var qs = __webpack_require__(108)
      var params = qs.parse(__resourceQuery.slice(1))
      if (params.entry == null) return

      module.hot.accept()
      Component.__route = route

      if (module.hot.status() === 'idle') return

      var components = next.router.components
      for (var r in components) {
        if (!components.hasOwnProperty(r)) continue

        if (components[r].Component.__route === route) {
          next.router.update(r, Component)
        }
      }
    })(typeof __webpack_exports__ !== 'undefined' ? __webpack_exports__.default : (module.exports.default || module.exports), "/")
  
/* WEBPACK VAR INJECTION */}.call(exports, "?entry"))

/***/ }),
/* 578 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__createStore__ = __webpack_require__(570);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__combineReducers__ = __webpack_require__(590);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__bindActionCreators__ = __webpack_require__(591);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__applyMiddleware__ = __webpack_require__(592);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__compose__ = __webpack_require__(574);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_warning__ = __webpack_require__(573);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "createStore", function() { return __WEBPACK_IMPORTED_MODULE_0__createStore__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "combineReducers", function() { return __WEBPACK_IMPORTED_MODULE_1__combineReducers__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "bindActionCreators", function() { return __WEBPACK_IMPORTED_MODULE_2__bindActionCreators__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "applyMiddleware", function() { return __WEBPACK_IMPORTED_MODULE_3__applyMiddleware__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return __WEBPACK_IMPORTED_MODULE_4__compose__["a"]; });







/*
* This is a dummy function to check if the function name has been altered by minification.
* If the function has been minified and NODE_ENV !== 'production', warn the user.
*/
function isCrushed() {}

if ("development" !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  Object(__WEBPACK_IMPORTED_MODULE_5__utils_warning__["a" /* default */])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
}



/***/ }),
/* 579 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(572);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getRawTag_js__ = __webpack_require__(582);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__objectToString_js__ = __webpack_require__(583);




/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */].toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? Object(__WEBPACK_IMPORTED_MODULE_1__getRawTag_js__["a" /* default */])(value)
    : Object(__WEBPACK_IMPORTED_MODULE_2__objectToString_js__["a" /* default */])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (baseGetTag);


/***/ }),
/* 580 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__ = __webpack_require__(581);


/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__["a" /* default */] || freeSelf || Function('return this')();

/* harmony default export */ __webpack_exports__["a"] = (root);


/***/ }),
/* 581 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/* harmony default export */ __webpack_exports__["a"] = (freeGlobal);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(92)))

/***/ }),
/* 582 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(572);


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */].toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (getRawTag);


/***/ }),
/* 583 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/* harmony default export */ __webpack_exports__["a"] = (objectToString);


/***/ }),
/* 584 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__overArg_js__ = __webpack_require__(585);


/** Built-in value references. */
var getPrototype = Object(__WEBPACK_IMPORTED_MODULE_0__overArg_js__["a" /* default */])(Object.getPrototypeOf, Object);

/* harmony default export */ __webpack_exports__["a"] = (getPrototype);


/***/ }),
/* 585 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* harmony default export */ __webpack_exports__["a"] = (overArg);


/***/ }),
/* 586 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/* harmony default export */ __webpack_exports__["a"] = (isObjectLike);


/***/ }),
/* 587 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(588);


/***/ }),
/* 588 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = __webpack_require__(589);

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root; /* global window */


if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(92), __webpack_require__(131)(module)))

/***/ }),
/* 589 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};

/***/ }),
/* 590 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = combineReducers;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__createStore__ = __webpack_require__(570);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash_es_isPlainObject__ = __webpack_require__(571);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_warning__ = __webpack_require__(573);




function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === __WEBPACK_IMPORTED_MODULE_0__createStore__["a" /* ActionTypes */].INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!Object(__WEBPACK_IMPORTED_MODULE_1_lodash_es_isPlainObject__["a" /* default */])(inputState)) {
    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });

  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });

  if (unexpectedKeys.length > 0) {
    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, { type: __WEBPACK_IMPORTED_MODULE_0__createStore__["a" /* ActionTypes */].INIT });

    if (typeof initialState === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');
    }

    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
    if (typeof reducer(undefined, { type: type }) === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + __WEBPACK_IMPORTED_MODULE_0__createStore__["a" /* ActionTypes */].INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');
    }
  });
}

/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (true) {
      if (typeof reducers[key] === 'undefined') {
        Object(__WEBPACK_IMPORTED_MODULE_2__utils_warning__["a" /* default */])('No reducer provided for key "' + key + '"');
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);

  var unexpectedKeyCache = void 0;
  if (true) {
    unexpectedKeyCache = {};
  }

  var shapeAssertionError = void 0;
  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var action = arguments[1];

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (true) {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        Object(__WEBPACK_IMPORTED_MODULE_2__utils_warning__["a" /* default */])(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};
    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(_key, action);
        throw new Error(errorMessage);
      }
      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    return hasChanged ? nextState : state;
  };
}

/***/ }),
/* 591 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = bindActionCreators;
function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(undefined, arguments));
  };
}

/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass a single function as the first argument,
 * and get a function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
  }

  var keys = Object.keys(actionCreators);
  var boundActionCreators = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}

/***/ }),
/* 592 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = applyMiddleware;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__compose__ = __webpack_require__(574);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };



/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function (reducer, preloadedState, enhancer) {
      var store = createStore(reducer, preloadedState, enhancer);
      var _dispatch = store.dispatch;
      var chain = [];

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch(action) {
          return _dispatch(action);
        }
      };
      chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = __WEBPACK_IMPORTED_MODULE_0__compose__["a" /* default */].apply(undefined, chain)(store.dispatch);

      return _extends({}, store, {
        dispatch: _dispatch
      });
    };
  };
}

/***/ }),
/* 593 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _assign = __webpack_require__(98);

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var initialState = {
    html: '',
    css: '',
    js: ''
};

var databaseInjectionAndPublish = function databaseInjectionAndPublish(state) {
    //All the connection with the backend will be made here!
    return state;
};

var CodeCombiner = function CodeCombiner() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
    var action = arguments[1];

    switch (action.type) {
        case 'HTML_SUBMIT':
            return (0, _assign2.default)({}, state, { html: action.html });
        case 'CSS_SUBMIT':
            return (0, _assign2.default)({}, state, { css: action.css });
        case 'JS_SUBMIT':
            return (0, _assign2.default)({}, state, { js: action.js });
        case 'SAVE_TO_DATABASE':
            return databaseInjectionAndPublish(state);
        default:
            return state;
    }
};

exports.default = CodeCombiner;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlZHV4XFxyZWR1Y2Vycy5qcyJdLCJuYW1lcyI6WyJpbml0aWFsU3RhdGUiLCJodG1sIiwiY3NzIiwianMiLCJkYXRhYmFzZUluamVjdGlvbkFuZFB1Ymxpc2giLCJzdGF0ZSIsIkNvZGVDb21iaW5lciIsImFjdGlvbiIsInR5cGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLElBQU07VUFBZSxBQUVqQjtTQUZpQixBQUdqQjtRQUhKLEFBQXFCO0FBQUEsQUFDakI7O0FBS0osSUFBTSw4QkFBOEIsU0FBOUIsQUFBOEIsNEJBQUEsQUFBQyxPQUFVLEFBQzNDO0FBQ0E7V0FBQSxBQUFPLEFBQ1Y7QUFIRDs7QUFLQSxJQUFNLGVBQWUsU0FBZixBQUFlLGVBQWtDO1FBQWpDLEFBQWlDLDRFQUF6QixBQUF5QjtRQUFYLEFBQVcsbUJBQ25EOztZQUFPLE9BQVAsQUFBYyxBQUNWO2FBQUEsQUFBSyxBQUFlO21CQUFPLHNCQUFBLEFBQWMsSUFBZCxBQUFrQixPQUFPLEVBQUMsTUFBTSxPQUF2QyxBQUFPLEFBQXlCLEFBQWMsQUFDbEU7YUFBQSxBQUFLLEFBQWM7bUJBQU8sc0JBQUEsQUFBYyxJQUFkLEFBQWtCLE9BQU8sRUFBQyxLQUFLLE9BQXRDLEFBQU8sQUFBeUIsQUFBYSxBQUNoRTthQUFBLEFBQUssQUFBYTttQkFBTyxzQkFBQSxBQUFjLElBQWQsQUFBa0IsT0FBTyxFQUFDLElBQUksT0FBckMsQUFBTyxBQUF5QixBQUFZLEFBQzlEO2FBQUEsQUFBSyxBQUFvQjttQkFBTyw0QkFBUCxBQUFPLEFBQTRCLEFBQzVEO0FBQVM7bUJBTGIsQUFLYSxBQUFPLEFBRXZCOztBQVJELEFBVUE7O2tCQUFBLEFBQWUiLCJmaWxlIjoicmVkdWNlcnMuanMiLCJzb3VyY2VSb290IjoiRTovUHJvamVjdHMgYW5kIElkZWFzL1N0YXJ0dmVyc2l0eS9uZXR3b3JxIn0=

 ;(function register() { /* react-hot-loader/webpack */ if (true) { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } if (typeof module.exports === 'function') { __REACT_HOT_LOADER__.register(module.exports, 'module.exports', "E:\\Projects and Ideas\\Startversity\\networq\\redux\\reducers.js"); return; } for (var key in module.exports) { if (!Object.prototype.hasOwnProperty.call(module.exports, key)) { continue; } var namedExport = void 0; try { namedExport = module.exports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, "E:\\Projects and Ideas\\Startversity\\networq\\redux\\reducers.js"); } } })();

/***/ }),
/* 594 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getPrototypeOf = __webpack_require__(60);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(33);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(34);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(61);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(63);

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__(27);

var _react2 = _interopRequireDefault(_react);

var _store = __webpack_require__(568);

var _store2 = _interopRequireDefault(_store);

var _actions = __webpack_require__(569);

var _less = __webpack_require__(575);

var _less2 = _interopRequireDefault(_less);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _jsxFileName = 'E:\\Projects and Ideas\\Startversity\\networq\\components\\Result.js';


var Result = function (_React$Component) {
    (0, _inherits3.default)(Result, _React$Component);

    function Result(props) {
        (0, _classCallCheck3.default)(this, Result);

        return (0, _possibleConstructorReturn3.default)(this, (Result.__proto__ || (0, _getPrototypeOf2.default)(Result)).call(this, props));
    }

    (0, _createClass3.default)(Result, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var rendering = void 0;
            _less2.default.render('#renderSc{' + _store2.default.getState().css + '}', function (e, output) {
                rendering = '<style>' + output.css + '</style>' + _store2.default.getState().html;
            });
            document.getElementById('renderSc').innerHTML = rendering;

            eval(_store2.default.getState().js);
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement('div', {
                id: 'renderSc',
                style: {
                    height: '90vh',
                    width: '50vw',
                    border: 'solid 1px black'
                }, __source: {
                    fileName: _jsxFileName,
                    lineNumber: 25
                }
            });
        }
    }]);

    return Result;
}(_react2.default.Component);

Result.unsubscribe = _store2.default.subscribe(function () {});

Result.contextType;

exports.default = Result;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHNcXFJlc3VsdC5qcyJdLCJuYW1lcyI6WyJzdG9yZSIsIlNBVkVfVE9fREFUQUJBU0UiLCJIVE1MX1NVQk1JVCIsIkNTU19TVUJNSVQiLCJKU19TVUJNSVQiLCJsZXNzIiwiUmVzdWx0IiwicHJvcHMiLCJyZW5kZXJpbmciLCJyZW5kZXIiLCJnZXRTdGF0ZSIsImNzcyIsImUiLCJvdXRwdXQiLCJodG1sIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImlubmVySFRNTCIsImV2YWwiLCJqcyIsImhlaWdodCIsIndpZHRoIiwiYm9yZGVyIiwiUmVhY3QiLCJDb21wb25lbnQiLCJ1bnN1YnNjcmliZSIsInN1YnNjcmliZSIsImNvbnRleHRUeXBlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxBQUFPOzs7O0FBQ1AsQUFBUSxBQUFrQixBQUFhLEFBQVk7O0FBQ25ELEFBQU87Ozs7Ozs7OztJQUdELEE7b0NBQ0Y7O29CQUFBLEFBQVksT0FBTzs0Q0FBQTs7cUlBQUEsQUFDVCxBQUNUOzs7Ozs0Q0FJbUIsQUFDaEI7Z0JBQUksaUJBQUosQUFDQTsyQkFBQSxBQUFLLHNCQUFvQixnQkFBQSxBQUFNLFdBQS9CLEFBQTBDLFdBQVEsVUFBQSxBQUFVLEdBQVYsQUFBYSxRQUFRLEFBQ25FO3dDQUFzQixPQUF0QixBQUE2QixtQkFBYyxnQkFBQSxBQUFNLFdBQWpELEFBQTRELEFBQy9EO0FBRkQsQUFHQTtxQkFBQSxBQUFTLGVBQVQsQUFBd0IsWUFBeEIsQUFBb0MsWUFBcEMsQUFBZ0QsQUFFaEQ7O2lCQUFLLGdCQUFBLEFBQU0sV0FBWCxBQUFzQixBQUN6Qjs7OztpQ0FFUSxBQUNMOztvQkFDSSxBQUNPLEFBQ0g7OzRCQUFPLEFBQ0MsQUFDUjsyQkFGTyxBQUVBLEFBQ1A7NEJBTEosQUFFVyxBQUdDO0FBSEQsQUFDUDs4QkFISjtnQ0FESixBQUNJLEFBUVA7QUFSTztBQUNJLGFBREo7Ozs7O0VBbkJTLGdCQUFNLEE7O0FBQXJCLEEsT0FLSyxBLGNBQWMsZ0JBQUEsQUFBTSxVQUFVLFlBQU0sQUFBRSxDLEFBQXhCOztBQXlCekIsT0FBQSxBQUFPLEFBRVA7O2tCQUFBLEFBQWUiLCJmaWxlIjoiUmVzdWx0LmpzIiwic291cmNlUm9vdCI6IkU6L1Byb2plY3RzIGFuZCBJZGVhcy9TdGFydHZlcnNpdHkvbmV0d29ycSJ9

 ;(function register() { /* react-hot-loader/webpack */ if (true) { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } if (typeof module.exports === 'function') { __REACT_HOT_LOADER__.register(module.exports, 'module.exports', "E:\\Projects and Ideas\\Startversity\\networq\\components\\Result.js"); return; } for (var key in module.exports) { if (!Object.prototype.hasOwnProperty.call(module.exports, key)) { continue; } var namedExport = void 0; try { namedExport = module.exports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, "E:\\Projects and Ideas\\Startversity\\networq\\components\\Result.js"); } } })();

/***/ }),
/* 595 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getPrototypeOf = __webpack_require__(60);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(33);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(34);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(61);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(63);

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__(27);

var _react2 = _interopRequireDefault(_react);

var _store = __webpack_require__(568);

var _store2 = _interopRequireDefault(_store);

var _actions = __webpack_require__(569);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _jsxFileName = 'E:\\Projects and Ideas\\Startversity\\networq\\components\\Css.js';


var Css = function (_React$Component) {
    (0, _inherits3.default)(Css, _React$Component);

    function Css(props) {
        (0, _classCallCheck3.default)(this, Css);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Css.__proto__ || (0, _getPrototypeOf2.default)(Css)).call(this, props));

        _this.state = {
            content: _store2.default.getState().css
        };
        return _this;
    }

    (0, _createClass3.default)(Css, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            _store2.default.dispatch((0, _actions.CSS_SUBMIT)(this.state.content));
        }
    }, {
        key: '_updateState',
        value: function _updateState(content) {
            this.setState({ content: content });
            _store2.default.dispatch((0, _actions.CSS_SUBMIT)(this.state.content));
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            _store2.default.dispatch((0, _actions.CSS_SUBMIT)(this.state.content));
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            return _react2.default.createElement('div', {
                __source: {
                    fileName: _jsxFileName,
                    lineNumber: 27
                }
            }, _react2.default.createElement('h2', {
                __source: {
                    fileName: _jsxFileName,
                    lineNumber: 28
                }
            }, 'CSS'), _react2.default.createElement('textarea', { style: { resize: 'none' },
                onChange: function onChange(node) {
                    return _this2._updateState(node.target.value);
                },
                rows: 20,
                cols: 100,
                __source: {
                    fileName: _jsxFileName,
                    lineNumber: 29
                }
            }, this.state.content), _react2.default.createElement('button', { onClick: function onClick() {
                    return _store2.default.dispatch((0, _actions.CSS_SUBMIT)(_this2.state.content));
                }, __source: {
                    fileName: _jsxFileName,
                    lineNumber: 36
                }
            }, 'Submit CSS'));
        }
    }]);

    return Css;
}(_react2.default.Component);

exports.default = Css;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHNcXENzcy5qcyJdLCJuYW1lcyI6WyJzdG9yZSIsIkNTU19TVUJNSVQiLCJDc3MiLCJwcm9wcyIsInN0YXRlIiwiY29udGVudCIsImdldFN0YXRlIiwiY3NzIiwiZGlzcGF0Y2giLCJzZXRTdGF0ZSIsInJlc2l6ZSIsIm5vZGUiLCJfdXBkYXRlU3RhdGUiLCJ0YXJnZXQiLCJ2YWx1ZSIsIlJlYWN0IiwiQ29tcG9uZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxBQUFPOzs7O0FBQ1AsQUFBUTs7Ozs7OztJQUVGLEE7aUNBQ0Y7O2lCQUFBLEFBQVksT0FBTzs0Q0FBQTs7b0lBQUEsQUFDVCxBQUNOOztjQUFBLEFBQUs7cUJBQ1EsZ0JBQUEsQUFBTSxXQUhKLEFBRWYsQUFBYSxBQUNpQjtBQURqQixBQUNUO2VBRVA7Ozs7OzZDQUVtQixBQUNoQjs0QkFBQSxBQUFNLFNBQVMseUJBQVcsS0FBQSxBQUFLLE1BQS9CLEFBQWUsQUFBc0IsQUFDeEM7Ozs7cUNBRVksQSxTQUFRLEFBQ2pCO2lCQUFBLEFBQUssU0FBUyxFQUFDLFNBQWYsQUFBYyxBQUNkOzRCQUFBLEFBQU0sU0FBUyx5QkFBVyxLQUFBLEFBQUssTUFBL0IsQUFBZSxBQUFzQixBQUN4Qzs7OzsrQ0FFcUIsQUFDbEI7NEJBQUEsQUFBTSxTQUFTLHlCQUFXLEtBQUEsQUFBSyxNQUEvQixBQUFlLEFBQXNCLEFBQ3hDOzs7O2lDQUVRO3lCQUNMOzttQ0FDSSxjQUFBOzs4QkFBQTtnQ0FBQSxBQUNJO0FBREo7QUFBQSxhQUFBLGtCQUNJLGNBQUE7OzhCQUFBO2dDQUFBO0FBQUE7QUFBQSxlQURKLEFBQ0ksQUFDQSx3QkFBQSxjQUFBLGNBQVUsT0FBTyxFQUFFLFFBQW5CLEFBQWlCLEFBQVUsQUFDbkI7MEJBQVUsa0JBQUEsQUFBQyxNQUFEOzJCQUFRLE9BQUEsQUFBSyxhQUFhLEtBQUEsQUFBSyxPQUEvQixBQUFRLEFBQThCO0FBRHhELEFBRVE7c0JBRlIsQUFFYyxBQUNOO3NCQUhSLEFBR2M7OzhCQUhkO2dDQUFBLEFBS0s7QUFMTDtvQkFLSyxBQUFLLE1BUGQsQUFFSSxBQUtnQixBQUVoQiwwQkFBQSxjQUFBLFlBQVEsU0FBUyxtQkFBQTsyQkFBTSxnQkFBQSxBQUFNLFNBQVMseUJBQVcsT0FBQSxBQUFLLE1BQXJDLEFBQU0sQUFBZSxBQUFzQjtBQUE1RDs4QkFBQTtnQ0FBQTtBQUFBO2VBVlIsQUFDSSxBQVNJLEFBR1g7Ozs7O0VBbkNhLGdCQUFNLEEsQUF1Q3hCOztrQkFBQSxBQUFlIiwiZmlsZSI6IkNzcy5qcyIsInNvdXJjZVJvb3QiOiJFOi9Qcm9qZWN0cyBhbmQgSWRlYXMvU3RhcnR2ZXJzaXR5L25ldHdvcnEifQ==

 ;(function register() { /* react-hot-loader/webpack */ if (true) { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } if (typeof module.exports === 'function') { __REACT_HOT_LOADER__.register(module.exports, 'module.exports', "E:\\Projects and Ideas\\Startversity\\networq\\components\\Css.js"); return; } for (var key in module.exports) { if (!Object.prototype.hasOwnProperty.call(module.exports, key)) { continue; } var namedExport = void 0; try { namedExport = module.exports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, "E:\\Projects and Ideas\\Startversity\\networq\\components\\Css.js"); } } })();

/***/ }),
/* 596 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getPrototypeOf = __webpack_require__(60);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(33);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(34);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(61);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(63);

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__(27);

var _react2 = _interopRequireDefault(_react);

var _store = __webpack_require__(568);

var _store2 = _interopRequireDefault(_store);

var _actions = __webpack_require__(569);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _jsxFileName = 'E:\\Projects and Ideas\\Startversity\\networq\\components\\JS.js';


var Js = function (_React$Component) {
    (0, _inherits3.default)(Js, _React$Component);

    function Js(props) {
        (0, _classCallCheck3.default)(this, Js);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Js.__proto__ || (0, _getPrototypeOf2.default)(Js)).call(this, props));

        _this.state = {
            content: _store2.default.getState().js
        };
        return _this;
    }

    (0, _createClass3.default)(Js, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            _store2.default.dispatch((0, _actions.JS_SUBMIT)(this.state.content));
        }
    }, {
        key: '_updateState',
        value: function _updateState(content) {
            this.setState({ content: content });
            _store2.default.dispatch((0, _actions.JS_SUBMIT)(this.state.content));
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            _store2.default.dispatch((0, _actions.JS_SUBMIT)(this.state.content));
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            return _react2.default.createElement('div', {
                __source: {
                    fileName: _jsxFileName,
                    lineNumber: 29
                }
            }, _react2.default.createElement('h2', {
                __source: {
                    fileName: _jsxFileName,
                    lineNumber: 30
                }
            }, 'JavaScript'), _react2.default.createElement('textarea', { style: { resize: 'none' },
                onChange: function onChange(node) {
                    return _this2._updateState(node.target.value);
                },
                rows: 20,
                cols: 100,
                __source: {
                    fileName: _jsxFileName,
                    lineNumber: 31
                }
            }, this.state.content), _react2.default.createElement('button', { onClick: function onClick() {
                    return _store2.default.dispatch((0, _actions.JS_SUBMIT)(_this2.state.content));
                }, __source: {
                    fileName: _jsxFileName,
                    lineNumber: 38
                }
            }, 'Submit JS'));
        }
    }]);

    return Js;
}(_react2.default.Component);

exports.default = Js;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHNcXEpTLmpzIl0sIm5hbWVzIjpbInN0b3JlIiwiSlNfU1VCTUlUIiwiSnMiLCJwcm9wcyIsInN0YXRlIiwiY29udGVudCIsImdldFN0YXRlIiwianMiLCJkaXNwYXRjaCIsInNldFN0YXRlIiwicmVzaXplIiwibm9kZSIsIl91cGRhdGVTdGF0ZSIsInRhcmdldCIsInZhbHVlIiwiUmVhY3QiLCJDb21wb25lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLEFBQU87Ozs7QUFDUCxBQUFROzs7Ozs7O0lBRUYsQTtnQ0FDRjs7Z0JBQUEsQUFBWSxPQUFPOzRDQUFBOztrSUFBQSxBQUNULEFBQ047O2NBQUEsQUFBSztxQkFDUSxnQkFBQSxBQUFNLFdBSEosQUFFZixBQUFhLEFBQ2lCO0FBRGpCLEFBQ1Q7ZUFFUDs7Ozs7NkNBRW1CLEFBQ2hCOzRCQUFBLEFBQU0sU0FBUyx3QkFBVSxLQUFBLEFBQUssTUFBOUIsQUFBZSxBQUFxQixBQUN2Qzs7OztxQ0FFWSxBLFNBQVEsQUFDakI7aUJBQUEsQUFBSyxTQUFTLEVBQUMsU0FBZixBQUFjLEFBQ2Q7NEJBQUEsQUFBTSxTQUFTLHdCQUFVLEtBQUEsQUFBSyxNQUE5QixBQUFlLEFBQXFCLEFBQ3ZDOzs7OytDQUVxQixBQUNsQjs0QkFBQSxBQUFNLFNBQVMsd0JBQVUsS0FBQSxBQUFLLE1BQTlCLEFBQWUsQUFBcUIsQUFDdkM7Ozs7aUNBSVE7eUJBQ0w7O21DQUNJLGNBQUE7OzhCQUFBO2dDQUFBLEFBQ0k7QUFESjtBQUFBLGFBQUEsa0JBQ0ksY0FBQTs7OEJBQUE7Z0NBQUE7QUFBQTtBQUFBLGVBREosQUFDSSxBQUNBLCtCQUFBLGNBQUEsY0FBVSxPQUFPLEVBQUUsUUFBbkIsQUFBaUIsQUFBVSxBQUNuQjswQkFBVSxrQkFBQSxBQUFDLE1BQUQ7MkJBQVEsT0FBQSxBQUFLLGFBQWEsS0FBQSxBQUFLLE9BQS9CLEFBQVEsQUFBOEI7QUFEeEQsQUFFUTtzQkFGUixBQUVjLEFBQ047c0JBSFIsQUFHYzs7OEJBSGQ7Z0NBQUEsQUFLSztBQUxMO29CQUtLLEFBQUssTUFQZCxBQUVJLEFBS2dCLEFBRWhCLDBCQUFBLGNBQUEsWUFBUSxTQUFTLG1CQUFBOzJCQUFNLGdCQUFBLEFBQU0sU0FBUyx3QkFBVSxPQUFBLEFBQUssTUFBcEMsQUFBTSxBQUFlLEFBQXFCO0FBQTNEOzhCQUFBO2dDQUFBO0FBQUE7ZUFWUixBQUNJLEFBU0ksQUFHWDs7Ozs7RUFyQ1ksZ0JBQU0sQSxBQXlDdkI7O2tCQUFBLEFBQWUiLCJmaWxlIjoiSlMuanMiLCJzb3VyY2VSb290IjoiRTovUHJvamVjdHMgYW5kIElkZWFzL1N0YXJ0dmVyc2l0eS9uZXR3b3JxIn0=

 ;(function register() { /* react-hot-loader/webpack */ if (true) { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } if (typeof module.exports === 'function') { __REACT_HOT_LOADER__.register(module.exports, 'module.exports', "E:\\Projects and Ideas\\Startversity\\networq\\components\\JS.js"); return; } for (var key in module.exports) { if (!Object.prototype.hasOwnProperty.call(module.exports, key)) { continue; } var namedExport = void 0; try { namedExport = module.exports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, "E:\\Projects and Ideas\\Startversity\\networq\\components\\JS.js"); } } })();

/***/ }),
/* 597 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getPrototypeOf = __webpack_require__(60);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(33);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(34);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(61);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(63);

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__(27);

var _react2 = _interopRequireDefault(_react);

var _store = __webpack_require__(568);

var _store2 = _interopRequireDefault(_store);

var _actions = __webpack_require__(569);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _jsxFileName = 'E:\\Projects and Ideas\\Startversity\\networq\\components\\Html.js';


var Html = function (_React$Component) {
    (0, _inherits3.default)(Html, _React$Component);

    function Html(props) {
        (0, _classCallCheck3.default)(this, Html);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Html.__proto__ || (0, _getPrototypeOf2.default)(Html)).call(this, props));

        _this.state = {
            content: _store2.default.getState().html
        };
        return _this;
    }

    (0, _createClass3.default)(Html, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            _store2.default.dispatch((0, _actions.HTML_SUBMIT)(this.state.content));
        }
    }, {
        key: '_updateState',
        value: function _updateState(content) {
            this.setState({ content: content });
            _store2.default.dispatch((0, _actions.HTML_SUBMIT)(this.state.content));
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            _store2.default.dispatch((0, _actions.HTML_SUBMIT)(this.state.content));
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            return _react2.default.createElement('div', {
                __source: {
                    fileName: _jsxFileName,
                    lineNumber: 27
                }
            }, _react2.default.createElement('h2', {
                __source: {
                    fileName: _jsxFileName,
                    lineNumber: 28
                }
            }, 'HTML'), _react2.default.createElement('textarea', { style: { resize: 'none' },
                onChange: function onChange(node) {
                    return _this2._updateState(node.target.value);
                },
                rows: 20,
                cols: 100,
                __source: {
                    fileName: _jsxFileName,
                    lineNumber: 29
                }
            }, this.state.content), _react2.default.createElement('button', { onClick: function onClick() {
                    return _store2.default.dispatch((0, _actions.HTML_SUBMIT)(_this2.state.content));
                }, __source: {
                    fileName: _jsxFileName,
                    lineNumber: 36
                }
            }, 'Submit HTML'));
        }
    }]);

    return Html;
}(_react2.default.Component);

exports.default = Html;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHNcXEh0bWwuanMiXSwibmFtZXMiOlsic3RvcmUiLCJIVE1MX1NVQk1JVCIsIkh0bWwiLCJwcm9wcyIsInN0YXRlIiwiY29udGVudCIsImdldFN0YXRlIiwiaHRtbCIsImRpc3BhdGNoIiwic2V0U3RhdGUiLCJyZXNpemUiLCJub2RlIiwiX3VwZGF0ZVN0YXRlIiwidGFyZ2V0IiwidmFsdWUiLCJSZWFjdCIsIkNvbXBvbmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsQUFBTzs7OztBQUNQLEFBQVE7Ozs7Ozs7SUFFRixBO2tDQUNGOztrQkFBQSxBQUFZLE9BQU87NENBQUE7O3NJQUFBLEFBQ1QsQUFDTjs7Y0FBQSxBQUFLO3FCQUNRLGdCQUFBLEFBQU0sV0FISixBQUVmLEFBQWEsQUFDaUI7QUFEakIsQUFDVDtlQUVQOzs7Ozs2Q0FFbUIsQUFDaEI7NEJBQUEsQUFBTSxTQUFTLDBCQUFZLEtBQUEsQUFBSyxNQUFoQyxBQUFlLEFBQXVCLEFBQ3pDOzs7O3FDQUVZLEEsU0FBUSxBQUNqQjtpQkFBQSxBQUFLLFNBQVMsRUFBQyxTQUFmLEFBQWMsQUFDZDs0QkFBQSxBQUFNLFNBQVMsMEJBQVksS0FBQSxBQUFLLE1BQWhDLEFBQWUsQUFBdUIsQUFDekM7Ozs7K0NBRXFCLEFBQ2xCOzRCQUFBLEFBQU0sU0FBUywwQkFBWSxLQUFBLEFBQUssTUFBaEMsQUFBZSxBQUF1QixBQUN6Qzs7OztpQ0FFUTt5QkFDTDs7bUNBQ0ksY0FBQTs7OEJBQUE7Z0NBQUEsQUFDSTtBQURKO0FBQUEsYUFBQSxrQkFDSSxjQUFBOzs4QkFBQTtnQ0FBQTtBQUFBO0FBQUEsZUFESixBQUNJLEFBQ0EseUJBQUEsY0FBQSxjQUFVLE9BQU8sRUFBRSxRQUFuQixBQUFpQixBQUFVLEFBQ25COzBCQUFVLGtCQUFBLEFBQUMsTUFBRDsyQkFBUSxPQUFBLEFBQUssYUFBYSxLQUFBLEFBQUssT0FBL0IsQUFBUSxBQUE4QjtBQUR4RCxBQUVRO3NCQUZSLEFBRWMsQUFDTjtzQkFIUixBQUdjOzs4QkFIZDtnQ0FBQSxBQUtLO0FBTEw7b0JBS0ssQUFBSyxNQVBkLEFBRUksQUFLZ0IsQUFFaEIsMEJBQUEsY0FBQSxZQUFRLFNBQVMsbUJBQUE7MkJBQU0sZ0JBQUEsQUFBTSxTQUFTLDBCQUFZLE9BQUEsQUFBSyxNQUF0QyxBQUFNLEFBQWUsQUFBdUI7QUFBN0Q7OEJBQUE7Z0NBQUE7QUFBQTtlQVZSLEFBQ0ksQUFTSSxBQUdYOzs7OztFQW5DYyxnQkFBTSxBLEFBdUN6Qjs7a0JBQUEsQUFBZSIsImZpbGUiOiJIdG1sLmpzIiwic291cmNlUm9vdCI6IkU6L1Byb2plY3RzIGFuZCBJZGVhcy9TdGFydHZlcnNpdHkvbmV0d29ycSJ9

 ;(function register() { /* react-hot-loader/webpack */ if (true) { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } if (typeof module.exports === 'function') { __REACT_HOT_LOADER__.register(module.exports, 'module.exports', "E:\\Projects and Ideas\\Startversity\\networq\\components\\Html.js"); return; } for (var key in module.exports) { if (!Object.prototype.hasOwnProperty.call(module.exports, key)) { continue; } var namedExport = void 0; try { namedExport = module.exports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, "E:\\Projects and Ideas\\Startversity\\networq\\components\\Html.js"); } } })();

/***/ })
],[576]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlc1xccGFnZXNcXGluZGV4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcz85Y2I2MzZlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzPzljYjYzNmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzPzljYjYzNmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanM/OWNiNjM2ZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcz85Y2I2MzZlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzPzljYjYzNmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanM/OWNiNjM2ZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcz85Y2I2MzZlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanM/OWNiNjM2ZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcz85Y2I2MzZlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzPzljYjYzNmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanM/OWNiNjM2ZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanM/OWNiNjM2ZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzPzljYjYzNmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanM/OWNiNjM2ZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qcz85Y2I2MzZlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vay5qcz85Y2I2MzZlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcz85Y2I2MzZlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzPzljYjYzNmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qcz85Y2I2MzZlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzPzljYjYzNmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanM/OWNiNjM2ZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcz85Y2I2MzZlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzPzljYjYzNmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzPzljYjYzNmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L3JlYWN0LmpzPzljYjYzNmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcz85Y2I2MzZlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanM/OWNiNjM2ZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qcz85Y2I2MzZlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanM/OWNiNjM2ZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzPzljYjYzNmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzPzljYjYzNmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzPzljYjYzNmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanM/OWNiNjM2ZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qcz85Y2I2MzZlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzPzljYjYzNmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzPzljYjYzNmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jYW5EZWZpbmVQcm9wZXJ0eS5qcz85Y2I2MzZlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcz85Y2I2MzZlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcz85Y2I2MzZlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanM/NmMwMjYxNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzPzZjMDI2MTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzPzZjMDI2MTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvbG93UHJpb3JpdHlXYXJuaW5nLmpzPzZjMDI2MTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzPzZjMDI2MTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanM/NmMwMjYxNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0LmpzPzZjMDI2MTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzPzZjMDI2MTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzPzZjMDI2MTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanM/NmMwMjYxNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzPzZjMDI2MTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzPzZjMDI2MTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanM/NmMwMjYxNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzPzZjMDI2MTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanM/NmMwMjYxNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0QmFzZUNsYXNzZXMuanM/NmMwMjYxNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlLmpzPzZjMDI2MTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRTeW1ib2wuanM/NmMwMjYxNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldEl0ZXJhdG9yRm4uanM/NmMwMjYxNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RWxlbWVudFZhbGlkYXRvci5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzPzZjMDI2MTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzPzZjMDI2MTUiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanM/NmMwMjYxNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanM/NmMwMjYxNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanM/NmMwMjYxNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzPzZjMDI2MTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanM/NmMwMjYxNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanM/NmMwMjYxNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanM/NmMwMjYxNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5LmpzPzZjMDI2MTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanM/NmMwMjYxNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzPzZjMDI2MTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzPzZjMDI2MTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcz82YzAyNjE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanM/NmMwMjYxNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzPzZiZTYyNWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanM/NmJlNjI1ZCIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzPzZiZTYyNWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanM/NmJlNjI1ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnbi5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanM/NmJlNjI1ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzPzZiZTYyNWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanM/NmJlNjI1ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0ta2V5cy5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzPzZiZTYyNWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanM/NmJlNjI1ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzPzZiZTYyNWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanM/NmJlNjI1ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1wcm90by5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbi5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanM/NmJlNjI1ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanM/NmJlNjI1ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0tleUVzY2FwZVV0aWxzLmpzPzZiZTYyNWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUZhY3Rvcmllcy5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvY2hlY2tSZWFjdFR5cGVTcGVjLmpzPzZiZTYyNWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanM/NmJlNjI1ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzLmpzPzZiZTYyNWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanM/NmJlNjI1ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VmVyc2lvbi5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvY3JlYXRlQ2xhc3MuanM/NmJlNjI1ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JlYXRlLXJlYWN0LWNsYXNzL2ZhY3RvcnkuanM/NmJlNjI1ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL29ubHlDaGlsZC5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL3JlZHV4L3N0b3JlLmpzPzZiZTYyNWQiLCJ3ZWJwYWNrOi8vLy4vcmVkdXgvYWN0aW9ucy5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9jcmVhdGVTdG9yZS5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNQbGFpbk9iamVjdC5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWR1eC9lcy91dGlscy93YXJuaW5nLmpzPzZiZTYyNWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2NvbXBvc2UuanM/NmJlNjI1ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVzcy9kaXN0L2xlc3MuanM/NmJlNjI1ZCIsIndlYnBhY2s6Ly8vLi9wYWdlcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9pbmRleC5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRUYWcuanM/NmJlNjI1ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzPzZiZTYyNWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZnJlZUdsb2JhbC5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcz82YmU2MjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzPzZiZTYyNWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UHJvdG90eXBlLmpzPzZiZTYyNWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qcz82ZmM0MDEwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3RMaWtlLmpzPzZmYzQwMTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2luZGV4LmpzPzZmYzQwMTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2xpYi9pbmRleC5qcz82ZmM0MDEwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvcG9ueWZpbGwuanM/NmZjNDAxMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVkdXgvZXMvY29tYmluZVJlZHVjZXJzLmpzPzZmYzQwMTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2JpbmRBY3Rpb25DcmVhdG9ycy5qcz82ZmM0MDEwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9hcHBseU1pZGRsZXdhcmUuanM/NmZjNDAxMCIsIndlYnBhY2s6Ly8vLi9yZWR1eC9yZWR1Y2Vycy5qcz82ZmM0MDEwIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvUmVzdWx0LmpzPzZmYzQwMTAiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9Dc3MuanM/NmZjNDAxMCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL0pTLmpzPzZmYzQwMTAiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9IdG1sLmpzPzZmYzQwMTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3dhcm5pbmcuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNS4xJyB9O1xuaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciBJU19XUkFQID0gdHlwZSAmICRleHBvcnQuVztcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGtleSwgb3duLCBvdXQ7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG93biAmJiBrZXkgaW4gZXhwb3J0cykgY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbiAoQykge1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEMpIHtcbiAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDKCk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmIChJU19QUk9UTykge1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmICh0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKSBoaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFN5bWJvbCcpO1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIG5vIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHNlbGZcbiAgICAgIH0pO1xuICAgICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc291cmNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICBlbGVtZW50Ll9zZWxmID0gc2VsZjtcbiAgICAgIGVsZW1lbnQuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlZWxlbWVudFxuICovXG5SZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLiQkdHlwZW9mID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgUmVhY3RFbGVtZW50cyBvZiBhIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlZmFjdG9yeVxuICovXG5SZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBmYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgLy8gRXhwb3NlIHRoZSB0eXBlIG9uIHRoZSBmYWN0b3J5IGFuZCB0aGUgcHJvdG90eXBlIHNvIHRoYXQgaXQgY2FuIGJlXG4gIC8vIGVhc2lseSBhY2Nlc3NlZCBvbiBlbGVtZW50cy4gRS5nLiBgPEZvbyAvPi50eXBlID09PSBGb29gLlxuICAvLyBUaGlzIHNob3VsZCBub3QgYmUgbmFtZWQgYGNvbnN0cnVjdG9yYCBzaW5jZSB0aGlzIG1heSBub3QgYmUgdGhlIGZ1bmN0aW9uXG4gIC8vIHRoYXQgY3JlYXRlZCB0aGUgZWxlbWVudCwgYW5kIGl0IG1heSBub3QgZXZlbiBiZSBhIGNvbnN0cnVjdG9yLlxuICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgZmFjdG9yeS50eXBlID0gdHlwZTtcbiAgcmV0dXJuIGZhY3Rvcnk7XG59O1xuXG5SZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlS2V5ID0gZnVuY3Rpb24gKG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufTtcblxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jbG9uZWVsZW1lbnRcbiAqL1xuUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjtcbiAgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn07XG5cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5pc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBpc05hdGl2ZShmbikge1xuICAvLyBCYXNlZCBvbiBpc05hdGl2ZSgpIGZyb20gTG9kYXNoXG4gIHZhciBmdW5jVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArIGZ1bmNUb1N0cmluZ1xuICAvLyBUYWtlIGFuIGV4YW1wbGUgbmF0aXZlIGZ1bmN0aW9uIHNvdXJjZSBmb3IgY29tcGFyaXNvblxuICAuY2FsbChoYXNPd25Qcm9wZXJ0eVxuICAvLyBTdHJpcCByZWdleCBjaGFyYWN0ZXJzIHNvIHdlIGNhbiB1c2UgaXQgZm9yIHJlZ2V4XG4gICkucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csICdcXFxcJCYnXG4gIC8vIFJlbW92ZSBoYXNPd25Qcm9wZXJ0eSBmcm9tIHRoZSB0ZW1wbGF0ZSB0byBtYWtlIGl0IGdlbmVyaWNcbiAgKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJyk7XG4gIHRyeSB7XG4gICAgdmFyIHNvdXJjZSA9IGZ1bmNUb1N0cmluZy5jYWxsKGZuKTtcbiAgICByZXR1cm4gcmVJc05hdGl2ZS50ZXN0KHNvdXJjZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG52YXIgY2FuVXNlQ29sbGVjdGlvbnMgPVxuLy8gQXJyYXkuZnJvbVxudHlwZW9mIEFycmF5LmZyb20gPT09ICdmdW5jdGlvbicgJiZcbi8vIE1hcFxudHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShNYXApICYmXG4vLyBNYXAucHJvdG90eXBlLmtleXNcbk1hcC5wcm90b3R5cGUgIT0gbnVsbCAmJiB0eXBlb2YgTWFwLnByb3RvdHlwZS5rZXlzID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKE1hcC5wcm90b3R5cGUua2V5cykgJiZcbi8vIFNldFxudHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShTZXQpICYmXG4vLyBTZXQucHJvdG90eXBlLmtleXNcblNldC5wcm90b3R5cGUgIT0gbnVsbCAmJiB0eXBlb2YgU2V0LnByb3RvdHlwZS5rZXlzID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKFNldC5wcm90b3R5cGUua2V5cyk7XG5cbnZhciBzZXRJdGVtO1xudmFyIGdldEl0ZW07XG52YXIgcmVtb3ZlSXRlbTtcbnZhciBnZXRJdGVtSURzO1xudmFyIGFkZFJvb3Q7XG52YXIgcmVtb3ZlUm9vdDtcbnZhciBnZXRSb290SURzO1xuXG5pZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgdmFyIGl0ZW1NYXAgPSBuZXcgTWFwKCk7XG4gIHZhciByb290SURTZXQgPSBuZXcgU2V0KCk7XG5cbiAgc2V0SXRlbSA9IGZ1bmN0aW9uIChpZCwgaXRlbSkge1xuICAgIGl0ZW1NYXAuc2V0KGlkLCBpdGVtKTtcbiAgfTtcbiAgZ2V0SXRlbSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBpdGVtTWFwLmdldChpZCk7XG4gIH07XG4gIHJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICBpdGVtTWFwWydkZWxldGUnXShpZCk7XG4gIH07XG4gIGdldEl0ZW1JRHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oaXRlbU1hcC5rZXlzKCkpO1xuICB9O1xuXG4gIGFkZFJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByb290SURTZXQuYWRkKGlkKTtcbiAgfTtcbiAgcmVtb3ZlUm9vdCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHJvb3RJRFNldFsnZGVsZXRlJ10oaWQpO1xuICB9O1xuICBnZXRSb290SURzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHJvb3RJRFNldC5rZXlzKCkpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIGl0ZW1CeUtleSA9IHt9O1xuICB2YXIgcm9vdEJ5S2V5ID0ge307XG5cbiAgLy8gVXNlIG5vbi1udW1lcmljIGtleXMgdG8gcHJldmVudCBWOCBwZXJmb3JtYW5jZSBpc3N1ZXM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbiAgdmFyIGdldEtleUZyb21JRCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiAnLicgKyBpZDtcbiAgfTtcbiAgdmFyIGdldElERnJvbUtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoa2V5LnN1YnN0cigxKSwgMTApO1xuICB9O1xuXG4gIHNldEl0ZW0gPSBmdW5jdGlvbiAoaWQsIGl0ZW0pIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICBpdGVtQnlLZXlba2V5XSA9IGl0ZW07XG4gIH07XG4gIGdldEl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICByZXR1cm4gaXRlbUJ5S2V5W2tleV07XG4gIH07XG4gIHJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICBkZWxldGUgaXRlbUJ5S2V5W2tleV07XG4gIH07XG4gIGdldEl0ZW1JRHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGl0ZW1CeUtleSkubWFwKGdldElERnJvbUtleSk7XG4gIH07XG5cbiAgYWRkUm9vdCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIHJvb3RCeUtleVtrZXldID0gdHJ1ZTtcbiAgfTtcbiAgcmVtb3ZlUm9vdCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIGRlbGV0ZSByb290QnlLZXlba2V5XTtcbiAgfTtcbiAgZ2V0Um9vdElEcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocm9vdEJ5S2V5KS5tYXAoZ2V0SURGcm9tS2V5KTtcbiAgfTtcbn1cblxudmFyIHVubW91bnRlZElEcyA9IFtdO1xuXG5mdW5jdGlvbiBwdXJnZURlZXAoaWQpIHtcbiAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgaWYgKGl0ZW0pIHtcbiAgICB2YXIgY2hpbGRJRHMgPSBpdGVtLmNoaWxkSURzO1xuXG4gICAgcmVtb3ZlSXRlbShpZCk7XG4gICAgY2hpbGRJRHMuZm9yRWFjaChwdXJnZURlZXApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIChuYW1lIHx8ICdVbmtub3duJykgKyAoc291cmNlID8gJyAoYXQgJyArIHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJykgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJyA6IG93bmVyTmFtZSA/ICcgKGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcpJyA6ICcnKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcjZW1wdHknO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gJyN0ZXh0JztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZSB8fCBlbGVtZW50LnR5cGUubmFtZSB8fCAnVW5rbm93bic7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVJRChpZCkge1xuICB2YXIgbmFtZSA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUoaWQpO1xuICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gIHZhciBvd25lcklEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKGlkKTtcbiAgdmFyIG93bmVyTmFtZTtcbiAgaWYgKG93bmVySUQpIHtcbiAgICBvd25lck5hbWUgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKG93bmVySUQpO1xuICB9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGVsZW1lbnQsICdSZWFjdENvbXBvbmVudFRyZWVIb29rOiBNaXNzaW5nIFJlYWN0IGVsZW1lbnQgZm9yIGRlYnVnSUQgJXMgd2hlbiAnICsgJ2J1aWxkaW5nIHN0YWNrJywgaWQpIDogdm9pZCAwO1xuICByZXR1cm4gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBlbGVtZW50ICYmIGVsZW1lbnQuX3NvdXJjZSwgb3duZXJOYW1lKTtcbn1cblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSB7XG4gIG9uU2V0Q2hpbGRyZW46IGZ1bmN0aW9uIChpZCwgbmV4dENoaWxkSURzKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICAhaXRlbSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJdGVtIG11c3QgaGF2ZSBiZWVuIHNldCcpIDogX3Byb2RJbnZhcmlhbnQoJzE0NCcpIDogdm9pZCAwO1xuICAgIGl0ZW0uY2hpbGRJRHMgPSBuZXh0Q2hpbGRJRHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHRDaGlsZElEcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5leHRDaGlsZElEID0gbmV4dENoaWxkSURzW2ldO1xuICAgICAgdmFyIG5leHRDaGlsZCA9IGdldEl0ZW0obmV4dENoaWxkSUQpO1xuICAgICAgIW5leHRDaGlsZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBob29rIGV2ZW50cyB0byBmaXJlIGZvciB0aGUgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MCcpIDogdm9pZCAwO1xuICAgICAgIShuZXh0Q2hpbGQuY2hpbGRJRHMgIT0gbnVsbCB8fCB0eXBlb2YgbmV4dENoaWxkLmVsZW1lbnQgIT09ICdvYmplY3QnIHx8IG5leHRDaGlsZC5lbGVtZW50ID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uU2V0Q2hpbGRyZW4oKSB0byBmaXJlIGZvciBhIGNvbnRhaW5lciBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBfcHJvZEludmFyaWFudCgnMTQxJykgOiB2b2lkIDA7XG4gICAgICAhbmV4dENoaWxkLmlzTW91bnRlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvbk1vdW50Q29tcG9uZW50KCkgdG8gZmlyZSBmb3IgdGhlIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IF9wcm9kSW52YXJpYW50KCc3MScpIDogdm9pZCAwO1xuICAgICAgaWYgKG5leHRDaGlsZC5wYXJlbnRJRCA9PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZC5wYXJlbnRJRCA9IGlkO1xuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZG4ndCBiZSBuZWNlc3NhcnkgYnV0IG1vdW50aW5nIGEgbmV3IHJvb3QgZHVyaW5nIGluXG4gICAgICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBjdXJyZW50bHkgY2F1c2VzIG5vdC15ZXQtbW91bnRlZCBjb21wb25lbnRzIHRvXG4gICAgICAgIC8vIGJlIHB1cmdlZCBmcm9tIG91ciB0cmVlIGRhdGEgc28gdGhlaXIgcGFyZW50IGlkIGlzIG1pc3NpbmcuXG4gICAgICB9XG4gICAgICAhKG5leHRDaGlsZC5wYXJlbnRJRCA9PT0gaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uQmVmb3JlTW91bnRDb21wb25lbnQoKSBwYXJlbnQgYW5kIG9uU2V0Q2hpbGRyZW4oKSB0byBiZSBjb25zaXN0ZW50ICglcyBoYXMgcGFyZW50cyAlcyBhbmQgJXMpLicsIG5leHRDaGlsZElELCBuZXh0Q2hpbGQucGFyZW50SUQsIGlkKSA6IF9wcm9kSW52YXJpYW50KCcxNDInLCBuZXh0Q2hpbGRJRCwgbmV4dENoaWxkLnBhcmVudElELCBpZCkgOiB2b2lkIDA7XG4gICAgfVxuICB9LFxuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQsIGVsZW1lbnQsIHBhcmVudElEKSB7XG4gICAgdmFyIGl0ZW0gPSB7XG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgICAgdGV4dDogbnVsbCxcbiAgICAgIGNoaWxkSURzOiBbXSxcbiAgICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgICB1cGRhdGVDb3VudDogMFxuICAgIH07XG4gICAgc2V0SXRlbShpZCwgaXRlbSk7XG4gIH0sXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoaWQsIGVsZW1lbnQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIGlmICghaXRlbSB8fCAhaXRlbS5pc01vdW50ZWQpIHtcbiAgICAgIC8vIFdlIG1heSBlbmQgdXAgaGVyZSBhcyBhIHJlc3VsdCBvZiBzZXRTdGF0ZSgpIGluIGNvbXBvbmVudFdpbGxVbm1vdW50KCkuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIGlnbm9yZSB0aGUgZWxlbWVudC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXRlbS5lbGVtZW50ID0gZWxlbWVudDtcbiAgfSxcbiAgb25Nb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICAhaXRlbSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJdGVtIG11c3QgaGF2ZSBiZWVuIHNldCcpIDogX3Byb2RJbnZhcmlhbnQoJzE0NCcpIDogdm9pZCAwO1xuICAgIGl0ZW0uaXNNb3VudGVkID0gdHJ1ZTtcbiAgICB2YXIgaXNSb290ID0gaXRlbS5wYXJlbnRJRCA9PT0gMDtcbiAgICBpZiAoaXNSb290KSB7XG4gICAgICBhZGRSb290KGlkKTtcbiAgICB9XG4gIH0sXG4gIG9uVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIGlmICghaXRlbSB8fCAhaXRlbS5pc01vdW50ZWQpIHtcbiAgICAgIC8vIFdlIG1heSBlbmQgdXAgaGVyZSBhcyBhIHJlc3VsdCBvZiBzZXRTdGF0ZSgpIGluIGNvbXBvbmVudFdpbGxVbm1vdW50KCkuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIGlnbm9yZSB0aGUgZWxlbWVudC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXRlbS51cGRhdGVDb3VudCsrO1xuICB9LFxuICBvblVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgaXQgZXhpc3RzLlxuICAgICAgLy8gYGl0ZW1gIG1pZ2h0IG5vdCBleGlzdCBpZiBpdCBpcyBpbnNpZGUgYW4gZXJyb3IgYm91bmRhcnksIGFuZCBhIHNpYmxpbmdcbiAgICAgIC8vIGVycm9yIGJvdW5kYXJ5IGNoaWxkIHRocmV3IHdoaWxlIG1vdW50aW5nLiBUaGVuIHRoaXMgaW5zdGFuY2UgbmV2ZXJcbiAgICAgIC8vIGdvdCBhIGNoYW5jZSB0byBtb3VudCwgYnV0IGl0IHN0aWxsIGdldHMgYW4gdW5tb3VudGluZyBldmVudCBkdXJpbmdcbiAgICAgIC8vIHRoZSBlcnJvciBib3VuZGFyeSBjbGVhbnVwLlxuICAgICAgaXRlbS5pc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBpc1Jvb3QgPSBpdGVtLnBhcmVudElEID09PSAwO1xuICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICByZW1vdmVSb290KGlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdW5tb3VudGVkSURzLnB1c2goaWQpO1xuICB9LFxuICBwdXJnZVVubW91bnRlZENvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RDb21wb25lbnRUcmVlSG9vay5fcHJldmVudFB1cmdpbmcpIHtcbiAgICAgIC8vIFNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHRlc3RpbmcuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bm1vdW50ZWRJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IHVubW91bnRlZElEc1tpXTtcbiAgICAgIHB1cmdlRGVlcChpZCk7XG4gICAgfVxuICAgIHVubW91bnRlZElEcy5sZW5ndGggPSAwO1xuICB9LFxuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmlzTW91bnRlZCA6IGZhbHNlO1xuICB9LFxuICBnZXRDdXJyZW50U3RhY2tBZGRlbmR1bTogZnVuY3Rpb24gKHRvcEVsZW1lbnQpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIGlmICh0b3BFbGVtZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldERpc3BsYXlOYW1lKHRvcEVsZW1lbnQpO1xuICAgICAgdmFyIG93bmVyID0gdG9wRWxlbWVudC5fb3duZXI7XG4gICAgICBpbmZvICs9IGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgdG9wRWxlbWVudC5fc291cmNlLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkpO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50T3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIHZhciBpZCA9IGN1cnJlbnRPd25lciAmJiBjdXJyZW50T3duZXIuX2RlYnVnSUQ7XG5cbiAgICBpbmZvICs9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoaWQpO1xuICAgIHJldHVybiBpbmZvO1xuICB9LFxuICBnZXRTdGFja0FkZGVuZHVtQnlJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB3aGlsZSAoaWQpIHtcbiAgICAgIGluZm8gKz0gZGVzY3JpYmVJRChpZCk7XG4gICAgICBpZCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0UGFyZW50SUQoaWQpO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbztcbiAgfSxcbiAgZ2V0Q2hpbGRJRHM6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmNoaWxkSURzIDogW107XG4gIH0sXG4gIGdldERpc3BsYXlOYW1lOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGdldERpc3BsYXlOYW1lKGVsZW1lbnQpO1xuICB9LFxuICBnZXRFbGVtZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5lbGVtZW50IDogbnVsbDtcbiAgfSxcbiAgZ2V0T3duZXJJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICAgIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudC5fb3duZXIuX2RlYnVnSUQ7XG4gIH0sXG4gIGdldFBhcmVudElEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5wYXJlbnRJRCA6IG51bGw7XG4gIH0sXG4gIGdldFNvdXJjZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICB2YXIgZWxlbWVudCA9IGl0ZW0gPyBpdGVtLmVsZW1lbnQgOiBudWxsO1xuICAgIHZhciBzb3VyY2UgPSBlbGVtZW50ICE9IG51bGwgPyBlbGVtZW50Ll9zb3VyY2UgOiBudWxsO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH0sXG4gIGdldFRleHQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICcnICsgZWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LFxuICBnZXRVcGRhdGVDb3VudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0udXBkYXRlQ291bnQgOiAwO1xuICB9LFxuXG5cbiAgZ2V0Um9vdElEczogZ2V0Um9vdElEcyxcbiAgZ2V0UmVnaXN0ZXJlZElEczogZ2V0SXRlbUlEcyxcblxuICBwdXNoTm9uU3RhbmRhcmRXYXJuaW5nU3RhY2s6IGZ1bmN0aW9uIChpc0NyZWF0aW5nRWxlbWVudCwgY3VycmVudFNvdXJjZSkge1xuICAgIGlmICh0eXBlb2YgY29uc29sZS5yZWFjdFN0YWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIGN1cnJlbnRPd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgdmFyIGlkID0gY3VycmVudE93bmVyICYmIGN1cnJlbnRPd25lci5fZGVidWdJRDtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoaXNDcmVhdGluZ0VsZW1lbnQpIHtcbiAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgbmFtZTogaWQgPyBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGlkKSA6IG51bGwsXG4gICAgICAgICAgZmlsZU5hbWU6IGN1cnJlbnRTb3VyY2UgPyBjdXJyZW50U291cmNlLmZpbGVOYW1lIDogbnVsbCxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBjdXJyZW50U291cmNlID8gY3VycmVudFNvdXJjZS5saW5lTnVtYmVyIDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGlkKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgICAgICAgdmFyIHBhcmVudElEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRQYXJlbnRJRChpZCk7XG4gICAgICAgIHZhciBvd25lcklEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKGlkKTtcbiAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVySUQgPyBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKG93bmVySUQpIDogbnVsbDtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGVsZW1lbnQgJiYgZWxlbWVudC5fc291cmNlO1xuICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBvd25lck5hbWUsXG4gICAgICAgICAgZmlsZU5hbWU6IHNvdXJjZSA/IHNvdXJjZS5maWxlTmFtZSA6IG51bGwsXG4gICAgICAgICAgbGluZU51bWJlcjogc291cmNlID8gc291cmNlLmxpbmVOdW1iZXIgOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBpZCA9IHBhcmVudElEO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSW50ZXJuYWwgc3RhdGUgaXMgbWVzc2VkIHVwLlxuICAgICAgLy8gU3RvcCBidWlsZGluZyB0aGUgc3RhY2sgKGl0J3MganVzdCBhIG5pY2UgdG8gaGF2ZSkuXG4gICAgfVxuXG4gICAgY29uc29sZS5yZWFjdFN0YWNrKHN0YWNrKTtcbiAgfSxcbiAgcG9wTm9uU3RhbmRhcmRXYXJuaW5nU3RhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUucmVhY3RTdGFja0VuZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zb2xlLnJlYWN0U3RhY2tFbmQoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuZnVuY3Rpb24gcmVhY3RQcm9kSW52YXJpYW50KGNvZGUpIHtcbiAgdmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG5cbiAgdmFyIG1lc3NhZ2UgPSAnTWluaWZpZWQgUmVhY3QgZXJyb3IgIycgKyBjb2RlICsgJzsgdmlzaXQgJyArICdodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudD0nICsgY29kZTtcblxuICBmb3IgKHZhciBhcmdJZHggPSAwOyBhcmdJZHggPCBhcmdDb3VudDsgYXJnSWR4KyspIHtcbiAgICBtZXNzYWdlICs9ICcmYXJnc1tdPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2FyZ0lkeCArIDFdKTtcbiAgfVxuXG4gIG1lc3NhZ2UgKz0gJyBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQnICsgJyBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nO1xuXG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IHJlYWN0UHJvZEludmFyaWFudCdzIG93biBmcmFtZVxuXG4gIHRocm93IGVycm9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0UHJvZEludmFyaWFudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEN1cnJlbnRPd25lcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGluZGV4ID0gdGhpcy5faTtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9SZWFjdCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvcmVhY3QuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBET01JdGVyYWJsZXMgPSAoJ0NTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsJyArXG4gICdET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LCcgK1xuICAnTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCwnICtcbiAgJ1NWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LCcgK1xuICAnVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QnKS5zcGxpdCgnLCcpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IERPTUl0ZXJhYmxlcy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IERPTUl0ZXJhYmxlc1tpXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmIChwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IGZhbHNlO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdHJ5IHtcbiAgICAvLyAkRmxvd0ZpeE1lIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4JywgeyBnZXQ6IGZ1bmN0aW9uICgpIHt9IH0pO1xuICAgIGNhbkRlZmluZVByb3BlcnR5ID0gdHJ1ZTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIElFIHdpbGwgZmFpbCBvbiBkZWZpbmVQcm9wZXJ0eVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FuRGVmaW5lUHJvcGVydHk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2NhbkRlZmluZVByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgJGl0ZXJDcmVhdGUgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG52YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTO1xuICB2YXIgVkFMVUVTX0JVRyA9IGZhbHNlO1xuICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcbiAgdmFyICRuYXRpdmUgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF07XG4gIHZhciAkZGVmYXVsdCA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpO1xuICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkO1xuICB2YXIgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmU7XG4gIHZhciBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmICgkYW55TmF0aXZlKSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYgKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSkgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKSB7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7XG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gcHJvdG8pKSByZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJ2YXIgTUVUQSA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBzZXREZXNjID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSkgZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwgeyB2YWx1ZTogd2tzRXh0LmYobmFtZSkgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2xvd1ByaW9yaXR5V2FybmluZy5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKCh0eXBlb2YgY2FsbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoY2FsbCkpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9zZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX3NldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldFByb3RvdHlwZU9mKTtcblxudmFyIF9jcmVhdGUgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpO1xuXG52YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RCYXNlQ2xhc3NlcyA9IHJlcXVpcmUoJy4vUmVhY3RCYXNlQ2xhc3NlcycpO1xudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRyZW4nKTtcbnZhciBSZWFjdERPTUZhY3RvcmllcyA9IHJlcXVpcmUoJy4vUmVhY3RET01GYWN0b3JpZXMnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlcycpO1xudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XG5cbnZhciBjcmVhdGVSZWFjdENsYXNzID0gcmVxdWlyZSgnLi9jcmVhdGVDbGFzcycpO1xudmFyIG9ubHlDaGlsZCA9IHJlcXVpcmUoJy4vb25seUNoaWxkJyk7XG5cbnZhciBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQ7XG52YXIgY3JlYXRlRmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5O1xudmFyIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQ7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSByZXF1aXJlKCcuL2xvd1ByaW9yaXR5V2FybmluZycpO1xuICB2YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG4gIHZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFZhbGlkYXRvcicpO1xuICB2YXIgZGlkV2FyblByb3BUeXBlc0RlcHJlY2F0ZWQgPSBmYWxzZTtcbiAgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50O1xuICBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3Rvcnk7XG4gIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jbG9uZUVsZW1lbnQ7XG59XG5cbnZhciBfX3NwcmVhZCA9IF9hc3NpZ247XG52YXIgY3JlYXRlTWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgcmV0dXJuIG1peGluO1xufTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHdhcm5lZEZvclNwcmVhZCA9IGZhbHNlO1xuICB2YXIgd2FybmVkRm9yQ3JlYXRlTWl4aW4gPSBmYWxzZTtcbiAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgbG93UHJpb3JpdHlXYXJuaW5nKHdhcm5lZEZvclNwcmVhZCwgJ1JlYWN0Ll9fc3ByZWFkIGlzIGRlcHJlY2F0ZWQgYW5kIHNob3VsZCBub3QgYmUgdXNlZC4gVXNlICcgKyAnT2JqZWN0LmFzc2lnbiBkaXJlY3RseSBvciBhbm90aGVyIGhlbHBlciBmdW5jdGlvbiB3aXRoIHNpbWlsYXIgJyArICdzZW1hbnRpY3MuIFlvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8geW91ciBjb21waWxlci4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcHJlYWQtZGVwcmVjYXRpb24gZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgICB3YXJuZWRGb3JTcHJlYWQgPSB0cnVlO1xuICAgIHJldHVybiBfYXNzaWduLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgY3JlYXRlTWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICBsb3dQcmlvcml0eVdhcm5pbmcod2FybmVkRm9yQ3JlYXRlTWl4aW4sICdSZWFjdC5jcmVhdGVNaXhpbiBpcyBkZXByZWNhdGVkIGFuZCBzaG91bGQgbm90IGJlIHVzZWQuICcgKyAnSW4gUmVhY3QgdjE2LjAsIGl0IHdpbGwgYmUgcmVtb3ZlZC4gJyArICdZb3UgY2FuIHVzZSB0aGlzIG1peGluIGRpcmVjdGx5IGluc3RlYWQuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvY3JlYXRlbWl4aW4td2FzLW5ldmVyLWltcGxlbWVudGVkIGZvciBtb3JlIGluZm8uJyk7XG4gICAgd2FybmVkRm9yQ3JlYXRlTWl4aW4gPSB0cnVlO1xuICAgIHJldHVybiBtaXhpbjtcbiAgfTtcbn1cblxudmFyIFJlYWN0ID0ge1xuICAvLyBNb2Rlcm5cblxuICBDaGlsZHJlbjoge1xuICAgIG1hcDogUmVhY3RDaGlsZHJlbi5tYXAsXG4gICAgZm9yRWFjaDogUmVhY3RDaGlsZHJlbi5mb3JFYWNoLFxuICAgIGNvdW50OiBSZWFjdENoaWxkcmVuLmNvdW50LFxuICAgIHRvQXJyYXk6IFJlYWN0Q2hpbGRyZW4udG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBDb21wb25lbnQ6IFJlYWN0QmFzZUNsYXNzZXMuQ29tcG9uZW50LFxuICBQdXJlQ29tcG9uZW50OiBSZWFjdEJhc2VDbGFzc2VzLlB1cmVDb21wb25lbnQsXG5cbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnQsXG4gIGlzVmFsaWRFbGVtZW50OiBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQsXG5cbiAgLy8gQ2xhc3NpY1xuXG4gIFByb3BUeXBlczogUmVhY3RQcm9wVHlwZXMsXG4gIGNyZWF0ZUNsYXNzOiBjcmVhdGVSZWFjdENsYXNzLFxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5LFxuICBjcmVhdGVNaXhpbjogY3JlYXRlTWl4aW4sXG5cbiAgLy8gVGhpcyBsb29rcyBET00gc3BlY2lmaWMgYnV0IHRoZXNlIGFyZSBhY3R1YWxseSBpc29tb3JwaGljIGhlbHBlcnNcbiAgLy8gc2luY2UgdGhleSBhcmUganVzdCBnZW5lcmF0aW5nIERPTSBzdHJpbmdzLlxuICBET006IFJlYWN0RE9NRmFjdG9yaWVzLFxuXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICAvLyBEZXByZWNhdGVkIGhvb2sgZm9yIEpTWCBzcHJlYWQsIGRvbid0IHVzZSB0aGlzIGZvciBhbnl0aGluZy5cbiAgX19zcHJlYWQ6IF9fc3ByZWFkXG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgd2FybmVkRm9yQ3JlYXRlQ2xhc3MgPSBmYWxzZTtcbiAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWN0LCAnUHJvcFR5cGVzJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyhkaWRXYXJuUHJvcFR5cGVzRGVwcmVjYXRlZCwgJ0FjY2Vzc2luZyBQcm9wVHlwZXMgdmlhIHRoZSBtYWluIFJlYWN0IHBhY2thZ2UgaXMgZGVwcmVjYXRlZCwnICsgJyBhbmQgd2lsbCBiZSByZW1vdmVkIGluICBSZWFjdCB2MTYuMC4nICsgJyBVc2UgdGhlIGxhdGVzdCBhdmFpbGFibGUgdjE1LiogcHJvcC10eXBlcyBwYWNrYWdlIGZyb20gbnBtIGluc3RlYWQuJyArICcgRm9yIGluZm8gb24gdXNhZ2UsIGNvbXBhdGliaWxpdHksIG1pZ3JhdGlvbiBhbmQgbW9yZSwgc2VlICcgKyAnaHR0cHM6Ly9mYi5tZS9wcm9wLXR5cGVzLWRvY3MnKTtcbiAgICAgICAgZGlkV2FyblByb3BUeXBlc0RlcHJlY2F0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhY3QsICdjcmVhdGVDbGFzcycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmcod2FybmVkRm9yQ3JlYXRlQ2xhc3MsICdBY2Nlc3NpbmcgY3JlYXRlQ2xhc3MgdmlhIHRoZSBtYWluIFJlYWN0IHBhY2thZ2UgaXMgZGVwcmVjYXRlZCwnICsgJyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IHYxNi4wLicgKyBcIiBVc2UgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzIGluc3RlYWQuIElmIHlvdSdyZSBub3QgeWV0IFwiICsgJ3JlYWR5IHRvIG1pZ3JhdGUsIGNyZWF0ZS1yZWFjdC1jbGFzcyB2MTUuKiBpcyBhdmFpbGFibGUgJyArICdvbiBucG0gYXMgYSB0ZW1wb3JhcnksIGRyb3AtaW4gcmVwbGFjZW1lbnQuICcgKyAnRm9yIG1vcmUgaW5mbyBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1jcmVhdGUtY2xhc3MnKTtcbiAgICAgICAgd2FybmVkRm9yQ3JlYXRlQ2xhc3MgPSB0cnVlO1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVhY3RDbGFzcztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFJlYWN0LkRPTSBmYWN0b3JpZXMgYXJlIGRlcHJlY2F0ZWQuIFdyYXAgdGhlc2UgbWV0aG9kcyBzbyB0aGF0XG4gIC8vIGludm9jYXRpb25zIG9mIHRoZSBSZWFjdC5ET00gbmFtZXNwYWNlIGFuZCBhbGVydCB1c2VycyB0byBzd2l0Y2hcbiAgLy8gdG8gdGhlIGByZWFjdC1kb20tZmFjdG9yaWVzYCBwYWNrYWdlLlxuICBSZWFjdC5ET00gPSB7fTtcbiAgdmFyIHdhcm5lZEZvckZhY3RvcmllcyA9IGZhbHNlO1xuICBPYmplY3Qua2V5cyhSZWFjdERPTUZhY3RvcmllcykuZm9yRWFjaChmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIFJlYWN0LkRPTVtmYWN0b3J5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghd2FybmVkRm9yRmFjdG9yaWVzKSB7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyhmYWxzZSwgJ0FjY2Vzc2luZyBmYWN0b3JpZXMgbGlrZSBSZWFjdC5ET00uJXMgaGFzIGJlZW4gZGVwcmVjYXRlZCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjE2LjArLiBVc2UgdGhlICcgKyAncmVhY3QtZG9tLWZhY3RvcmllcyBwYWNrYWdlIGluc3RlYWQuICcgKyAnIFZlcnNpb24gMS4wIHByb3ZpZGVzIGEgZHJvcC1pbiByZXBsYWNlbWVudC4nICsgJyBGb3IgbW9yZSBpbmZvLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1kb20tZmFjdG9yaWVzJywgZmFjdG9yeSk7XG4gICAgICAgIHdhcm5lZEZvckZhY3RvcmllcyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3RET01GYWN0b3JpZXNbZmFjdG9yeV0uYXBwbHkoUmVhY3RET01GYWN0b3JpZXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9pdGVyYXRvciA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiKTtcblxudmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7XG5cbnZhciBfc3ltYm9sID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sXCIpO1xuXG52YXIgX3N5bWJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2wpO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIF9pdGVyYXRvcjIuZGVmYXVsdCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YoX2l0ZXJhdG9yMi5kZWZhdWx0KSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbmUsIHZhbHVlKSB7XG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSByZXF1aXJlKCcuL2xvd1ByaW9yaXR5V2FybmluZycpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBSZWFjdENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gICEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiBfcHJvZEludmFyaWFudCgnODUnKSA6IHZvaWQgMDtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyhmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gUmVhY3RDb21wb25lbnQuXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBSZWFjdENvbXBvbmVudC5wcm90b3R5cGU7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVhY3RQdXJlQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKFJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSk7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnQsXG4gIFB1cmVDb21wb25lbnQ6IFJlYWN0UHVyZUNvbXBvbmVudFxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RCYXNlQ2xhc3Nlcy5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaykge30sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3ROb29wVXBkYXRlUXVldWUuanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50IHR5cGUuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgfHwgMHhlYWM3O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFbGVtZW50U3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBTeW1ib2wgKi9cblxudmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICpcbiAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICpcbiAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAqICAgICAgIC4uLlxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpdGVyYXRvckZuO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SXRlcmF0b3JGbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0SXRlcmF0b3JGbi5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qKlxuICogUmVhY3RFbGVtZW50VmFsaWRhdG9yIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgYSBlbGVtZW50IGZhY3RvcnlcbiAqIHdoaWNoIHZhbGlkYXRlcyB0aGUgcHJvcHMgcGFzc2VkIHRvIHRoZSBlbGVtZW50LiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG4gKiB1c2VkIG9ubHkgaW4gREVWIGFuZCBjb3VsZCBiZSByZXBsYWNlZCBieSBhIHN0YXRpYyB0eXBlIGNoZWNrZXIgZm9yIGxhbmd1YWdlc1xuICogdGhhdCBzdXBwb3J0IGl0LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgY2hlY2tSZWFjdFR5cGVTcGVjID0gcmVxdWlyZSgnLi9jaGVja1JlYWN0VHlwZVNwZWMnKTtcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IHJlcXVpcmUoJy4vbG93UHJpb3JpdHlXYXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkICYmIGVsZW1lbnRQcm9wcy5fX3NvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNvdXJjZSA9IGVsZW1lbnRQcm9wcy5fX3NvdXJjZTtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICcgQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9ICcgQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgbWVtb2l6ZXIgPSBvd25lckhhc0tleVVzZVdhcm5pbmcudW5pcXVlS2V5IHx8IChvd25lckhhc0tleVVzZVdhcm5pbmcudW5pcXVlS2V5ID0ge30pO1xuXG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcbiAgaWYgKG1lbW9pemVyW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG1lbW9pemVyW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nO1xuICB9XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLiVzJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lciwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDdXJyZW50U3RhY2tBZGRlbmR1bShlbGVtZW50KSkgOiB2b2lkIDA7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgLy8gRW50cnkgaXRlcmF0b3JzIHByb3ZpZGUgaW1wbGljaXQga2V5cy5cbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgY29tcG9uZW50Q2xhc3MgPSBlbGVtZW50LnR5cGU7XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5hbWUgPSBjb21wb25lbnRDbGFzcy5kaXNwbGF5TmFtZSB8fCBjb21wb25lbnRDbGFzcy5uYW1lO1xuICBpZiAoY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzKSB7XG4gICAgY2hlY2tSZWFjdFR5cGVTcGVjKGNvbXBvbmVudENsYXNzLnByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50LCBudWxsKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgfVxufVxuXG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0ge1xuICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShwcm9wcyk7XG4gICAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmZvICs9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW0oKTtcblxuICAgICAgICB2YXIgY3VycmVudFNvdXJjZSA9IHByb3BzICE9PSBudWxsICYmIHByb3BzICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuX19zb3VyY2UgIT09IHVuZGVmaW5lZCA/IHByb3BzLl9fc291cmNlIDogbnVsbDtcbiAgICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vay5wdXNoTm9uU3RhbmRhcmRXYXJuaW5nU3RhY2sodHJ1ZSwgY3VycmVudFNvdXJjZSk7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pIDogdm9pZCAwO1xuICAgICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rLnBvcE5vblN0YW5kYXJkV2FybmluZ1N0YWNrKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICBjcmVhdGVGYWN0b3J5OiBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmcoZmFsc2UsICdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG4gIH0sXG5cbiAgY2xvbmVFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgICB9XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlclxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIGludmFyaWFudChcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsXG4gICAgICAgICAgICAgIHByb3BGdWxsTmFtZSxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJXMgYXQgaW5kZXggJXMuJyxcbiAgICAgICAgICBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlciksXG4gICAgICAgICAgaVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc1xuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIgNSIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qc1xuLy8gbW9kdWxlIGlkID0gOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ25cIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qc1xuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYykge1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDExMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL193a3MtZXh0JykuZignaXRlcmF0b3InKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlN5bWJvbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCkge1xuICByZXR1cm4gJE9iamVjdC5jcmVhdGUoUCwgRCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFJlYWN0IDE1LjUgcmVmZXJlbmNlcyB0aGlzIG1vZHVsZSwgYW5kIGFzc3VtZXMgUHJvcFR5cGVzIGFyZSBzdGlsbCBjYWxsYWJsZSBpbiBwcm9kdWN0aW9uLlxuLy8gVGhlcmVmb3JlIHdlIHJlLWV4cG9ydCBkZXZlbG9wbWVudC1vbmx5IHZlcnNpb24gd2l0aCBhbGwgdGhlIFByb3BUeXBlcyBjaGVja3MgaGVyZS5cbi8vIEhvd2V2ZXIgaWYgb25lIGlzIG1pZ3JhdGluZyB0byB0aGUgYHByb3AtdHlwZXNgIG5wbSBsaWJyYXJ5LCB0aGV5IHdpbGwgZ28gdGhyb3VnaCB0aGVcbi8vIGBpbmRleC5qc2AgZW50cnkgcG9pbnQsIGFuZCBpdCB3aWxsIGJyYW5jaCBkZXBlbmRpbmcgb24gdGhlIGVudmlyb25tZW50LlxudmFyIGZhY3RvcnkgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50KSB7XG4gIC8vIEl0IGlzIHN0aWxsIGFsbG93ZWQgaW4gMTUuNS5cbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSBmYWxzZTtcbiAgcmV0dXJuIGZhY3RvcnkoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc3RyaW5nLWF0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBkZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDUiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5hc3NpZ247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJykgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMTM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDE0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2xcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIE1FVEEgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciB3a3NEZWZpbmUgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJyk7XG52YXIgZW51bUtleXMgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBnT1BORXh0ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0Jyk7XG52YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BEID0gJEdPUEQuZjtcbnZhciBkUCA9ICREUC5mO1xudmFyIGdPUE4gPSBnT1BORXh0LmY7XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgJEpTT04gPSBnbG9iYWwuSlNPTjtcbnZhciBfc3RyaW5naWZ5ID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIEhJRERFTiA9IHdrcygnX2hpZGRlbicpO1xudmFyIFRPX1BSSU1JVElWRSA9IHdrcygndG9QcmltaXRpdmUnKTtcbnZhciBpc0VudW0gPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9QU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgVVNFX05BVElWRSA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbic7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRQKHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZiAocHJvdG9EZXNjKSBkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmIChwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKSBkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpIHtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90bykgJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFELmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzKGl0LCBISURERU4pKSBkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7IGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApIHtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsID4gaSkgJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCkge1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSkge1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgaXQgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYgKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkgRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvO1xuICB2YXIgbmFtZXMgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvKSAkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKSBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXQgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5JykpIHtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFN5bWJvbDogJFN5bWJvbCB9KTtcblxuZm9yICh2YXIgZXM2U3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBqID0gMDsgZXM2U3ltYm9scy5sZW5ndGggPiBqOyl3a3MoZXM2U3ltYm9sc1tqKytdKTtcblxuZm9yICh2YXIgd2VsbEtub3duU3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGsgPSAwOyB3ZWxsS25vd25TeW1ib2xzLmxlbmd0aCA+IGs7KSB3a3NEZWZpbmUod2VsbEtub3duU3ltYm9sc1trKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gU3ltYm9sUmVnaXN0cnkpIGlmIChTeW1ib2xSZWdpc3RyeVtrZXldID09PSBzeW0pIHJldHVybiBrZXk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7IGE6IFMgfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgaWYgKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSAkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICBpZiAoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKCRyZXBsYWNlcikgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMTQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDE0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0IH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1wcm90by5qc1xuLy8gbW9kdWxlIGlkID0gMTUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgY3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJykgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyO1xudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcjtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiB0cmF2ZXJzYWwuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgRm9yRWFjaEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gZm9yRWFjaEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gdHJhdmVyc2FsIHdpdGguXG4gKiBAcGFyYW0gez8qfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gY29udGV4dCB3aXRoLlxuICovXG5mdW5jdGlvbiBGb3JFYWNoQm9va0tlZXBpbmcoZm9yRWFjaEZ1bmN0aW9uLCBmb3JFYWNoQ29udGV4dCkge1xuICB0aGlzLmZ1bmMgPSBmb3JFYWNoRnVuY3Rpb247XG4gIHRoaXMuY29udGV4dCA9IGZvckVhY2hDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbkZvckVhY2hCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZvckVhY2hCb29rS2VlcGluZywgdHdvQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBGb3JFYWNoQm9va0tlZXBpbmcuZ2V0UG9vbGVkKGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgRm9yRWFjaEJvb2tLZWVwaW5nLnJlbGVhc2UodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcbiAqIG1hcHBpbmcuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgTWFwQm9va0tlZXBpbmdcbiAqIEBwYXJhbSB7ISp9IG1hcFJlc3VsdCBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBtYXBGdW5jdGlvbiBGdW5jdGlvbiB0byBwZXJmb3JtIG1hcHBpbmcgd2l0aC5cbiAqIEBwYXJhbSB7Pyp9IG1hcENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIG1hcHBpbmcgd2l0aC5cbiAqL1xuZnVuY3Rpb24gTWFwQm9va0tlZXBpbmcobWFwUmVzdWx0LCBrZXlQcmVmaXgsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIHRoaXMucmVzdWx0ID0gbWFwUmVzdWx0O1xuICB0aGlzLmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgdGhpcy5mdW5jID0gbWFwRnVuY3Rpb247XG4gIHRoaXMuY29udGV4dCA9IG1hcENvbnRleHQ7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuTWFwQm9va0tlZXBpbmcucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVzdWx0ID0gbnVsbDtcbiAgdGhpcy5rZXlQcmVmaXggPSBudWxsO1xuICB0aGlzLmZ1bmMgPSBudWxsO1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLmNvdW50ID0gMDtcbn07XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oTWFwQm9va0tlZXBpbmcsIGZvdXJBcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQoYm9va0tlZXBpbmcsIGNoaWxkLCBjaGlsZEtleSkge1xuICB2YXIgcmVzdWx0ID0gYm9va0tlZXBpbmcucmVzdWx0LFxuICAgICAga2V5UHJlZml4ID0gYm9va0tlZXBpbmcua2V5UHJlZml4LFxuICAgICAgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuXG4gIHZhciBtYXBwZWRDaGlsZCA9IGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG4gIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwobWFwcGVkQ2hpbGQsIHJlc3VsdCwgY2hpbGRLZXksIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gTWFwQm9va0tlZXBpbmcuZ2V0UG9vbGVkKGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgTWFwQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGtleSwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZnVuYywgY29udGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZER1bW15KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuLCBjb250ZXh0KSB7XG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSwgbnVsbCk7XG59XG5cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlYWN0Q2hpbGRyZW4gPSB7XG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbDogbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCxcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gIHRvQXJyYXk6IHRvQXJyYXlcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZHJlbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbi5qc1xuLy8gbW9kdWxlIGlkID0gMTUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXG4gKiByZXF1aXJlIGFjY2Vzc2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBJbiBlYWNoIG9mIHRoZXNlLCBgdGhpc2AgcmVmZXJzIHRvXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXG4gKi9cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChjb3B5RmllbGRzRnJvbSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBjb3B5RmllbGRzRnJvbSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoY29weUZpZWxkc0Zyb20pO1xuICB9XG59O1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMik7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyKTtcbiAgfVxufTtcblxudmFyIHRocmVlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMykge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzKTtcbiAgfVxufTtcblxudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQpO1xuICB9XG59O1xuXG52YXIgc3RhbmRhcmRSZWxlYXNlciA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICAhKGluc3RhbmNlIGluc3RhbmNlb2YgS2xhc3MpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyeWluZyB0byByZWxlYXNlIGFuIGluc3RhbmNlIGludG8gYSBwb29sIG9mIGEgZGlmZmVyZW50IHR5cGUuJykgOiBfcHJvZEludmFyaWFudCgnMjUnKSA6IHZvaWQgMDtcbiAgaW5zdGFuY2UuZGVzdHJ1Y3RvcigpO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCA8IEtsYXNzLnBvb2xTaXplKSB7XG4gICAgS2xhc3MuaW5zdGFuY2VQb29sLnB1c2goaW5zdGFuY2UpO1xuICB9XG59O1xuXG52YXIgREVGQVVMVF9QT09MX1NJWkUgPSAxMDtcbnZhciBERUZBVUxUX1BPT0xFUiA9IG9uZUFyZ3VtZW50UG9vbGVyO1xuXG4vKipcbiAqIEF1Z21lbnRzIGBDb3B5Q29uc3RydWN0b3JgIHRvIGJlIGEgcG9vbGFibGUgY2xhc3MsIGF1Z21lbnRpbmcgb25seSB0aGUgY2xhc3NcbiAqIGl0c2VsZiAoc3RhdGljYWxseSkgbm90IGFkZGluZyBhbnkgcHJvdG90eXBpY2FsIGZpZWxkcy4gQW55IENvcHlDb25zdHJ1Y3RvclxuICogeW91IGdpdmUgdGhpcyBtYXkgaGF2ZSBhIGBwb29sU2l6ZWAgcHJvcGVydHksIGFuZCB3aWxsIGxvb2sgZm9yIGFcbiAqIHByb3RvdHlwaWNhbCBgZGVzdHJ1Y3RvcmAgb24gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENvcHlDb25zdHJ1Y3RvciBDb25zdHJ1Y3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcG9vbGVyIEN1c3RvbWl6YWJsZSBwb29sZXIuXG4gKi9cbnZhciBhZGRQb29saW5nVG8gPSBmdW5jdGlvbiAoQ29weUNvbnN0cnVjdG9yLCBwb29sZXIpIHtcbiAgLy8gQ2FzdGluZyBhcyBhbnkgc28gdGhhdCBmbG93IGlnbm9yZXMgdGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvbiBhbmQgdHJ1c3RzXG4gIC8vIGl0IHRvIG1hdGNoIHRoZSB0eXBlIHdlIGRlY2xhcmVkXG4gIHZhciBOZXdLbGFzcyA9IENvcHlDb25zdHJ1Y3RvcjtcbiAgTmV3S2xhc3MuaW5zdGFuY2VQb29sID0gW107XG4gIE5ld0tsYXNzLmdldFBvb2xlZCA9IHBvb2xlciB8fCBERUZBVUxUX1BPT0xFUjtcbiAgaWYgKCFOZXdLbGFzcy5wb29sU2l6ZSkge1xuICAgIE5ld0tsYXNzLnBvb2xTaXplID0gREVGQVVMVF9QT09MX1NJWkU7XG4gIH1cbiAgTmV3S2xhc3MucmVsZWFzZSA9IHN0YW5kYXJkUmVsZWFzZXI7XG4gIHJldHVybiBOZXdLbGFzcztcbn07XG5cbnZhciBQb29sZWRDbGFzcyA9IHtcbiAgYWRkUG9vbGluZ1RvOiBhZGRQb29saW5nVG8sXG4gIG9uZUFyZ3VtZW50UG9vbGVyOiBvbmVBcmd1bWVudFBvb2xlcixcbiAgdHdvQXJndW1lbnRQb29sZXI6IHR3b0FyZ3VtZW50UG9vbGVyLFxuICB0aHJlZUFyZ3VtZW50UG9vbGVyOiB0aHJlZUFyZ3VtZW50UG9vbGVyLFxuICBmb3VyQXJndW1lbnRQb29sZXI6IGZvdXJBcmd1bWVudFBvb2xlclxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sZWRDbGFzcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanNcbi8vIG1vZHVsZSBpZCA9IDE1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRTeW1ib2wnKTtcblxudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6JztcblxuLyoqXG4gKiBUaGlzIGlzIGlubGluZWQgZnJvbSBSZWFjdEVsZW1lbnQgc2luY2UgdGhpcyBmaWxlIGlzIHNoYXJlZCBiZXR3ZWVuXG4gKiBpc29tb3JwaGljIGFuZCByZW5kZXJlcnMuIFdlIGNvdWxkIGV4dHJhY3QgdGhpcyB0byBhXG4gKlxuICovXG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmIChjb21wb25lbnQgJiYgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIEtleUVzY2FwZVV0aWxzLmVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicgfHxcbiAgLy8gVGhlIGZvbGxvd2luZyBpcyBpbmxpbmVkIGZyb20gUmVhY3RFbGVtZW50LiBUaGlzIG1lYW5zIHdlIGNhbiBvcHRpbWl6ZVxuICAvLyBzb21lIGNoZWNrcy4gUmVhY3QgRmliZXIgYWxzbyBpbmxpbmVzIHRoaXMgbG9naWMgZm9yIHNpbWlsYXIgcHVycG9zZXMuXG4gIHR5cGUgPT09ICdvYmplY3QnICYmIGNoaWxkcmVuLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpaSA9IDA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0gPSAnJztcbiAgICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgICBpZiAobWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUpIHtcbiAgICAgICAgICAgICAgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkLiBJdCBpcyBhbiAnICsgJ2V4cGVyaW1lbnRhbCBmZWF0dXJlIHRoYXQgbWlnaHQgYmUgcmVtb3ZlZC4gQ29udmVydCBpdCB0byBhICcgKyAnc2VxdWVuY2UgLyBpdGVyYWJsZSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIEtleUVzY2FwZVV0aWxzLmVzY2FwZShlbnRyeVswXSkgKyBTVUJTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIDApO1xuICAgICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQgb3Igd3JhcCB0aGUgb2JqZWN0IHVzaW5nIGNyZWF0ZUZyYWdtZW50KG9iamVjdCkgZnJvbSB0aGUgJyArICdSZWFjdCBhZGQtb25zLic7XG4gICAgICAgIGlmIChjaGlsZHJlbi5faXNSZWFjdEVsZW1lbnQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9IFwiIEl0IGxvb2tzIGxpa2UgeW91J3JlIHVzaW5nIGFuIGVsZW1lbnQgY3JlYXRlZCBieSBhIGRpZmZlcmVudCBcIiArICd2ZXJzaW9uIG9mIFJlYWN0LiBNYWtlIHN1cmUgdG8gdXNlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtICs9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKSA6IF9wcm9kSW52YXJpYW50KCczMScsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhdmVyc2VBbGxDaGlsZHJlbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBVbmVzY2FwZSBhbmQgdW53cmFwIGtleSBmb3IgaHVtYW4tcmVhZGFibGUgZGlzcGxheVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gdW5lc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSB1bmVzY2FwZWQga2V5LlxuICovXG5mdW5jdGlvbiB1bmVzY2FwZShrZXkpIHtcbiAgdmFyIHVuZXNjYXBlUmVnZXggPSAvKD0wfD0yKS9nO1xuICB2YXIgdW5lc2NhcGVyTG9va3VwID0ge1xuICAgICc9MCc6ICc9JyxcbiAgICAnPTInOiAnOidcbiAgfTtcbiAgdmFyIGtleVN1YnN0cmluZyA9IGtleVswXSA9PT0gJy4nICYmIGtleVsxXSA9PT0gJyQnID8ga2V5LnN1YnN0cmluZygyKSA6IGtleS5zdWJzdHJpbmcoMSk7XG5cbiAgcmV0dXJuICgnJyArIGtleVN1YnN0cmluZykucmVwbGFjZSh1bmVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG59XG5cbnZhciBLZXlFc2NhcGVVdGlscyA9IHtcbiAgZXNjYXBlOiBlc2NhcGUsXG4gIHVuZXNjYXBlOiB1bmVzY2FwZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlFc2NhcGVVdGlscztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvS2V5RXNjYXBlVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBmYWN0b3J5IHRoYXQgY3JlYXRlcyBIVE1MIHRhZyBlbGVtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgY3JlYXRlRE9NRmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50VmFsaWRhdG9yJyk7XG4gIGNyZWF0ZURPTUZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwcGluZyBmcm9tIHN1cHBvcnRlZCBIVE1MIHRhZ3MgdG8gYFJlYWN0RE9NQ29tcG9uZW50YCBjbGFzc2VzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0ge1xuICBhOiBjcmVhdGVET01GYWN0b3J5KCdhJyksXG4gIGFiYnI6IGNyZWF0ZURPTUZhY3RvcnkoJ2FiYnInKSxcbiAgYWRkcmVzczogY3JlYXRlRE9NRmFjdG9yeSgnYWRkcmVzcycpLFxuICBhcmVhOiBjcmVhdGVET01GYWN0b3J5KCdhcmVhJyksXG4gIGFydGljbGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2FydGljbGUnKSxcbiAgYXNpZGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2FzaWRlJyksXG4gIGF1ZGlvOiBjcmVhdGVET01GYWN0b3J5KCdhdWRpbycpLFxuICBiOiBjcmVhdGVET01GYWN0b3J5KCdiJyksXG4gIGJhc2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2Jhc2UnKSxcbiAgYmRpOiBjcmVhdGVET01GYWN0b3J5KCdiZGknKSxcbiAgYmRvOiBjcmVhdGVET01GYWN0b3J5KCdiZG8nKSxcbiAgYmlnOiBjcmVhdGVET01GYWN0b3J5KCdiaWcnKSxcbiAgYmxvY2txdW90ZTogY3JlYXRlRE9NRmFjdG9yeSgnYmxvY2txdW90ZScpLFxuICBib2R5OiBjcmVhdGVET01GYWN0b3J5KCdib2R5JyksXG4gIGJyOiBjcmVhdGVET01GYWN0b3J5KCdicicpLFxuICBidXR0b246IGNyZWF0ZURPTUZhY3RvcnkoJ2J1dHRvbicpLFxuICBjYW52YXM6IGNyZWF0ZURPTUZhY3RvcnkoJ2NhbnZhcycpLFxuICBjYXB0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdjYXB0aW9uJyksXG4gIGNpdGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NpdGUnKSxcbiAgY29kZTogY3JlYXRlRE9NRmFjdG9yeSgnY29kZScpLFxuICBjb2w6IGNyZWF0ZURPTUZhY3RvcnkoJ2NvbCcpLFxuICBjb2xncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnY29sZ3JvdXAnKSxcbiAgZGF0YTogY3JlYXRlRE9NRmFjdG9yeSgnZGF0YScpLFxuICBkYXRhbGlzdDogY3JlYXRlRE9NRmFjdG9yeSgnZGF0YWxpc3QnKSxcbiAgZGQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2RkJyksXG4gIGRlbDogY3JlYXRlRE9NRmFjdG9yeSgnZGVsJyksXG4gIGRldGFpbHM6IGNyZWF0ZURPTUZhY3RvcnkoJ2RldGFpbHMnKSxcbiAgZGZuOiBjcmVhdGVET01GYWN0b3J5KCdkZm4nKSxcbiAgZGlhbG9nOiBjcmVhdGVET01GYWN0b3J5KCdkaWFsb2cnKSxcbiAgZGl2OiBjcmVhdGVET01GYWN0b3J5KCdkaXYnKSxcbiAgZGw6IGNyZWF0ZURPTUZhY3RvcnkoJ2RsJyksXG4gIGR0OiBjcmVhdGVET01GYWN0b3J5KCdkdCcpLFxuICBlbTogY3JlYXRlRE9NRmFjdG9yeSgnZW0nKSxcbiAgZW1iZWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2VtYmVkJyksXG4gIGZpZWxkc2V0OiBjcmVhdGVET01GYWN0b3J5KCdmaWVsZHNldCcpLFxuICBmaWdjYXB0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdmaWdjYXB0aW9uJyksXG4gIGZpZ3VyZTogY3JlYXRlRE9NRmFjdG9yeSgnZmlndXJlJyksXG4gIGZvb3RlcjogY3JlYXRlRE9NRmFjdG9yeSgnZm9vdGVyJyksXG4gIGZvcm06IGNyZWF0ZURPTUZhY3RvcnkoJ2Zvcm0nKSxcbiAgaDE6IGNyZWF0ZURPTUZhY3RvcnkoJ2gxJyksXG4gIGgyOiBjcmVhdGVET01GYWN0b3J5KCdoMicpLFxuICBoMzogY3JlYXRlRE9NRmFjdG9yeSgnaDMnKSxcbiAgaDQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2g0JyksXG4gIGg1OiBjcmVhdGVET01GYWN0b3J5KCdoNScpLFxuICBoNjogY3JlYXRlRE9NRmFjdG9yeSgnaDYnKSxcbiAgaGVhZDogY3JlYXRlRE9NRmFjdG9yeSgnaGVhZCcpLFxuICBoZWFkZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ2hlYWRlcicpLFxuICBoZ3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ2hncm91cCcpLFxuICBocjogY3JlYXRlRE9NRmFjdG9yeSgnaHInKSxcbiAgaHRtbDogY3JlYXRlRE9NRmFjdG9yeSgnaHRtbCcpLFxuICBpOiBjcmVhdGVET01GYWN0b3J5KCdpJyksXG4gIGlmcmFtZTogY3JlYXRlRE9NRmFjdG9yeSgnaWZyYW1lJyksXG4gIGltZzogY3JlYXRlRE9NRmFjdG9yeSgnaW1nJyksXG4gIGlucHV0OiBjcmVhdGVET01GYWN0b3J5KCdpbnB1dCcpLFxuICBpbnM6IGNyZWF0ZURPTUZhY3RvcnkoJ2lucycpLFxuICBrYmQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2tiZCcpLFxuICBrZXlnZW46IGNyZWF0ZURPTUZhY3RvcnkoJ2tleWdlbicpLFxuICBsYWJlbDogY3JlYXRlRE9NRmFjdG9yeSgnbGFiZWwnKSxcbiAgbGVnZW5kOiBjcmVhdGVET01GYWN0b3J5KCdsZWdlbmQnKSxcbiAgbGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpJyksXG4gIGxpbms6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpbmsnKSxcbiAgbWFpbjogY3JlYXRlRE9NRmFjdG9yeSgnbWFpbicpLFxuICBtYXA6IGNyZWF0ZURPTUZhY3RvcnkoJ21hcCcpLFxuICBtYXJrOiBjcmVhdGVET01GYWN0b3J5KCdtYXJrJyksXG4gIG1lbnU6IGNyZWF0ZURPTUZhY3RvcnkoJ21lbnUnKSxcbiAgbWVudWl0ZW06IGNyZWF0ZURPTUZhY3RvcnkoJ21lbnVpdGVtJyksXG4gIG1ldGE6IGNyZWF0ZURPTUZhY3RvcnkoJ21ldGEnKSxcbiAgbWV0ZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ21ldGVyJyksXG4gIG5hdjogY3JlYXRlRE9NRmFjdG9yeSgnbmF2JyksXG4gIG5vc2NyaXB0OiBjcmVhdGVET01GYWN0b3J5KCdub3NjcmlwdCcpLFxuICBvYmplY3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ29iamVjdCcpLFxuICBvbDogY3JlYXRlRE9NRmFjdG9yeSgnb2wnKSxcbiAgb3B0Z3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ29wdGdyb3VwJyksXG4gIG9wdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnb3B0aW9uJyksXG4gIG91dHB1dDogY3JlYXRlRE9NRmFjdG9yeSgnb3V0cHV0JyksXG4gIHA6IGNyZWF0ZURPTUZhY3RvcnkoJ3AnKSxcbiAgcGFyYW06IGNyZWF0ZURPTUZhY3RvcnkoJ3BhcmFtJyksXG4gIHBpY3R1cmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3BpY3R1cmUnKSxcbiAgcHJlOiBjcmVhdGVET01GYWN0b3J5KCdwcmUnKSxcbiAgcHJvZ3Jlc3M6IGNyZWF0ZURPTUZhY3RvcnkoJ3Byb2dyZXNzJyksXG4gIHE6IGNyZWF0ZURPTUZhY3RvcnkoJ3EnKSxcbiAgcnA6IGNyZWF0ZURPTUZhY3RvcnkoJ3JwJyksXG4gIHJ0OiBjcmVhdGVET01GYWN0b3J5KCdydCcpLFxuICBydWJ5OiBjcmVhdGVET01GYWN0b3J5KCdydWJ5JyksXG4gIHM6IGNyZWF0ZURPTUZhY3RvcnkoJ3MnKSxcbiAgc2FtcDogY3JlYXRlRE9NRmFjdG9yeSgnc2FtcCcpLFxuICBzY3JpcHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3NjcmlwdCcpLFxuICBzZWN0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdzZWN0aW9uJyksXG4gIHNlbGVjdDogY3JlYXRlRE9NRmFjdG9yeSgnc2VsZWN0JyksXG4gIHNtYWxsOiBjcmVhdGVET01GYWN0b3J5KCdzbWFsbCcpLFxuICBzb3VyY2U6IGNyZWF0ZURPTUZhY3RvcnkoJ3NvdXJjZScpLFxuICBzcGFuOiBjcmVhdGVET01GYWN0b3J5KCdzcGFuJyksXG4gIHN0cm9uZzogY3JlYXRlRE9NRmFjdG9yeSgnc3Ryb25nJyksXG4gIHN0eWxlOiBjcmVhdGVET01GYWN0b3J5KCdzdHlsZScpLFxuICBzdWI6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1YicpLFxuICBzdW1tYXJ5OiBjcmVhdGVET01GYWN0b3J5KCdzdW1tYXJ5JyksXG4gIHN1cDogY3JlYXRlRE9NRmFjdG9yeSgnc3VwJyksXG4gIHRhYmxlOiBjcmVhdGVET01GYWN0b3J5KCd0YWJsZScpLFxuICB0Ym9keTogY3JlYXRlRE9NRmFjdG9yeSgndGJvZHknKSxcbiAgdGQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RkJyksXG4gIHRleHRhcmVhOiBjcmVhdGVET01GYWN0b3J5KCd0ZXh0YXJlYScpLFxuICB0Zm9vdDogY3JlYXRlRE9NRmFjdG9yeSgndGZvb3QnKSxcbiAgdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ3RoJyksXG4gIHRoZWFkOiBjcmVhdGVET01GYWN0b3J5KCd0aGVhZCcpLFxuICB0aW1lOiBjcmVhdGVET01GYWN0b3J5KCd0aW1lJyksXG4gIHRpdGxlOiBjcmVhdGVET01GYWN0b3J5KCd0aXRsZScpLFxuICB0cjogY3JlYXRlRE9NRmFjdG9yeSgndHInKSxcbiAgdHJhY2s6IGNyZWF0ZURPTUZhY3RvcnkoJ3RyYWNrJyksXG4gIHU6IGNyZWF0ZURPTUZhY3RvcnkoJ3UnKSxcbiAgdWw6IGNyZWF0ZURPTUZhY3RvcnkoJ3VsJyksXG4gICd2YXInOiBjcmVhdGVET01GYWN0b3J5KCd2YXInKSxcbiAgdmlkZW86IGNyZWF0ZURPTUZhY3RvcnkoJ3ZpZGVvJyksXG4gIHdicjogY3JlYXRlRE9NRmFjdG9yeSgnd2JyJyksXG5cbiAgLy8gU1ZHXG4gIGNpcmNsZTogY3JlYXRlRE9NRmFjdG9yeSgnY2lyY2xlJyksXG4gIGNsaXBQYXRoOiBjcmVhdGVET01GYWN0b3J5KCdjbGlwUGF0aCcpLFxuICBkZWZzOiBjcmVhdGVET01GYWN0b3J5KCdkZWZzJyksXG4gIGVsbGlwc2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2VsbGlwc2UnKSxcbiAgZzogY3JlYXRlRE9NRmFjdG9yeSgnZycpLFxuICBpbWFnZTogY3JlYXRlRE9NRmFjdG9yeSgnaW1hZ2UnKSxcbiAgbGluZTogY3JlYXRlRE9NRmFjdG9yeSgnbGluZScpLFxuICBsaW5lYXJHcmFkaWVudDogY3JlYXRlRE9NRmFjdG9yeSgnbGluZWFyR3JhZGllbnQnKSxcbiAgbWFzazogY3JlYXRlRE9NRmFjdG9yeSgnbWFzaycpLFxuICBwYXRoOiBjcmVhdGVET01GYWN0b3J5KCdwYXRoJyksXG4gIHBhdHRlcm46IGNyZWF0ZURPTUZhY3RvcnkoJ3BhdHRlcm4nKSxcbiAgcG9seWdvbjogY3JlYXRlRE9NRmFjdG9yeSgncG9seWdvbicpLFxuICBwb2x5bGluZTogY3JlYXRlRE9NRmFjdG9yeSgncG9seWxpbmUnKSxcbiAgcmFkaWFsR3JhZGllbnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3JhZGlhbEdyYWRpZW50JyksXG4gIHJlY3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ3JlY3QnKSxcbiAgc3RvcDogY3JlYXRlRE9NRmFjdG9yeSgnc3RvcCcpLFxuICBzdmc6IGNyZWF0ZURPTUZhY3RvcnkoJ3N2ZycpLFxuICB0ZXh0OiBjcmVhdGVET01GYWN0b3J5KCd0ZXh0JyksXG4gIHRzcGFuOiBjcmVhdGVET01GYWN0b3J5KCd0c3BhbicpXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRmFjdG9yaWVzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUZhY3Rvcmllcy5qc1xuLy8gbW9kdWxlIGlkID0gMTU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXG4gIC8vIElubGluZSByZXF1aXJlcyBkb24ndCB3b3JrIHdlbGwgd2l0aCBKZXN0OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzE3OFxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/b2JqZWN0fSBlbGVtZW50IFRoZSBSZWFjdCBlbGVtZW50IHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0gez9udW1iZXJ9IGRlYnVnSUQgVGhlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIHR5cGUtY2hlY2tlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tSZWFjdFR5cGVTcGVjKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCwgZGVidWdJRCkge1xuICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICB2YXIgZXJyb3I7XG4gICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgISh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gUmVhY3QuUHJvcFR5cGVzLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzg0JywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiB2b2lkIDA7XG4gICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgfVxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpIDogdm9pZCAwO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGNvbXBvbmVudFN0YWNrSW5mbyA9ICcnO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKCFSZWFjdENvbXBvbmVudFRyZWVIb29rKSB7XG4gICAgICAgICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWJ1Z0lEICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFja0luZm8gPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDdXJyZW50U3RhY2tBZGRlbmR1bShlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCAlcyB0eXBlOiAlcyVzJywgbG9jYXRpb24sIGVycm9yLm1lc3NhZ2UsIGNvbXBvbmVudFN0YWNrSW5mbykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tSZWFjdFR5cGVTcGVjO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanNcbi8vIG1vZHVsZSBpZCA9IDE1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHtcbiAgICBwcm9wOiAncHJvcCcsXG4gICAgY29udGV4dDogJ2NvbnRleHQnLFxuICAgIGNoaWxkQ29udGV4dDogJ2NoaWxkIGNvbnRleHQnXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qc1xuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50JyksXG4gICAgaXNWYWxpZEVsZW1lbnQgPSBfcmVxdWlyZS5pc1ZhbGlkRWxlbWVudDtcblxudmFyIGZhY3RvcnkgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2ZhY3RvcnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGlzVmFsaWRFbGVtZW50KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbiAgdmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaW52YXJpYW50KHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICdSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lKTtcbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICcxNS42LjEnO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFZlcnNpb24uanNcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL1JlYWN0QmFzZUNsYXNzZXMnKSxcbiAgICBDb21wb25lbnQgPSBfcmVxdWlyZS5Db21wb25lbnQ7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpLFxuICAgIGlzVmFsaWRFbGVtZW50ID0gX3JlcXVpcmUyLmlzVmFsaWRFbGVtZW50O1xuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG52YXIgZmFjdG9yeSA9IHJlcXVpcmUoJ2NyZWF0ZS1yZWFjdC1jbGFzcy9mYWN0b3J5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShDb21wb25lbnQsIGlzVmFsaWRFbGVtZW50LCBSZWFjdE5vb3BVcGRhdGVRdWV1ZSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2NyZWF0ZUNsYXNzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbn1cblxudmFyIE1JWElOU19LRVkgPSAnbWl4aW5zJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFsbG93IHRoZSBjcmVhdGlvbiBvZiBhbm9ueW1vdXMgZnVuY3Rpb25zIHdoaWNoIGRvIG5vdFxuLy8gaGF2ZSAubmFtZSBzZXQgdG8gdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIGJlaW5nIGFzc2lnbmVkIHRvLlxuZnVuY3Rpb24gaWRlbnRpdHkoZm4pIHtcbiAgcmV0dXJuIGZuO1xufVxuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXM7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHtcbiAgICBwcm9wOiAncHJvcCcsXG4gICAgY29udGV4dDogJ2NvbnRleHQnLFxuICAgIGNoaWxkQ29udGV4dDogJ2NoaWxkIGNvbnRleHQnXG4gIH07XG59IGVsc2Uge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBmYWN0b3J5KFJlYWN0Q29tcG9uZW50LCBpc1ZhbGlkRWxlbWVudCwgUmVhY3ROb29wVXBkYXRlUXVldWUpIHtcbiAgLyoqXG4gICAqIFBvbGljaWVzIHRoYXQgZGVzY3JpYmUgbWV0aG9kcyBpbiBgUmVhY3RDbGFzc0ludGVyZmFjZWAuXG4gICAqL1xuXG4gIHZhciBpbmplY3RlZE1peGlucyA9IFtdO1xuXG4gIC8qKlxuICAgKiBDb21wb3NpdGUgY29tcG9uZW50cyBhcmUgaGlnaGVyLWxldmVsIGNvbXBvbmVudHMgdGhhdCBjb21wb3NlIG90aGVyIGNvbXBvc2l0ZVxuICAgKiBvciBob3N0IGNvbXBvbmVudHMuXG4gICAqXG4gICAqIFRvIGNyZWF0ZSBhIG5ldyB0eXBlIG9mIGBSZWFjdENsYXNzYCwgcGFzcyBhIHNwZWNpZmljYXRpb24gb2ZcbiAgICogeW91ciBuZXcgY2xhc3MgdG8gYFJlYWN0LmNyZWF0ZUNsYXNzYC4gVGhlIG9ubHkgcmVxdWlyZW1lbnQgb2YgeW91ciBjbGFzc1xuICAgKiBzcGVjaWZpY2F0aW9uIGlzIHRoYXQgeW91IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC5cbiAgICpcbiAgICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICByZXR1cm4gPGRpdj5IZWxsbyBXb3JsZDwvZGl2PjtcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogVGhlIGNsYXNzIHNwZWNpZmljYXRpb24gc3VwcG9ydHMgYSBzcGVjaWZpYyBwcm90b2NvbCBvZiBtZXRob2RzIHRoYXQgaGF2ZVxuICAgKiBzcGVjaWFsIG1lYW5pbmcgKGUuZy4gYHJlbmRlcmApLiBTZWUgYFJlYWN0Q2xhc3NJbnRlcmZhY2VgIGZvclxuICAgKiBtb3JlIHRoZSBjb21wcmVoZW5zaXZlIHByb3RvY29sLiBBbnkgb3RoZXIgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBpbiB0aGVcbiAgICogY2xhc3Mgc3BlY2lmaWNhdGlvbiB3aWxsIGJlIGF2YWlsYWJsZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgKlxuICAgKiBAaW50ZXJmYWNlIFJlYWN0Q2xhc3NJbnRlcmZhY2VcbiAgICogQGludGVybmFsXG4gICAqL1xuICB2YXIgUmVhY3RDbGFzc0ludGVyZmFjZSA9IHtcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBNaXhpbiBvYmplY3RzIHRvIGluY2x1ZGUgd2hlbiBkZWZpbmluZyB5b3VyIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBtaXhpbnM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRoYXQgc2hvdWxkIGJlIGRlZmluZWQgb25cbiAgICAgKiB0aGUgY29tcG9uZW50J3MgY29uc3RydWN0b3IgaW5zdGVhZCBvZiBpdHMgcHJvdG90eXBlIChzdGF0aWMgbWV0aG9kcykuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIHN0YXRpY3M6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbml0aW9uIG9mIHByb3AgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBwcm9wVHlwZXM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb250ZXh0VHlwZXM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgdGhpcyBjb21wb25lbnQgc2V0cyBmb3IgaXRzIGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjaGlsZENvbnRleHRUeXBlczogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8vID09PT0gRGVmaW5pdGlvbiBtZXRob2RzID09PT1cblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFZhbHVlcyBpbiB0aGUgbWFwcGluZyB3aWxsIGJlIHNldCBvblxuICAgICAqIGB0aGlzLnByb3BzYCBpZiB0aGF0IHByb3AgaXMgbm90IHNwZWNpZmllZCAoaS5lLiB1c2luZyBhbiBgaW5gIGNoZWNrKS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYmVmb3JlIGBnZXRJbml0aWFsU3RhdGVgIGFuZCB0aGVyZWZvcmUgY2Fubm90IHJlbHlcbiAgICAgKiBvbiBgdGhpcy5zdGF0ZWAgb3IgdXNlIGB0aGlzLnNldFN0YXRlYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBnZXREZWZhdWx0UHJvcHM6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBvbmNlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAgICogYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgYHRoaXMuc3RhdGVgLlxuICAgICAqXG4gICAgICogICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICByZXR1cm4ge1xuICAgICAqICAgICAgIGlzT246IGZhbHNlLFxuICAgICAqICAgICAgIGZvb0JhejogbmV3IEJhekZvbygpXG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBnZXRJbml0aWFsU3RhdGU6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGdldENoaWxkQ29udGV4dDogJ0RFRklORV9NQU5ZX01FUkdFRCcsXG5cbiAgICAvKipcbiAgICAgKiBVc2VzIHByb3BzIGZyb20gYHRoaXMucHJvcHNgIGFuZCBzdGF0ZSBmcm9tIGB0aGlzLnN0YXRlYCB0byByZW5kZXIgdGhlXG4gICAgICogc3RydWN0dXJlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBObyBndWFyYW50ZWVzIGFyZSBtYWRlIGFib3V0IHdoZW4gb3IgaG93IG9mdGVuIHRoaXMgbWV0aG9kIGlzIGludm9rZWQsIHNvXG4gICAgICogaXQgbXVzdCBub3QgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gICAgICpcbiAgICAgKiAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuICAgICAqICAgICByZXR1cm4gPGRpdj5IZWxsbywge25hbWV9ITwvZGl2PjtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICAgICAqIEByZXF1aXJlZFxuICAgICAqL1xuICAgIHJlbmRlcjogJ0RFRklORV9PTkNFJyxcblxuICAgIC8vID09PT0gRGVsZWdhdGUgbWV0aG9kcyA9PT09XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBpbml0aWFsbHkgY3JlYXRlZCBhbmQgYWJvdXQgdG8gYmUgbW91bnRlZC5cbiAgICAgKiBUaGlzIG1heSBoYXZlIHNpZGUgZWZmZWN0cywgYnV0IGFueSBleHRlcm5hbCBzdWJzY3JpcHRpb25zIG9yIGRhdGEgY3JlYXRlZFxuICAgICAqIGJ5IHRoaXMgbWV0aG9kIG11c3QgYmUgY2xlYW5lZCB1cCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgLlxuICAgICAqXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbE1vdW50OiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCBhbmQgaGFzIGEgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEhvd2V2ZXIsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBET00gbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgICAqIGJlZW4gbW91bnRlZCAoaW5pdGlhbGl6ZWQgYW5kIHJlbmRlcmVkKSBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZE1vdW50OiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCByZWNlaXZlcyBuZXcgcHJvcHMuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byByZWFjdCB0byBhIHByb3AgdHJhbnNpdGlvbiBieSB1cGRhdGluZyB0aGVcbiAgICAgKiBzdGF0ZSB1c2luZyBgdGhpcy5zZXRTdGF0ZWAuIEN1cnJlbnQgcHJvcHMgYXJlIGFjY2Vzc2VkIHZpYSBgdGhpcy5wcm9wc2AuXG4gICAgICpcbiAgICAgKiAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICAgKiAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICogICAgICAgbGlrZXNJbmNyZWFzaW5nOiBuZXh0UHJvcHMubGlrZUNvdW50ID4gdGhpcy5wcm9wcy5saWtlQ291bnRcbiAgICAgKiAgICAgfSk7XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGVyZSBpcyBubyBlcXVpdmFsZW50IGBjb21wb25lbnRXaWxsUmVjZWl2ZVN0YXRlYC4gQW4gaW5jb21pbmcgcHJvcFxuICAgICAqIHRyYW5zaXRpb24gbWF5IGNhdXNlIGEgc3RhdGUgY2hhbmdlLCBidXQgdGhlIG9wcG9zaXRlIGlzIG5vdCB0cnVlLiBJZiB5b3VcbiAgICAgKiBuZWVkIGl0LCB5b3UgYXJlIHByb2JhYmx5IGxvb2tpbmcgZm9yIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGlsZSBkZWNpZGluZyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSB1cGRhdGVkIGFzIGEgcmVzdWx0IG9mXG4gICAgICogcmVjZWl2aW5nIG5ldyBwcm9wcywgc3RhdGUgYW5kL29yIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBgcmV0dXJuIGZhbHNlYCB3aGVuIHlvdSdyZSBjZXJ0YWluIHRoYXQgdGhlXG4gICAgICogdHJhbnNpdGlvbiB0byB0aGUgbmV3IHByb3BzL3N0YXRlL2NvbnRleHQgd2lsbCBub3QgcmVxdWlyZSBhIGNvbXBvbmVudFxuICAgICAqIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgICAgKiAgICAgcmV0dXJuICFlcXVhbChuZXh0UHJvcHMsIHRoaXMucHJvcHMpIHx8XG4gICAgICogICAgICAgIWVxdWFsKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkgfHxcbiAgICAgKiAgICAgICAhZXF1YWwobmV4dENvbnRleHQsIHRoaXMuY29udGV4dCk7XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29tcG9uZW50IHNob3VsZCB1cGRhdGUuXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiAnREVGSU5FX09OQ0UnLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gdXBkYXRlIGR1ZSB0byBhIHRyYW5zaXRpb24gZnJvbVxuICAgICAqIGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YCB0byBgbmV4dFByb3BzYCwgYG5leHRTdGF0ZWBcbiAgICAgKiBhbmQgYG5leHRDb250ZXh0YC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHBlcmZvcm0gcHJlcGFyYXRpb24gYmVmb3JlIGFuIHVwZGF0ZSBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBOT1RFOiBZb3UgKipjYW5ub3QqKiB1c2UgYHRoaXMuc2V0U3RhdGUoKWAgaW4gdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxVcGRhdGU6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCdzIERPTSByZXByZXNlbnRhdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICAgKiBiZWVuIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJldlByb3BzXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2U3RhdGVcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDb250ZXh0XG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRVcGRhdGU6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBhbmQgaGF2ZVxuICAgICAqIGl0cyBET00gcmVwcmVzZW50YXRpb24gZGVzdHJveWVkLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gZGVhbGxvY2F0ZSBhbnkgZXh0ZXJuYWwgcmVzb3VyY2VzLlxuICAgICAqXG4gICAgICogTk9URTogVGhlcmUgaXMgbm8gYGNvbXBvbmVudERpZFVubW91bnRgIHNpbmNlIHlvdXIgY29tcG9uZW50IHdpbGwgaGF2ZSBiZWVuXG4gICAgICogZGVzdHJveWVkIGJ5IHRoYXQgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8vID09PT0gQWR2YW5jZWQgbWV0aG9kcyA9PT09XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQncyBjdXJyZW50bHkgbW91bnRlZCBET00gcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAb3ZlcnJpZGFibGVcbiAgICAgKi9cbiAgICB1cGRhdGVDb21wb25lbnQ6ICdPVkVSUklERV9CQVNFJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gY2xhc3Mgc3BlY2lmaWNhdGlvbiBrZXlzIHRvIHNwZWNpYWwgcHJvY2Vzc2luZyBmdW5jdGlvbnMuXG4gICAqXG4gICAqIEFsdGhvdWdoIHRoZXNlIGFyZSBkZWNsYXJlZCBsaWtlIGluc3RhbmNlIHByb3BlcnRpZXMgaW4gdGhlIHNwZWNpZmljYXRpb25cbiAgICogd2hlbiBkZWZpbmluZyBjbGFzc2VzIHVzaW5nIGBSZWFjdC5jcmVhdGVDbGFzc2AsIHRoZXkgYXJlIGFjdHVhbGx5IHN0YXRpY1xuICAgKiBhbmQgYXJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgdGhlIHByb3RvdHlwZS4gRGVzcGl0ZVxuICAgKiBiZWluZyBzdGF0aWMsIHRoZXkgbXVzdCBiZSBkZWZpbmVkIG91dHNpZGUgb2YgdGhlIFwic3RhdGljc1wiIGtleSB1bmRlclxuICAgKiB3aGljaCBhbGwgb3RoZXIgc3RhdGljIG1ldGhvZHMgYXJlIGRlZmluZWQuXG4gICAqL1xuICB2YXIgUkVTRVJWRURfU1BFQ19LRVlTID0ge1xuICAgIGRpc3BsYXlOYW1lOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgZGlzcGxheU5hbWUpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgfSxcbiAgICBtaXhpbnM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBtaXhpbnMpIHtcbiAgICAgIGlmIChtaXhpbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgbWl4aW5zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2hpbGRDb250ZXh0VHlwZXM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcywgJ2NoaWxkQ29udGV4dCcpO1xuICAgICAgfVxuICAgICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPSBfYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMsXG4gICAgICAgIGNoaWxkQ29udGV4dFR5cGVzXG4gICAgICApO1xuICAgIH0sXG4gICAgY29udGV4dFR5cGVzOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcywgJ2NvbnRleHQnKTtcbiAgICAgIH1cbiAgICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyA9IF9hc3NpZ24oXG4gICAgICAgIHt9LFxuICAgICAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMsXG4gICAgICAgIGNvbnRleHRUeXBlc1xuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuICAgICAqIGF1dG9tYXRpYyBtZXJnaW5nLlxuICAgICAqL1xuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIGdldERlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihcbiAgICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMsXG4gICAgICAgICAgZ2V0RGVmYXVsdFByb3BzXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHM7XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wVHlwZXM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzLCAncHJvcCcpO1xuICAgICAgfVxuICAgICAgQ29uc3RydWN0b3IucHJvcFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IucHJvcFR5cGVzLCBwcm9wVHlwZXMpO1xuICAgIH0sXG4gICAgc3RhdGljczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICAgIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKTtcbiAgICB9LFxuICAgIGF1dG9iaW5kOiBmdW5jdGlvbigpIHt9XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCB0eXBlRGVmLCBsb2NhdGlvbikge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHR5cGVEZWYpIHtcbiAgICAgIGlmICh0eXBlRGVmLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAvLyB1c2UgYSB3YXJuaW5nIGluc3RlYWQgb2YgYW4gX2ludmFyaWFudCBzbyBjb21wb25lbnRzXG4gICAgICAgIC8vIGRvbid0IHNob3cgdXAgaW4gcHJvZCBidXQgb25seSBpbiBfX0RFVl9fXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgIHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgK1xuICAgICAgICAgICAgICAnUmVhY3QuUHJvcFR5cGVzLicsXG4gICAgICAgICAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsXG4gICAgICAgICAgICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sXG4gICAgICAgICAgICBwcm9wTmFtZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpIHtcbiAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgID8gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXVxuICAgICAgOiBudWxsO1xuXG4gICAgLy8gRGlzYWxsb3cgb3ZlcnJpZGluZyBvZiBiYXNlIGNsYXNzIG1ldGhvZHMgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgICBpZiAoUmVhY3RDbGFzc01peGluLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBfaW52YXJpYW50KFxuICAgICAgICBzcGVjUG9saWN5ID09PSAnT1ZFUlJJREVfQkFTRScsXG4gICAgICAgICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gb3ZlcnJpZGUgJyArXG4gICAgICAgICAgJ2Alc2AgZnJvbSB5b3VyIGNsYXNzIHNwZWNpZmljYXRpb24uIEVuc3VyZSB0aGF0IHlvdXIgbWV0aG9kIG5hbWVzICcgK1xuICAgICAgICAgICdkbyBub3Qgb3ZlcmxhcCB3aXRoIFJlYWN0IG1ldGhvZHMuJyxcbiAgICAgICAgbmFtZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEaXNhbGxvdyBkZWZpbmluZyBtZXRob2RzIG1vcmUgdGhhbiBvbmNlIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgIHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWScgfHwgc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZX01FUkdFRCcsXG4gICAgICAgICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgK1xuICAgICAgICAgICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgJyArXG4gICAgICAgICAgJ3RvIGEgbWl4aW4uJyxcbiAgICAgICAgbmFtZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWl4aW4gaGVscGVyIHdoaWNoIGhhbmRsZXMgcG9saWN5IHZhbGlkYXRpb24gYW5kIHJlc2VydmVkXG4gICAqIHNwZWNpZmljYXRpb24ga2V5cyB3aGVuIGJ1aWxkaW5nIFJlYWN0IGNsYXNzZXMuXG4gICAqL1xuICBmdW5jdGlvbiBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYykge1xuICAgIGlmICghc3BlYykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHR5cGVvZlNwZWMgPSB0eXBlb2Ygc3BlYztcbiAgICAgICAgdmFyIGlzTWl4aW5WYWxpZCA9IHR5cGVvZlNwZWMgPT09ICdvYmplY3QnICYmIHNwZWMgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgaXNNaXhpblZhbGlkLFxuICAgICAgICAgICAgXCIlczogWW91J3JlIGF0dGVtcHRpbmcgdG8gaW5jbHVkZSBhIG1peGluIHRoYXQgaXMgZWl0aGVyIG51bGwgXCIgK1xuICAgICAgICAgICAgICAnb3Igbm90IGFuIG9iamVjdC4gQ2hlY2sgdGhlIG1peGlucyBpbmNsdWRlZCBieSB0aGUgY29tcG9uZW50LCAnICtcbiAgICAgICAgICAgICAgJ2FzIHdlbGwgYXMgYW55IG1peGlucyB0aGV5IGluY2x1ZGUgdGhlbXNlbHZlcy4gJyArXG4gICAgICAgICAgICAgICdFeHBlY3RlZCBvYmplY3QgYnV0IGdvdCAlcy4nLFxuICAgICAgICAgICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLFxuICAgICAgICAgICAgc3BlYyA9PT0gbnVsbCA/IG51bGwgOiB0eXBlb2ZTcGVjXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX2ludmFyaWFudChcbiAgICAgIHR5cGVvZiBzcGVjICE9PSAnZnVuY3Rpb24nLFxuICAgICAgXCJSZWFjdENsYXNzOiBZb3UncmUgYXR0ZW1wdGluZyB0byBcIiArXG4gICAgICAgICd1c2UgYSBjb21wb25lbnQgY2xhc3Mgb3IgZnVuY3Rpb24gYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSAnICtcbiAgICAgICAgJ3JlZ3VsYXIgb2JqZWN0LidcbiAgICApO1xuICAgIF9pbnZhcmlhbnQoXG4gICAgICAhaXNWYWxpZEVsZW1lbnQoc3BlYyksXG4gICAgICBcIlJlYWN0Q2xhc3M6IFlvdSdyZSBhdHRlbXB0aW5nIHRvIFwiICtcbiAgICAgICAgJ3VzZSBhIGNvbXBvbmVudCBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LidcbiAgICApO1xuXG4gICAgdmFyIHByb3RvID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIHZhciBhdXRvQmluZFBhaXJzID0gcHJvdG8uX19yZWFjdEF1dG9CaW5kUGFpcnM7XG5cbiAgICAvLyBCeSBoYW5kbGluZyBtaXhpbnMgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzLCB3ZSBlbnN1cmUgdGhlIHNhbWVcbiAgICAvLyBjaGFpbmluZyBvcmRlciBpcyBhcHBsaWVkIHRvIG1ldGhvZHMgd2l0aCBERUZJTkVfTUFOWSBwb2xpY3ksIHdoZXRoZXJcbiAgICAvLyBtaXhpbnMgYXJlIGxpc3RlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlc2UgbWV0aG9kcyBpbiB0aGUgc3BlYy5cbiAgICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShNSVhJTlNfS0VZKSkge1xuICAgICAgUkVTRVJWRURfU1BFQ19LRVlTLm1peGlucyhDb25zdHJ1Y3Rvciwgc3BlYy5taXhpbnMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3BlYykge1xuICAgICAgaWYgKCFzcGVjLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gTUlYSU5TX0tFWSkge1xuICAgICAgICAvLyBXZSBoYXZlIGFscmVhZHkgaGFuZGxlZCBtaXhpbnMgaW4gYSBzcGVjaWFsIGNhc2UgYWJvdmUuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcGVydHkgPSBzcGVjW25hbWVdO1xuICAgICAgdmFyIGlzQWxyZWFkeURlZmluZWQgPSBwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSk7XG5cbiAgICAgIGlmIChSRVNFUlZFRF9TUEVDX0tFWVMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgUkVTRVJWRURfU1BFQ19LRVlTW25hbWVdKENvbnN0cnVjdG9yLCBwcm9wZXJ0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZXR1cCBtZXRob2RzIG9uIHByb3RvdHlwZTpcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBtZW1iZXIgbWV0aG9kcyBzaG91bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgYm91bmQ6XG4gICAgICAgIC8vIDEuIEV4cGVjdGVkIFJlYWN0Q2xhc3MgbWV0aG9kcyAoaW4gdGhlIFwiaW50ZXJmYWNlXCIpLlxuICAgICAgICAvLyAyLiBPdmVycmlkZGVuIG1ldGhvZHMgKHRoYXQgd2VyZSBtaXhlZCBpbikuXG4gICAgICAgIHZhciBpc1JlYWN0Q2xhc3NNZXRob2QgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgdmFyIHNob3VsZEF1dG9CaW5kID1cbiAgICAgICAgICBpc0Z1bmN0aW9uICYmXG4gICAgICAgICAgIWlzUmVhY3RDbGFzc01ldGhvZCAmJlxuICAgICAgICAgICFpc0FscmVhZHlEZWZpbmVkICYmXG4gICAgICAgICAgc3BlYy5hdXRvYmluZCAhPT0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNob3VsZEF1dG9CaW5kKSB7XG4gICAgICAgICAgYXV0b0JpbmRQYWlycy5wdXNoKG5hbWUsIHByb3BlcnR5KTtcbiAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV07XG5cbiAgICAgICAgICAgIC8vIFRoZXNlIGNhc2VzIHNob3VsZCBhbHJlYWR5IGJlIGNhdWdodCBieSB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlLlxuICAgICAgICAgICAgX2ludmFyaWFudChcbiAgICAgICAgICAgICAgaXNSZWFjdENsYXNzTWV0aG9kICYmXG4gICAgICAgICAgICAgICAgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnIHx8XG4gICAgICAgICAgICAgICAgICBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknKSxcbiAgICAgICAgICAgICAgJ1JlYWN0Q2xhc3M6IFVuZXhwZWN0ZWQgc3BlYyBwb2xpY3kgJXMgZm9yIGtleSAlcyAnICtcbiAgICAgICAgICAgICAgICAnd2hlbiBtaXhpbmcgaW4gY29tcG9uZW50IHNwZWNzLicsXG4gICAgICAgICAgICAgIHNwZWNQb2xpY3ksXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEZvciBtZXRob2RzIHdoaWNoIGFyZSBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlLCBjYWxsIHRoZSBleGlzdGluZ1xuICAgICAgICAgICAgLy8gbWV0aG9kcyBiZWZvcmUgY2FsbGluZyB0aGUgbmV3IHByb3BlcnR5LCBtZXJnaW5nIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgICAgaWYgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJykge1xuICAgICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gQWRkIHZlcmJvc2UgZGlzcGxheU5hbWUgdG8gdGhlIGZ1bmN0aW9uLCB3aGljaCBoZWxwcyB3aGVuIGxvb2tpbmdcbiAgICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIHNwZWMuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgICBwcm90b1tuYW1lXS5kaXNwbGF5TmFtZSA9IHNwZWMuZGlzcGxheU5hbWUgKyAnXycgKyBuYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICBpZiAoIXN0YXRpY3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgbmFtZSBpbiBzdGF0aWNzKSB7XG4gICAgICB2YXIgcHJvcGVydHkgPSBzdGF0aWNzW25hbWVdO1xuICAgICAgaWYgKCFzdGF0aWNzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNSZXNlcnZlZCA9IG5hbWUgaW4gUkVTRVJWRURfU1BFQ19LRVlTO1xuICAgICAgX2ludmFyaWFudChcbiAgICAgICAgIWlzUmVzZXJ2ZWQsXG4gICAgICAgICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGEgcmVzZXJ2ZWQgJyArXG4gICAgICAgICAgJ3Byb3BlcnR5LCBgJXNgLCB0aGF0IHNob3VsZG5cXCd0IGJlIG9uIHRoZSBcInN0YXRpY3NcIiBrZXkuIERlZmluZSBpdCAnICtcbiAgICAgICAgICAnYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgaW5zdGVhZDsgaXQgd2lsbCBzdGlsbCBiZSBhY2Nlc3NpYmxlIG9uIHRoZSAnICtcbiAgICAgICAgICAnY29uc3RydWN0b3IuJyxcbiAgICAgICAgbmFtZVxuICAgICAgKTtcblxuICAgICAgdmFyIGlzSW5oZXJpdGVkID0gbmFtZSBpbiBDb25zdHJ1Y3RvcjtcbiAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgICFpc0luaGVyaXRlZCxcbiAgICAgICAgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgJyArXG4gICAgICAgICAgJ2Alc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlICcgK1xuICAgICAgICAgICdkdWUgdG8gYSBtaXhpbi4nLFxuICAgICAgICBuYW1lXG4gICAgICApO1xuICAgICAgQ29uc3RydWN0b3JbbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgdHdvIG9iamVjdHMsIGJ1dCB0aHJvdyBpZiBib3RoIGNvbnRhaW4gdGhlIHNhbWUga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb25lIFRoZSBmaXJzdCBvYmplY3QsIHdoaWNoIGlzIG11dGF0ZWQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0d28gVGhlIHNlY29uZCBvYmplY3RcbiAgICogQHJldHVybiB7b2JqZWN0fSBvbmUgYWZ0ZXIgaXQgaGFzIGJlZW4gbXV0YXRlZCB0byBjb250YWluIGV2ZXJ5dGhpbmcgaW4gdHdvLlxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhvbmUsIHR3bykge1xuICAgIF9pbnZhcmlhbnQoXG4gICAgICBvbmUgJiYgdHdvICYmIHR5cGVvZiBvbmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0d28gPT09ICdvYmplY3QnLFxuICAgICAgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogQ2Fubm90IG1lcmdlIG5vbi1vYmplY3RzLidcbiAgICApO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHR3bykge1xuICAgICAgaWYgKHR3by5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgICAgb25lW2tleV0gPT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiAnICtcbiAgICAgICAgICAgICdUcmllZCB0byBtZXJnZSB0d28gb2JqZWN0cyB3aXRoIHRoZSBzYW1lIGtleTogYCVzYC4gVGhpcyBjb25mbGljdCAnICtcbiAgICAgICAgICAgICdtYXkgYmUgZHVlIHRvIGEgbWl4aW47IGluIHBhcnRpY3VsYXIsIHRoaXMgbWF5IGJlIGNhdXNlZCBieSB0d28gJyArXG4gICAgICAgICAgICAnZ2V0SW5pdGlhbFN0YXRlKCkgb3IgZ2V0RGVmYXVsdFByb3BzKCkgbWV0aG9kcyByZXR1cm5pbmcgb2JqZWN0cyAnICtcbiAgICAgICAgICAgICd3aXRoIGNsYXNoaW5nIGtleXMuJyxcbiAgICAgICAgICBrZXlcbiAgICAgICAgKTtcbiAgICAgICAgb25lW2tleV0gPSB0d29ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIG1lcmdlcyB0aGVpciByZXR1cm4gdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZFJlc3VsdCgpIHtcbiAgICAgIHZhciBhID0gb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB2YXIgYiA9IHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgICAgdmFyIGMgPSB7fTtcbiAgICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYSk7XG4gICAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGIpO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIGlnbm9yZXMgdGhlaXIgcmV0dXJuIHZhbGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbihvbmUsIHR3bykge1xuICAgIHJldHVybiBmdW5jdGlvbiBjaGFpbmVkRnVuY3Rpb24oKSB7XG4gICAgICBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgYSBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgTWV0aG9kIHRvIGJlIGJvdW5kLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGJvdW5kIG1ldGhvZC5cbiAgICovXG4gIGZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCkge1xuICAgIHZhciBib3VuZE1ldGhvZCA9IG1ldGhvZC5iaW5kKGNvbXBvbmVudCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBudWxsO1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuY29uc3RydWN0b3IuZGlzcGxheU5hbWU7XG4gICAgICB2YXIgX2JpbmQgPSBib3VuZE1ldGhvZC5iaW5kO1xuICAgICAgYm91bmRNZXRob2QuYmluZCA9IGZ1bmN0aW9uKG5ld1RoaXMpIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLFxuICAgICAgICAgICAgX2tleSA9IDE7XG4gICAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgICAgX2tleSsrXG4gICAgICAgICkge1xuICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlciBpcyB0cnlpbmcgdG8gYmluZCgpIGFuIGF1dG9ib3VuZCBtZXRob2Q7IHdlIGVmZmVjdGl2ZWx5IHdpbGxcbiAgICAgICAgLy8gaWdub3JlIHRoZSB2YWx1ZSBvZiBcInRoaXNcIiB0aGF0IHRoZSB1c2VyIGlzIHRyeWluZyB0byB1c2UsIHNvXG4gICAgICAgIC8vIGxldCdzIHdhcm4uXG4gICAgICAgIGlmIChuZXdUaGlzICE9PSBjb21wb25lbnQgJiYgbmV3VGhpcyAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ2JpbmQoKTogUmVhY3QgY29tcG9uZW50IG1ldGhvZHMgbWF5IG9ubHkgYmUgYm91bmQgdG8gdGhlICcgK1xuICAgICAgICAgICAgICAgICdjb21wb25lbnQgaW5zdGFuY2UuIFNlZSAlcycsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ2JpbmQoKTogWW91IGFyZSBiaW5kaW5nIGEgY29tcG9uZW50IG1ldGhvZCB0byB0aGUgY29tcG9uZW50LiAnICtcbiAgICAgICAgICAgICAgICAnUmVhY3QgZG9lcyB0aGlzIGZvciB5b3UgYXV0b21hdGljYWxseSBpbiBhIGhpZ2gtcGVyZm9ybWFuY2UgJyArXG4gICAgICAgICAgICAgICAgJ3dheSwgc28geW91IGNhbiBzYWZlbHkgcmVtb3ZlIHRoaXMgY2FsbC4gU2VlICVzJyxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWJvdW5kTWV0aG9kID0gX2JpbmQuYXBwbHkoYm91bmRNZXRob2QsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gYXJncztcbiAgICAgICAgcmV0dXJuIHJlYm91bmRNZXRob2Q7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYm91bmRNZXRob2Q7XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgYWxsIGF1dG8tYm91bmQgbWV0aG9kcyBpbiBhIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICAgKi9cbiAgZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kcyhjb21wb25lbnQpIHtcbiAgICB2YXIgcGFpcnMgPSBjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kUGFpcnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIGF1dG9CaW5kS2V5ID0gcGFpcnNbaV07XG4gICAgICB2YXIgbWV0aG9kID0gcGFpcnNbaSArIDFdO1xuICAgICAgY29tcG9uZW50W2F1dG9CaW5kS2V5XSA9IGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIElzTW91bnRlZFByZU1peGluID0ge1xuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX19pc01vdW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgSXNNb3VudGVkUG9zdE1peGluID0ge1xuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX19pc01vdW50ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBtb3JlIHRvIHRoZSBSZWFjdENsYXNzIGJhc2UgY2xhc3MuIFRoZXNlIGFyZSBhbGwgbGVnYWN5IGZlYXR1cmVzIGFuZFxuICAgKiB0aGVyZWZvcmUgbm90IGFscmVhZHkgcGFydCBvZiB0aGUgbW9kZXJuIFJlYWN0Q29tcG9uZW50LlxuICAgKi9cbiAgdmFyIFJlYWN0Q2xhc3NNaXhpbiA9IHtcbiAgICAvKipcbiAgICAgKiBUT0RPOiBUaGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBiZWNhdXNlIHN0YXRlIHNob3VsZCBhbHdheXMga2VlcCBhIGNvbnNpc3RlbnRcbiAgICAgKiB0eXBlIHNpZ25hdHVyZSBhbmQgdGhlIG9ubHkgdXNlIGNhc2UgZm9yIHRoaXMsIGlzIHRvIGF2b2lkIHRoYXQuXG4gICAgICovXG4gICAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbihuZXdTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKHRoaXMsIG5ld1N0YXRlLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGZpbmFsXG4gICAgICovXG4gICAgaXNNb3VudGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgdGhpcy5fX2RpZFdhcm5Jc01vdW50ZWQsXG4gICAgICAgICAgJyVzOiBpc01vdW50ZWQgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwICcgK1xuICAgICAgICAgICAgJ3N1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gY29tcG9uZW50V2lsbFVubW91bnQgdG8gJyArXG4gICAgICAgICAgICAncHJldmVudCBtZW1vcnkgbGVha3MuJyxcbiAgICAgICAgICAodGhpcy5jb25zdHJ1Y3RvciAmJiB0aGlzLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lKSB8fFxuICAgICAgICAgICAgdGhpcy5uYW1lIHx8XG4gICAgICAgICAgICAnQ29tcG9uZW50J1xuICAgICAgICApO1xuICAgICAgICB0aGlzLl9fZGlkV2FybklzTW91bnRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gISF0aGlzLl9faXNNb3VudGVkO1xuICAgIH1cbiAgfTtcblxuICB2YXIgUmVhY3RDbGFzc0NvbXBvbmVudCA9IGZ1bmN0aW9uKCkge307XG4gIF9hc3NpZ24oXG4gICAgUmVhY3RDbGFzc0NvbXBvbmVudC5wcm90b3R5cGUsXG4gICAgUmVhY3RDb21wb25lbnQucHJvdG90eXBlLFxuICAgIFJlYWN0Q2xhc3NNaXhpblxuICApO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIGNvbXBvbmVudCBjbGFzcyBnaXZlbiBhIGNsYXNzIHNwZWNpZmljYXRpb24uXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jcmVhdGVjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3BlYyBDbGFzcyBzcGVjaWZpY2F0aW9uICh3aGljaCBtdXN0IGRlZmluZSBgcmVuZGVyYCkuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBDb21wb25lbnQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzKHNwZWMpIHtcbiAgICAvLyBUbyBrZWVwIG91ciB3YXJuaW5ncyBtb3JlIHVuZGVyc3RhbmRhYmxlLCB3ZSdsbCB1c2UgYSBsaXR0bGUgaGFjayBoZXJlIHRvXG4gICAgLy8gZW5zdXJlIHRoYXQgQ29uc3RydWN0b3IubmFtZSAhPT0gJ0NvbnN0cnVjdG9yJy4gVGhpcyBtYWtlcyBzdXJlIHdlIGRvbid0XG4gICAgLy8gdW5uZWNlc3NhcmlseSBpZGVudGlmeSBhIGNsYXNzIHdpdGhvdXQgZGlzcGxheU5hbWUgYXMgJ0NvbnN0cnVjdG9yJy5cbiAgICB2YXIgQ29uc3RydWN0b3IgPSBpZGVudGl0eShmdW5jdGlvbihwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAgICAgLy8gVGhpcyBjb25zdHJ1Y3RvciBnZXRzIG92ZXJyaWRkZW4gYnkgbW9ja3MuIFRoZSBhcmd1bWVudCBpcyB1c2VkXG4gICAgICAvLyBieSBtb2NrcyB0byBhc3NlcnQgb24gd2hhdCBnZXRzIG1vdW50ZWQuXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgdGhpcyBpbnN0YW5jZW9mIENvbnN0cnVjdG9yLFxuICAgICAgICAgICdTb21ldGhpbmcgaXMgY2FsbGluZyBhIFJlYWN0IGNvbXBvbmVudCBkaXJlY3RseS4gVXNlIGEgZmFjdG9yeSBvciAnICtcbiAgICAgICAgICAgICdKU1ggaW5zdGVhZC4gU2VlOiBodHRwczovL2ZiLm1lL3JlYWN0LWxlZ2FjeWZhY3RvcnknXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdpcmUgdXAgYXV0by1iaW5kaW5nXG4gICAgICBpZiAodGhpcy5fX3JlYWN0QXV0b0JpbmRQYWlycy5sZW5ndGgpIHtcbiAgICAgICAgYmluZEF1dG9CaW5kTWV0aG9kcyh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgICAgIC8vIFJlYWN0Q2xhc3NlcyBkb2Vzbid0IGhhdmUgY29uc3RydWN0b3JzLiBJbnN0ZWFkLCB0aGV5IHVzZSB0aGVcbiAgICAgIC8vIGdldEluaXRpYWxTdGF0ZSBhbmQgY29tcG9uZW50V2lsbE1vdW50IG1ldGhvZHMgZm9yIGluaXRpYWxpemF0aW9uLlxuXG4gICAgICB2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUgPyB0aGlzLmdldEluaXRpYWxTdGF0ZSgpIDogbnVsbDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICB0aGlzLmdldEluaXRpYWxTdGF0ZS5faXNNb2NrRnVuY3Rpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgIHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSksXG4gICAgICAgICclcy5nZXRJbml0aWFsU3RhdGUoKTogbXVzdCByZXR1cm4gYW4gb2JqZWN0IG9yIG51bGwnLFxuICAgICAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnXG4gICAgICApO1xuXG4gICAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIH0pO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ldyBSZWFjdENsYXNzQ29tcG9uZW50KCk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLl9fcmVhY3RBdXRvQmluZFBhaXJzID0gW107XG5cbiAgICBpbmplY3RlZE1peGlucy5mb3JFYWNoKG1peFNwZWNJbnRvQ29tcG9uZW50LmJpbmQobnVsbCwgQ29uc3RydWN0b3IpKTtcblxuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBJc01vdW50ZWRQcmVNaXhpbik7XG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpO1xuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBJc01vdW50ZWRQb3N0TWl4aW4pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZGVmYXVsdFByb3BzIHByb3BlcnR5IGFmdGVyIGFsbCBtaXhpbnMgaGF2ZSBiZWVuIG1lcmdlZC5cbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5kZWZhdWx0UHJvcHMgPSBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMoKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHRhZyB0byBpbmRpY2F0ZSB0aGF0IHRoZSB1c2Ugb2YgdGhlc2UgbWV0aG9kIG5hbWVzIGlzIG9rLFxuICAgICAgLy8gc2luY2UgaXQncyB1c2VkIHdpdGggY3JlYXRlQ2xhc3MuIElmIGl0J3Mgbm90LCB0aGVuIGl0J3MgbGlrZWx5IGFcbiAgICAgIC8vIG1pc3Rha2Ugc28gd2UnbGwgd2FybiB5b3UgdG8gdXNlIHRoZSBzdGF0aWMgcHJvcGVydHksIHByb3BlcnR5XG4gICAgICAvLyBpbml0aWFsaXplciBvciBjb25zdHJ1Y3RvciByZXNwZWN0aXZlbHkuXG4gICAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUpIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIF9pbnZhcmlhbnQoXG4gICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUucmVuZGVyLFxuICAgICAgJ2NyZWF0ZUNsYXNzKC4uLik6IENsYXNzIHNwZWNpZmljYXRpb24gbXVzdCBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuJ1xuICAgICk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRTaG91bGRVcGRhdGUsXG4gICAgICAgICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgK1xuICAgICAgICAgICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICtcbiAgICAgICAgICAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgK1xuICAgICAgICAgICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLFxuICAgICAgICBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCdcbiAgICAgICk7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMsXG4gICAgICAgICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgK1xuICAgICAgICAgICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JyxcbiAgICAgICAgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFJlZHVjZSB0aW1lIHNwZW50IGRvaW5nIGxvb2t1cHMgYnkgc2V0dGluZyB0aGVzZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gUmVhY3RDbGFzc0ludGVyZmFjZSkge1xuICAgICAgaWYgKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlQ2xhc3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1yZWFjdC1jbGFzcy9mYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJykgOiBfcHJvZEludmFyaWFudCgnMTQzJykgOiB2b2lkIDA7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvbmx5Q2hpbGQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL29ubHlDaGlsZC5qc1xuLy8gbW9kdWxlIGlkID0gMTY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSIsImltcG9ydCB7Y3JlYXRlU3RvcmV9IGZyb20gJ3JlZHV4J1xyXG5cclxuaW1wb3J0IENvZGVDb21iaW5lciBmcm9tICcuL3JlZHVjZXJzJ1xyXG5cclxubGV0IHN0b3JlID0gY3JlYXRlU3RvcmUoQ29kZUNvbWJpbmVyKVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgc3RvcmVcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9yZWR1eC9zdG9yZS5qcyIsImNvbnN0IEhUTUxfU1VCTUlUID0gKGh0bWwpID0+ICh7XHJcbiAgICB0eXBlOiAnSFRNTF9TVUJNSVQnLFxyXG4gICAgaHRtbFxyXG59KVxyXG5cclxuY29uc3QgQ1NTX1NVQk1JVCA9IChjc3MpID0+ICh7XHJcbiAgICB0eXBlOiAnQ1NTX1NVQk1JVCcsXHJcbiAgICBjc3NcclxufSlcclxuXHJcbmNvbnN0IEpTX1NVQk1JVCA9IChqcykgPT4gKHtcclxuICAgIHR5cGU6ICdKU19TVUJNSVQnLFxyXG4gICAganNcclxufSlcclxuXHJcbmNvbnN0IFNBVkVfVE9fREFUQUJBU0UgPSAoKSA9PiAoe1xyXG4gICAgdHlwZTogJ1NBVkVfVE9fREFUQUJBU0UnXHJcbn0pXHJcblxyXG5leHBvcnQge0hUTUxfU1VCTUlULCBDU1NfU1VCTUlULCBKU19TVUJNSVQsIFNBVkVfVE9fREFUQUJBU0V9XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVkdXgvYWN0aW9ucy5qcyIsImltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJ2xvZGFzaC1lcy9pc1BsYWluT2JqZWN0JztcbmltcG9ydCAkJG9ic2VydmFibGUgZnJvbSAnc3ltYm9sLW9ic2VydmFibGUnO1xuXG4vKipcbiAqIFRoZXNlIGFyZSBwcml2YXRlIGFjdGlvbiB0eXBlcyByZXNlcnZlZCBieSBSZWR1eC5cbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqIERvIG5vdCByZWZlcmVuY2UgdGhlc2UgYWN0aW9uIHR5cGVzIGRpcmVjdGx5IGluIHlvdXIgY29kZS5cbiAqL1xuZXhwb3J0IHZhciBBY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogJ0BAcmVkdXgvSU5JVCdcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlZHV4IHN0b3JlIHRoYXQgaG9sZHMgdGhlIHN0YXRlIHRyZWUuXG4gICAqIFRoZSBvbmx5IHdheSB0byBjaGFuZ2UgdGhlIGRhdGEgaW4gdGhlIHN0b3JlIGlzIHRvIGNhbGwgYGRpc3BhdGNoKClgIG9uIGl0LlxuICAgKlxuICAgKiBUaGVyZSBzaG91bGQgb25seSBiZSBhIHNpbmdsZSBzdG9yZSBpbiB5b3VyIGFwcC4gVG8gc3BlY2lmeSBob3cgZGlmZmVyZW50XG4gICAqIHBhcnRzIG9mIHRoZSBzdGF0ZSB0cmVlIHJlc3BvbmQgdG8gYWN0aW9ucywgeW91IG1heSBjb21iaW5lIHNldmVyYWwgcmVkdWNlcnNcbiAgICogaW50byBhIHNpbmdsZSByZWR1Y2VyIGZ1bmN0aW9uIGJ5IHVzaW5nIGBjb21iaW5lUmVkdWNlcnNgLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWR1Y2VyIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlIHRyZWUsIGdpdmVuXG4gICAqIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBhY3Rpb24gdG8gaGFuZGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gW3ByZWxvYWRlZFN0YXRlXSBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAgICogdG8gaHlkcmF0ZSB0aGUgc3RhdGUgZnJvbSB0aGUgc2VydmVyIGluIHVuaXZlcnNhbCBhcHBzLCBvciB0byByZXN0b3JlIGFcbiAgICogcHJldmlvdXNseSBzZXJpYWxpemVkIHVzZXIgc2Vzc2lvbi5cbiAgICogSWYgeW91IHVzZSBgY29tYmluZVJlZHVjZXJzYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXIgZnVuY3Rpb24sIHRoaXMgbXVzdCBiZVxuICAgKiBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyBgY29tYmluZVJlZHVjZXJzYCBrZXlzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZW5oYW5jZXJdIFRoZSBzdG9yZSBlbmhhbmNlci4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAgICogdG8gZW5oYW5jZSB0aGUgc3RvcmUgd2l0aCB0aGlyZC1wYXJ0eSBjYXBhYmlsaXRpZXMgc3VjaCBhcyBtaWRkbGV3YXJlLFxuICAgKiB0aW1lIHRyYXZlbCwgcGVyc2lzdGVuY2UsIGV0Yy4gVGhlIG9ubHkgc3RvcmUgZW5oYW5jZXIgdGhhdCBzaGlwcyB3aXRoIFJlZHV4XG4gICAqIGlzIGBhcHBseU1pZGRsZXdhcmUoKWAuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdG9yZX0gQSBSZWR1eCBzdG9yZSB0aGF0IGxldHMgeW91IHJlYWQgdGhlIHN0YXRlLCBkaXNwYXRjaCBhY3Rpb25zXG4gICAqIGFuZCBzdWJzY3JpYmUgdG8gY2hhbmdlcy5cbiAgICovXG59O2V4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICB2YXIgX3JlZjI7XG5cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZW5oYW5jZXIgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIHJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50U3RhdGUgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgdmFyIGN1cnJlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xuICB2YXIgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBzdGF0ZSB0cmVlIG1hbmFnZWQgYnkgdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgY3VycmVudCBzdGF0ZSB0cmVlIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuXG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIG5leHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoIWlzU3Vic2NyaWJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuXG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICB2YXIgaW5kZXggPSBuZXh0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbmV4dExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBhY3Rpb24uIEl0IGlzIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGEgc3RhdGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGdpdmVuIGBhY3Rpb25gLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xuICAgKiB3cmFwIHlvdXIgc3RvcmUgY3JlYXRpbmcgZnVuY3Rpb24gaW50byB0aGUgY29ycmVzcG9uZGluZyBtaWRkbGV3YXJlLiBGb3JcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxuICAgKiBzZXNzaW9ucywgb3IgdXNlIHRoZSB0aW1lIHRyYXZlbGxpbmcgYHJlZHV4LWRldnRvb2xzYC4gQW4gYWN0aW9uIG11c3QgaGF2ZVxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCwgaWYgeW91IHVzZSBhIGN1c3RvbSBtaWRkbGV3YXJlLCBpdCBtYXkgd3JhcCBgZGlzcGF0Y2goKWAgdG9cbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxuICAgKi9cbiAgZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuICcgKyAnVXNlIGN1c3RvbSBtaWRkbGV3YXJlIGZvciBhc3luYyBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gJyArICdIYXZlIHlvdSBtaXNzcGVsbGVkIGEgY29uc3RhbnQ/Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSByZWR1Y2VyIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBzdG9yZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBZb3UgbWlnaHQgbmVlZCB0aGlzIGlmIHlvdXIgYXBwIGltcGxlbWVudHMgY29kZSBzcGxpdHRpbmcgYW5kIHlvdSB3YW50IHRvXG4gICAqIGxvYWQgc29tZSBvZiB0aGUgcmVkdWNlcnMgZHluYW1pY2FsbHkuIFlvdSBtaWdodCBhbHNvIG5lZWQgdGhpcyBpZiB5b3VcbiAgICogaW1wbGVtZW50IGEgaG90IHJlbG9hZGluZyBtZWNoYW5pc20gZm9yIFJlZHV4LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0UmVkdWNlciBUaGUgcmVkdWNlciBmb3IgdGhlIHN0b3JlIHRvIHVzZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0UmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyO1xuICAgIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm9wZXJhYmlsaXR5IHBvaW50IGZvciBvYnNlcnZhYmxlL3JlYWN0aXZlIGxpYnJhcmllcy5cbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgcmV0dXJuIF9yZWYgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlciBBbnkgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gb2JzZXJ2ZXIuXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cbiAgICAgICAqIEByZXR1cm5zIHtzdWJzY3JpcHRpb259IEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXG4gICAgICAgKiBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZhYmxlIGZyb20gdGhlIHN0b3JlLCBhbmQgcHJldmVudCBmdXJ0aGVyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAqL1xuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnNlcnZlciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb2JzZXJ2ZVN0YXRlKCkge1xuICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGdldFN0YXRlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9ic2VydmVTdGF0ZSgpO1xuICAgICAgICB2YXIgdW5zdWJzY3JpYmUgPSBvdXRlclN1YnNjcmliZShvYnNlcnZlU3RhdGUpO1xuICAgICAgICByZXR1cm4geyB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmUgfTtcbiAgICAgIH1cbiAgICB9LCBfcmVmWyQkb2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfcmVmO1xuICB9XG5cbiAgLy8gV2hlbiBhIHN0b3JlIGlzIGNyZWF0ZWQsIGFuIFwiSU5JVFwiIGFjdGlvbiBpcyBkaXNwYXRjaGVkIHNvIHRoYXQgZXZlcnlcbiAgLy8gcmVkdWNlciByZXR1cm5zIHRoZWlyIGluaXRpYWwgc3RhdGUuIFRoaXMgZWZmZWN0aXZlbHkgcG9wdWxhdGVzXG4gIC8vIHRoZSBpbml0aWFsIHN0YXRlIHRyZWUuXG4gIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcblxuICByZXR1cm4gX3JlZjIgPSB7XG4gICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxuICAgIGdldFN0YXRlOiBnZXRTdGF0ZSxcbiAgICByZXBsYWNlUmVkdWNlcjogcmVwbGFjZVJlZHVjZXJcbiAgfSwgX3JlZjJbJCRvYnNlcnZhYmxlXSA9IG9ic2VydmFibGUsIF9yZWYyO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2NyZWF0ZVN0b3JlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NzBcbi8vIG1vZHVsZSBjaHVua3MgPSA1IiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgZ2V0UHJvdG90eXBlIGZyb20gJy4vX2dldFByb3RvdHlwZS5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1BsYWluT2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDU3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDUiLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bWJvbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSA1NzJcbi8vIG1vZHVsZSBjaHVua3MgPSA1IiwiLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWR1eC9lcy91dGlscy93YXJuaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA1NzNcbi8vIG1vZHVsZSBjaHVua3MgPSA1IiwiLyoqXG4gKiBDb21wb3NlcyBzaW5nbGUtYXJndW1lbnQgZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC4gVGhlIHJpZ2h0bW9zdFxuICogZnVuY3Rpb24gY2FuIHRha2UgbXVsdGlwbGUgYXJndW1lbnRzIGFzIGl0IHByb3ZpZGVzIHRoZSBzaWduYXR1cmUgZm9yXG4gKiB0aGUgcmVzdWx0aW5nIGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jcyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gb2J0YWluZWQgYnkgY29tcG9zaW5nIHRoZSBhcmd1bWVudCBmdW5jdGlvbnNcbiAqIGZyb20gcmlnaHQgdG8gbGVmdC4gRm9yIGV4YW1wbGUsIGNvbXBvc2UoZiwgZywgaCkgaXMgaWRlbnRpY2FsIHRvIGRvaW5nXG4gKiAoLi4uYXJncykgPT4gZihnKGgoLi4uYXJncykpKS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wb3NlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIGFyZztcbiAgICB9O1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmdW5jc1swXTtcbiAgfVxuXG4gIHJldHVybiBmdW5jcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGEoYi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2NvbXBvc2UuanNcbi8vIG1vZHVsZSBpZCA9IDU3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDUiLCIvKiFcbiAqIExlc3MgLSBMZWFuZXIgQ1NTIHYyLjcuMlxuICogaHR0cDovL2xlc3Njc3Mub3JnXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMTcsIEFsZXhpcyBTZWxsaWVyIDxzZWxmQGNsb3VkaGVhZC5uZXQ+XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBMaWNlbnNlLlxuICpcbiAqL1xuXG4gLyoqICogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuICovXG5cbihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLmxlc3MgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgYWRkRGF0YUF0dHIgPSByZXF1aXJlKFwiLi91dGlsc1wiKS5hZGREYXRhQXR0cixcbiAgICBicm93c2VyID0gcmVxdWlyZShcIi4vYnJvd3NlclwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih3aW5kb3csIG9wdGlvbnMpIHtcblxuICAgIC8vIHVzZSBvcHRpb25zIGZyb20gdGhlIGN1cnJlbnQgc2NyaXB0IHRhZyBkYXRhIGF0dHJpYnVlc1xuICAgIGFkZERhdGFBdHRyKG9wdGlvbnMsIGJyb3dzZXIuY3VycmVudFNjcmlwdCh3aW5kb3cpKTtcblxuICAgIGlmIChvcHRpb25zLmlzRmlsZVByb3RvY29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5pc0ZpbGVQcm90b2NvbCA9IC9eKGZpbGV8KGNocm9tZXxzYWZhcmkpKC1leHRlbnNpb24pP3xyZXNvdXJjZXxxcmN8YXBwKTovLnRlc3Qod2luZG93LmxvY2F0aW9uLnByb3RvY29sKTtcbiAgICB9XG5cbiAgICAvLyBMb2FkIHN0eWxlcyBhc3luY2hyb25vdXNseSAoZGVmYXVsdDogZmFsc2UpXG4gICAgLy9cbiAgICAvLyBUaGlzIGlzIHNldCB0byBgZmFsc2VgIGJ5IGRlZmF1bHQsIHNvIHRoYXQgdGhlIGJvZHlcbiAgICAvLyBkb2Vzbid0IHN0YXJ0IGxvYWRpbmcgYmVmb3JlIHRoZSBzdHlsZXNoZWV0cyBhcmUgcGFyc2VkLlxuICAgIC8vIFNldHRpbmcgdGhpcyB0byBgdHJ1ZWAgY2FuIHJlc3VsdCBpbiBmbGlja2VyaW5nLlxuICAgIC8vXG4gICAgb3B0aW9ucy5hc3luYyA9IG9wdGlvbnMuYXN5bmMgfHwgZmFsc2U7XG4gICAgb3B0aW9ucy5maWxlQXN5bmMgPSBvcHRpb25zLmZpbGVBc3luYyB8fCBmYWxzZTtcblxuICAgIC8vIEludGVydmFsIGJldHdlZW4gd2F0Y2ggcG9sbHNcbiAgICBvcHRpb25zLnBvbGwgPSBvcHRpb25zLnBvbGwgfHwgKG9wdGlvbnMuaXNGaWxlUHJvdG9jb2wgPyAxMDAwIDogMTUwMCk7XG5cbiAgICBvcHRpb25zLmVudiA9IG9wdGlvbnMuZW52IHx8ICh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgPT0gJzEyNy4wLjAuMScgfHxcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lID09ICcwLjAuMC4wJyAgIHx8XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA9PSAnbG9jYWxob3N0JyB8fFxuICAgICAgICAod2luZG93LmxvY2F0aW9uLnBvcnQgJiZcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5wb3J0Lmxlbmd0aCA+IDApICAgICAgfHxcbiAgICAgICAgb3B0aW9ucy5pc0ZpbGVQcm90b2NvbCAgICAgICAgICAgICAgICAgICA/ICdkZXZlbG9wbWVudCdcbiAgICAgICAgOiAncHJvZHVjdGlvbicpO1xuXG4gICAgdmFyIGR1bXBMaW5lTnVtYmVycyA9IC8hZHVtcExpbmVOdW1iZXJzOihjb21tZW50c3xtZWRpYXF1ZXJ5fGFsbCkvLmV4ZWMod2luZG93LmxvY2F0aW9uLmhhc2gpO1xuICAgIGlmIChkdW1wTGluZU51bWJlcnMpIHtcbiAgICAgICAgb3B0aW9ucy5kdW1wTGluZU51bWJlcnMgPSBkdW1wTGluZU51bWJlcnNbMV07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudXNlRmlsZUNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy51c2VGaWxlQ2FjaGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm9uUmVhZHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLm9uUmVhZHkgPSB0cnVlO1xuICAgIH1cblxufTtcblxufSx7XCIuL2Jyb3dzZXJcIjozLFwiLi91dGlsc1wiOjEwfV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEtpY2tzIG9mZiBsZXNzIGFuZCBjb21waWxlcyBhbnkgc3R5bGVzaGVldHNcbiAqIHVzZWQgaW4gdGhlIGJyb3dzZXIgZGlzdHJpYnV0ZWQgdmVyc2lvbiBvZiBsZXNzXG4gKiB0byBraWNrLXN0YXJ0IGxlc3MgdXNpbmcgdGhlIGJyb3dzZXIgYXBpXG4gKi9cbi8qZ2xvYmFsIHdpbmRvdywgZG9jdW1lbnQgKi9cblxuLy8gc2hpbSBQcm9taXNlIGlmIHJlcXVpcmVkXG5yZXF1aXJlKCdwcm9taXNlL3BvbHlmaWxsLmpzJyk7XG5cbnZhciBvcHRpb25zID0gd2luZG93Lmxlc3MgfHwge307XG5yZXF1aXJlKFwiLi9hZGQtZGVmYXVsdC1vcHRpb25zXCIpKHdpbmRvdywgb3B0aW9ucyk7XG5cbnZhciBsZXNzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pbmRleFwiKSh3aW5kb3csIG9wdGlvbnMpO1xuXG53aW5kb3cubGVzcyA9IGxlc3M7XG5cbnZhciBjc3MsIGhlYWQsIHN0eWxlO1xuXG4vLyBBbHdheXMgcmVzdG9yZSBwYWdlIHZpc2liaWxpdHlcbmZ1bmN0aW9uIHJlc29sdmVPclJlamVjdChkYXRhKSB7XG4gICAgaWYgKGRhdGEuZmlsZW5hbWUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGRhdGEpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuYXN5bmMpIHtcbiAgICAgICAgaGVhZC5yZW1vdmVDaGlsZChzdHlsZSk7XG4gICAgfVxufVxuXG5pZiAob3B0aW9ucy5vblJlYWR5KSB7XG4gICAgaWYgKC8hd2F0Y2gvLnRlc3Qod2luZG93LmxvY2F0aW9uLmhhc2gpKSB7XG4gICAgICAgIGxlc3Mud2F0Y2goKTtcbiAgICB9XG4gICAgLy8gU2ltdWxhdGUgc3luY2hyb25vdXMgc3R5bGVzaGVldCBsb2FkaW5nIGJ5IGJsb2NraW5nIHBhZ2UgcmVuZGVyaW5nXG4gICAgaWYgKCFvcHRpb25zLmFzeW5jKSB7XG4gICAgICAgIGNzcyA9ICdib2R5IHsgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50IH0nO1xuICAgICAgICBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgICAgICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cbiAgICAgICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgICBsZXNzLnJlZ2lzdGVyU3R5bGVzaGVldHNJbW1lZGlhdGVseSgpO1xuICAgIGxlc3MucGFnZUxvYWRGaW5pc2hlZCA9IGxlc3MucmVmcmVzaChsZXNzLmVudiA9PT0gJ2RldmVsb3BtZW50JykudGhlbihyZXNvbHZlT3JSZWplY3QsIHJlc29sdmVPclJlamVjdCk7XG59XG5cbn0se1wiLi9hZGQtZGVmYXVsdC1vcHRpb25zXCI6MSxcIi4vaW5kZXhcIjo4LFwicHJvbWlzZS9wb2x5ZmlsbC5qc1wiOjk3fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNyZWF0ZUNTUzogZnVuY3Rpb24gKGRvY3VtZW50LCBzdHlsZXMsIHNoZWV0KSB7XG4gICAgICAgIC8vIFN0cmlwIHRoZSBxdWVyeS1zdHJpbmdcbiAgICAgICAgdmFyIGhyZWYgPSBzaGVldC5ocmVmIHx8ICcnO1xuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHRpdGxlIHNldCwgdXNlIHRoZSBmaWxlbmFtZSwgbWludXMgdGhlIGV4dGVuc2lvblxuICAgICAgICB2YXIgaWQgPSAnbGVzczonICsgKHNoZWV0LnRpdGxlIHx8IHV0aWxzLmV4dHJhY3RJZChocmVmKSk7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBoYXMgYWxyZWFkeSBiZWVuIGluc2VydGVkIGludG8gdGhlIERPTSwgd2UgbWF5IG5lZWQgdG8gcmVwbGFjZSBpdFxuICAgICAgICB2YXIgb2xkU3R5bGVOb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICB2YXIga2VlcE9sZFN0eWxlTm9kZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBzdHlsZXNoZWV0IG5vZGUgZm9yIGluc2VydGlvbiBvciAoaWYgbmVjZXNzYXJ5KSByZXBsYWNlbWVudFxuICAgICAgICB2YXIgc3R5bGVOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGVOb2RlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuICAgICAgICBpZiAoc2hlZXQubWVkaWEpIHtcbiAgICAgICAgICAgIHN0eWxlTm9kZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgc2hlZXQubWVkaWEpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlTm9kZS5pZCA9IGlkO1xuXG4gICAgICAgIGlmICghc3R5bGVOb2RlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgIHN0eWxlTm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHlsZXMpKTtcblxuICAgICAgICAgICAgLy8gSWYgbmV3IGNvbnRlbnRzIG1hdGNoIGNvbnRlbnRzIG9mIG9sZFN0eWxlTm9kZSwgZG9uJ3QgcmVwbGFjZSBvbGRTdHlsZU5vZGVcbiAgICAgICAgICAgIGtlZXBPbGRTdHlsZU5vZGUgPSAob2xkU3R5bGVOb2RlICE9PSBudWxsICYmIG9sZFN0eWxlTm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDAgJiYgc3R5bGVOb2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIG9sZFN0eWxlTm9kZS5maXJzdENoaWxkLm5vZGVWYWx1ZSA9PT0gc3R5bGVOb2RlLmZpcnN0Q2hpbGQubm9kZVZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBvbGRTdHlsZU5vZGUsIGp1c3QgYXBwZW5kOyBvdGhlcndpc2UsIG9ubHkgYXBwZW5kIGlmIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gcmVwbGFjZSBvbGRTdHlsZU5vZGUgd2l0aCBhbiB1cGRhdGVkIHN0eWxlc2hlZXRcbiAgICAgICAgaWYgKG9sZFN0eWxlTm9kZSA9PT0gbnVsbCB8fCBrZWVwT2xkU3R5bGVOb2RlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIG5leHRFbCA9IHNoZWV0ICYmIHNoZWV0Lm5leHRTaWJsaW5nIHx8IG51bGw7XG4gICAgICAgICAgICBpZiAobmV4dEVsKSB7XG4gICAgICAgICAgICAgICAgbmV4dEVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN0eWxlTm9kZSwgbmV4dEVsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZU5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRTdHlsZU5vZGUgJiYga2VlcE9sZFN0eWxlTm9kZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG9sZFN0eWxlTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9sZFN0eWxlTm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3IgSUUuXG4gICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gaGFwcGVuICphZnRlciogdGhlIHN0eWxlIGVsZW1lbnQgaXMgYWRkZWQgdG8gdGhlIERPTSwgb3RoZXJ3aXNlIElFIDcgYW5kIDggbWF5IGNyYXNoLlxuICAgICAgICAvLyBTZWUgaHR0cDovL3NvY2lhbC5tc2RuLm1pY3Jvc29mdC5jb20vRm9ydW1zL2VuLVVTLzdlMDgxYjY1LTg3OGEtNGMyMi04ZTY4LWMxMGQzOWMyZWQzMi9pbnRlcm5ldC1leHBsb3Jlci1jcmFzaGVzLWFwcGVuZGluZy1zdHlsZS1lbGVtZW50LXRvLWhlYWRcbiAgICAgICAgaWYgKHN0eWxlTm9kZS5zdHlsZVNoZWV0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0eWxlTm9kZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBzdHlsZXM7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgcmVhc3NpZ24gc3R5bGVTaGVldC5jc3NUZXh0LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3VycmVudFNjcmlwdDogZnVuY3Rpb24od2luZG93KSB7XG4gICAgICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgfHwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV07XG4gICAgICAgIH0pKCk7XG4gICAgfVxufTtcblxufSx7XCIuL3V0aWxzXCI6MTB9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIENhY2hlIHN5c3RlbSBpcyBhIGJpdCBvdXRkYXRlZCBhbmQgY291bGQgZG8gd2l0aCB3b3JrXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24od2luZG93LCBvcHRpb25zLCBsb2dnZXIpIHtcbiAgICB2YXIgY2FjaGUgPSBudWxsO1xuICAgIGlmIChvcHRpb25zLmVudiAhPT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2FjaGUgPSAodHlwZW9mIHdpbmRvdy5sb2NhbFN0b3JhZ2UgPT09ICd1bmRlZmluZWQnKSA/IG51bGwgOiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgICAgICB9IGNhdGNoIChfKSB7fVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzZXRDU1M6IGZ1bmN0aW9uKHBhdGgsIGxhc3RNb2RpZmllZCwgbW9kaWZ5VmFycywgc3R5bGVzKSB7XG4gICAgICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuaW5mbygnc2F2aW5nICcgKyBwYXRoICsgJyB0byBjYWNoZS4nKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXRJdGVtKHBhdGgsIHN0eWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldEl0ZW0ocGF0aCArICc6dGltZXN0YW1wJywgbGFzdE1vZGlmaWVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGlmeVZhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldEl0ZW0ocGF0aCArICc6dmFycycsIEpTT04uc3RyaW5naWZ5KG1vZGlmeVZhcnMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gLSBjb3VsZCBkbyB3aXRoIGFkZGluZyBtb3JlIHJvYnVzdCBlcnJvciBoYW5kbGluZ1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ2ZhaWxlZCB0byBzYXZlIFwiJyArIHBhdGggKyAnXCIgdG8gbG9jYWwgc3RvcmFnZSBmb3IgY2FjaGluZy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldENTUzogZnVuY3Rpb24ocGF0aCwgd2ViSW5mbywgbW9kaWZ5VmFycykge1xuICAgICAgICAgICAgdmFyIGNzcyAgICAgICA9IGNhY2hlICYmIGNhY2hlLmdldEl0ZW0ocGF0aCksXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gY2FjaGUgJiYgY2FjaGUuZ2V0SXRlbShwYXRoICsgJzp0aW1lc3RhbXAnKSxcbiAgICAgICAgICAgICAgICB2YXJzICAgICAgPSBjYWNoZSAmJiBjYWNoZS5nZXRJdGVtKHBhdGggKyAnOnZhcnMnKTtcblxuICAgICAgICAgICAgbW9kaWZ5VmFycyA9IG1vZGlmeVZhcnMgfHwge307XG5cbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgJiYgd2ViSW5mby5sYXN0TW9kaWZpZWQgJiZcbiAgICAgICAgICAgICAgICAobmV3IERhdGUod2ViSW5mby5sYXN0TW9kaWZpZWQpLnZhbHVlT2YoKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUodGltZXN0YW1wKS52YWx1ZU9mKCkpICYmXG4gICAgICAgICAgICAgICAgKCFtb2RpZnlWYXJzICYmICF2YXJzIHx8IEpTT04uc3RyaW5naWZ5KG1vZGlmeVZhcnMpID09PSB2YXJzKSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBsb2NhbCBjb3B5XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuXG59LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpLFxuICAgIGJyb3dzZXIgPSByZXF1aXJlKFwiLi9icm93c2VyXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHdpbmRvdywgbGVzcywgb3B0aW9ucykge1xuXG4gICAgZnVuY3Rpb24gZXJyb3JIVE1MKGUsIHJvb3RIcmVmKSB7XG4gICAgICAgIHZhciBpZCA9ICdsZXNzLWVycm9yLW1lc3NhZ2U6JyArIHV0aWxzLmV4dHJhY3RJZChyb290SHJlZiB8fCBcIlwiKTtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gJzxsaT48bGFiZWw+e2xpbmV9PC9sYWJlbD48cHJlIGNsYXNzPVwie2NsYXNzfVwiPntjb250ZW50fTwvcHJlPjwvbGk+JztcbiAgICAgICAgdmFyIGVsZW0gPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIHRpbWVyLCBjb250ZW50LCBlcnJvcnMgPSBbXTtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gZS5maWxlbmFtZSB8fCByb290SHJlZjtcbiAgICAgICAgdmFyIGZpbGVuYW1lTm9QYXRoID0gZmlsZW5hbWUubWF0Y2goLyhbXlxcL10rKFxcPy4qKT8pJC8pWzFdO1xuXG4gICAgICAgIGVsZW0uaWQgICAgICAgID0gaWQ7XG4gICAgICAgIGVsZW0uY2xhc3NOYW1lID0gXCJsZXNzLWVycm9yLW1lc3NhZ2VcIjtcblxuICAgICAgICBjb250ZW50ID0gJzxoMz4nICArIChlLnR5cGUgfHwgXCJTeW50YXhcIikgKyBcIkVycm9yOiBcIiArIChlLm1lc3NhZ2UgfHwgJ1RoZXJlIGlzIGFuIGVycm9yIGluIHlvdXIgLmxlc3MgZmlsZScpICtcbiAgICAgICAgICAgICc8L2gzPicgKyAnPHA+aW4gPGEgaHJlZj1cIicgKyBmaWxlbmFtZSAgICsgJ1wiPicgKyBmaWxlbmFtZU5vUGF0aCArIFwiPC9hPiBcIjtcblxuICAgICAgICB2YXIgZXJyb3JsaW5lID0gZnVuY3Rpb24gKGUsIGksIGNsYXNzbmFtZSkge1xuICAgICAgICAgICAgaWYgKGUuZXh0cmFjdFtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGVtcGxhdGUucmVwbGFjZSgvXFx7bGluZVxcfS8sIChwYXJzZUludChlLmxpbmUsIDEwKSB8fCAwKSArIChpIC0gMSkpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHtjbGFzc1xcfS8sIGNsYXNzbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xce2NvbnRlbnRcXH0vLCBlLmV4dHJhY3RbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZS5leHRyYWN0KSB7XG4gICAgICAgICAgICBlcnJvcmxpbmUoZSwgMCwgJycpO1xuICAgICAgICAgICAgZXJyb3JsaW5lKGUsIDEsICdsaW5lJyk7XG4gICAgICAgICAgICBlcnJvcmxpbmUoZSwgMiwgJycpO1xuICAgICAgICAgICAgY29udGVudCArPSAnb24gbGluZSAnICsgZS5saW5lICsgJywgY29sdW1uICcgKyAoZS5jb2x1bW4gKyAxKSArICc6PC9wPicgK1xuICAgICAgICAgICAgICAgICc8dWw+JyArIGVycm9ycy5qb2luKCcnKSArICc8L3VsPic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUuc3RhY2sgJiYgKGUuZXh0cmFjdCB8fCBvcHRpb25zLmxvZ0xldmVsID49IDQpKSB7XG4gICAgICAgICAgICBjb250ZW50ICs9ICc8YnIvPlN0YWNrIFRyYWNlPC9iciAvPicgKyBlLnN0YWNrLnNwbGl0KCdcXG4nKS5zbGljZSgxKS5qb2luKCc8YnIvPicpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW0uaW5uZXJIVE1MID0gY29udGVudDtcblxuICAgICAgICAvLyBDU1MgZm9yIGVycm9yIG1lc3NhZ2VzXG4gICAgICAgIGJyb3dzZXIuY3JlYXRlQ1NTKHdpbmRvdy5kb2N1bWVudCwgW1xuICAgICAgICAgICAgJy5sZXNzLWVycm9yLW1lc3NhZ2UgdWwsIC5sZXNzLWVycm9yLW1lc3NhZ2UgbGkgeycsXG4gICAgICAgICAgICAnbGlzdC1zdHlsZS10eXBlOiBub25lOycsXG4gICAgICAgICAgICAnbWFyZ2luLXJpZ2h0OiAxNXB4OycsXG4gICAgICAgICAgICAncGFkZGluZzogNHB4IDA7JyxcbiAgICAgICAgICAgICdtYXJnaW46IDA7JyxcbiAgICAgICAgICAgICd9JyxcbiAgICAgICAgICAgICcubGVzcy1lcnJvci1tZXNzYWdlIGxhYmVsIHsnLFxuICAgICAgICAgICAgJ2ZvbnQtc2l6ZTogMTJweDsnLFxuICAgICAgICAgICAgJ21hcmdpbi1yaWdodDogMTVweDsnLFxuICAgICAgICAgICAgJ3BhZGRpbmc6IDRweCAwOycsXG4gICAgICAgICAgICAnY29sb3I6ICNjYzc3Nzc7JyxcbiAgICAgICAgICAgICd9JyxcbiAgICAgICAgICAgICcubGVzcy1lcnJvci1tZXNzYWdlIHByZSB7JyxcbiAgICAgICAgICAgICdjb2xvcjogI2RkNjY2NjsnLFxuICAgICAgICAgICAgJ3BhZGRpbmc6IDRweCAwOycsXG4gICAgICAgICAgICAnbWFyZ2luOiAwOycsXG4gICAgICAgICAgICAnZGlzcGxheTogaW5saW5lLWJsb2NrOycsXG4gICAgICAgICAgICAnfScsXG4gICAgICAgICAgICAnLmxlc3MtZXJyb3ItbWVzc2FnZSBwcmUubGluZSB7JyxcbiAgICAgICAgICAgICdjb2xvcjogI2ZmMDAwMDsnLFxuICAgICAgICAgICAgJ30nLFxuICAgICAgICAgICAgJy5sZXNzLWVycm9yLW1lc3NhZ2UgaDMgeycsXG4gICAgICAgICAgICAnZm9udC1zaXplOiAyMHB4OycsXG4gICAgICAgICAgICAnZm9udC13ZWlnaHQ6IGJvbGQ7JyxcbiAgICAgICAgICAgICdwYWRkaW5nOiAxNXB4IDAgNXB4IDA7JyxcbiAgICAgICAgICAgICdtYXJnaW46IDA7JyxcbiAgICAgICAgICAgICd9JyxcbiAgICAgICAgICAgICcubGVzcy1lcnJvci1tZXNzYWdlIGEgeycsXG4gICAgICAgICAgICAnY29sb3I6ICMxMGEnLFxuICAgICAgICAgICAgJ30nLFxuICAgICAgICAgICAgJy5sZXNzLWVycm9yLW1lc3NhZ2UgLmVycm9yIHsnLFxuICAgICAgICAgICAgJ2NvbG9yOiByZWQ7JyxcbiAgICAgICAgICAgICdmb250LXdlaWdodDogYm9sZDsnLFxuICAgICAgICAgICAgJ3BhZGRpbmctYm90dG9tOiAycHg7JyxcbiAgICAgICAgICAgICdib3JkZXItYm90dG9tOiAxcHggZGFzaGVkIHJlZDsnLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksIHsgdGl0bGU6ICdlcnJvci1tZXNzYWdlJyB9KTtcblxuICAgICAgICBlbGVtLnN0eWxlLmNzc1RleHQgPSBbXG4gICAgICAgICAgICBcImZvbnQtZmFtaWx5OiBBcmlhbCwgc2Fucy1zZXJpZlwiLFxuICAgICAgICAgICAgXCJib3JkZXI6IDFweCBzb2xpZCAjZTAwXCIsXG4gICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3I6ICNlZWVcIixcbiAgICAgICAgICAgIFwiYm9yZGVyLXJhZGl1czogNXB4XCIsXG4gICAgICAgICAgICBcIi13ZWJraXQtYm9yZGVyLXJhZGl1czogNXB4XCIsXG4gICAgICAgICAgICBcIi1tb3otYm9yZGVyLXJhZGl1czogNXB4XCIsXG4gICAgICAgICAgICBcImNvbG9yOiAjZTAwXCIsXG4gICAgICAgICAgICBcInBhZGRpbmc6IDE1cHhcIixcbiAgICAgICAgICAgIFwibWFyZ2luLWJvdHRvbTogMTVweFwiXG4gICAgICAgIF0uam9pbignOycpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmVudiA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgdGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5LnJlcGxhY2VDaGlsZChlbGVtLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5pbnNlcnRCZWZvcmUoZWxlbSwgYm9keS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVFcnJvckhUTUwocGF0aCkge1xuICAgICAgICB2YXIgbm9kZSA9IHdpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGVzcy1lcnJvci1tZXNzYWdlOicgKyB1dGlscy5leHRyYWN0SWQocGF0aCkpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRXJyb3JDb25zb2xlKHBhdGgpIHtcbiAgICAgICAgLy9ubyBhY3Rpb25cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVFcnJvcihwYXRoKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5lcnJvclJlcG9ydGluZyB8fCBvcHRpb25zLmVycm9yUmVwb3J0aW5nID09PSBcImh0bWxcIikge1xuICAgICAgICAgICAgcmVtb3ZlRXJyb3JIVE1MKHBhdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZXJyb3JSZXBvcnRpbmcgPT09IFwiY29uc29sZVwiKSB7XG4gICAgICAgICAgICByZW1vdmVFcnJvckNvbnNvbGUocGF0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuZXJyb3JSZXBvcnRpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JSZXBvcnRpbmcoXCJyZW1vdmVcIiwgcGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvckNvbnNvbGUoZSwgcm9vdEhyZWYpIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gJ3tsaW5lfSB7Y29udGVudH0nO1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBlLmZpbGVuYW1lIHx8IHJvb3RIcmVmO1xuICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgIHZhciBjb250ZW50ID0gKGUudHlwZSB8fCBcIlN5bnRheFwiKSArIFwiRXJyb3I6IFwiICsgKGUubWVzc2FnZSB8fCAnVGhlcmUgaXMgYW4gZXJyb3IgaW4geW91ciAubGVzcyBmaWxlJykgK1xuICAgICAgICAgICAgXCIgaW4gXCIgKyBmaWxlbmFtZSArIFwiIFwiO1xuXG4gICAgICAgIHZhciBlcnJvcmxpbmUgPSBmdW5jdGlvbiAoZSwgaSwgY2xhc3NuYW1lKSB7XG4gICAgICAgICAgICBpZiAoZS5leHRyYWN0W2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0ZW1wbGF0ZS5yZXBsYWNlKC9cXHtsaW5lXFx9LywgKHBhcnNlSW50KGUubGluZSwgMTApIHx8IDApICsgKGkgLSAxKSlcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xce2NsYXNzXFx9LywgY2xhc3NuYW1lKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx7Y29udGVudFxcfS8sIGUuZXh0cmFjdFtpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChlLmV4dHJhY3QpIHtcbiAgICAgICAgICAgIGVycm9ybGluZShlLCAwLCAnJyk7XG4gICAgICAgICAgICBlcnJvcmxpbmUoZSwgMSwgJ2xpbmUnKTtcbiAgICAgICAgICAgIGVycm9ybGluZShlLCAyLCAnJyk7XG4gICAgICAgICAgICBjb250ZW50ICs9ICdvbiBsaW5lICcgKyBlLmxpbmUgKyAnLCBjb2x1bW4gJyArIChlLmNvbHVtbiArIDEpICsgJzpcXG4nICtcbiAgICAgICAgICAgICAgICBlcnJvcnMuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUuc3RhY2sgJiYgKGUuZXh0cmFjdCB8fCBvcHRpb25zLmxvZ0xldmVsID49IDQpKSB7XG4gICAgICAgICAgICBjb250ZW50ICs9ICdcXG5TdGFjayBUcmFjZVxcbicgKyBlLnN0YWNrO1xuICAgICAgICB9XG4gICAgICAgIGxlc3MubG9nZ2VyLmVycm9yKGNvbnRlbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVycm9yKGUsIHJvb3RIcmVmKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5lcnJvclJlcG9ydGluZyB8fCBvcHRpb25zLmVycm9yUmVwb3J0aW5nID09PSBcImh0bWxcIikge1xuICAgICAgICAgICAgZXJyb3JIVE1MKGUsIHJvb3RIcmVmKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmVycm9yUmVwb3J0aW5nID09PSBcImNvbnNvbGVcIikge1xuICAgICAgICAgICAgZXJyb3JDb25zb2xlKGUsIHJvb3RIcmVmKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5lcnJvclJlcG9ydGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3B0aW9ucy5lcnJvclJlcG9ydGluZyhcImFkZFwiLCBlLCByb290SHJlZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhZGQ6IGVycm9yLFxuICAgICAgICByZW1vdmU6IHJlbW92ZUVycm9yXG4gICAgfTtcbn07XG5cbn0se1wiLi9icm93c2VyXCI6MyxcIi4vdXRpbHNcIjoxMH1dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLypnbG9iYWwgd2luZG93LCBYTUxIdHRwUmVxdWVzdCAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGxvZ2dlcikge1xuXG4gICAgdmFyIEFic3RyYWN0RmlsZU1hbmFnZXIgPSByZXF1aXJlKFwiLi4vbGVzcy9lbnZpcm9ubWVudC9hYnN0cmFjdC1maWxlLW1hbmFnZXIuanNcIik7XG5cbiAgICB2YXIgZmlsZUNhY2hlID0ge307XG5cbiAgICAvL1RPRE9TIC0gbW92ZSBsb2cgc29tZXdoZXJlLiBwYXRoRGlmZiBhbmQgZG9pbmcgc29tZXRoaW5nIHNpbWlsYXIgaW4gbm9kZS4gdXNlIHBhdGhEaWZmIGluIHRoZSBvdGhlciBicm93c2VyIGZpbGUgZm9yIHRoZSBpbml0aWFsIGxvYWRcblxuICAgIGZ1bmN0aW9uIGdldFhNTEh0dHBSZXF1ZXN0KCkge1xuICAgICAgICBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0ICYmICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgIT09IFwiZmlsZTpcIiB8fCAhKFwiQWN0aXZlWE9iamVjdFwiIGluIHdpbmRvdykpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8qZ2xvYmFsIEFjdGl2ZVhPYmplY3QgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBBSkFYLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBGaWxlTWFuYWdlciA9IGZ1bmN0aW9uKCkge1xuICAgIH07XG5cbiAgICBGaWxlTWFuYWdlci5wcm90b3R5cGUgPSBuZXcgQWJzdHJhY3RGaWxlTWFuYWdlcigpO1xuXG4gICAgRmlsZU1hbmFnZXIucHJvdG90eXBlLmFsd2F5c01ha2VQYXRoc0Fic29sdXRlID0gZnVuY3Rpb24gYWx3YXlzTWFrZVBhdGhzQWJzb2x1dGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgRmlsZU1hbmFnZXIucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKGJhc2VQYXRoLCBsYXRlclBhdGgpIHtcbiAgICAgICAgaWYgKCFiYXNlUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhdGVyUGF0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0VXJsUGFydHMobGF0ZXJQYXRoLCBiYXNlUGF0aCkucGF0aDtcbiAgICB9O1xuICAgIEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5kb1hIUiA9IGZ1bmN0aW9uIGRvWEhSKHVybCwgdHlwZSwgY2FsbGJhY2ssIGVycmJhY2spIHtcblxuICAgICAgICB2YXIgeGhyID0gZ2V0WE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgdmFyIGFzeW5jID0gb3B0aW9ucy5pc0ZpbGVQcm90b2NvbCA/IG9wdGlvbnMuZmlsZUFzeW5jIDogdHJ1ZTtcblxuICAgICAgICBpZiAodHlwZW9mIHhoci5vdmVycmlkZU1pbWVUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9jc3MnKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoXCJYSFI6IEdldHRpbmcgJ1wiICsgdXJsICsgXCInXCIpO1xuICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCBhc3luYyk7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCB0eXBlIHx8ICd0ZXh0L3gtbGVzcywgdGV4dC9jc3M7IHE9MC45LCAqLyo7IHE9MC41Jyk7XG4gICAgICAgIHhoci5zZW5kKG51bGwpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlKHhociwgY2FsbGJhY2ssIGVycmJhY2spIHtcbiAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soeGhyLnJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgeGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZXJyYmFjayh4aHIuc3RhdHVzLCB1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaXNGaWxlUHJvdG9jb2wgJiYgIW9wdGlvbnMuZmlsZUFzeW5jKSB7XG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMCB8fCAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyYmFjayh4aHIuc3RhdHVzLCB1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVJlc3BvbnNlKHhociwgY2FsbGJhY2ssIGVycmJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVSZXNwb25zZSh4aHIsIGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmlsZU1hbmFnZXIucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24oZmlsZW5hbWUsIGN1cnJlbnREaXJlY3RvcnksIG9wdGlvbnMsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBGaWxlTWFuYWdlci5wcm90b3R5cGUuY2xlYXJGaWxlQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZmlsZUNhY2hlID0ge307XG4gICAgfTtcblxuICAgIEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5sb2FkRmlsZSA9IGZ1bmN0aW9uIGxvYWRGaWxlKGZpbGVuYW1lLCBjdXJyZW50RGlyZWN0b3J5LCBvcHRpb25zLCBlbnZpcm9ubWVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGN1cnJlbnREaXJlY3RvcnkgJiYgIXRoaXMuaXNQYXRoQWJzb2x1dGUoZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICBmaWxlbmFtZSA9IGN1cnJlbnREaXJlY3RvcnkgKyBmaWxlbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8vIHNoZWV0IG1heSBiZSBzZXQgdG8gdGhlIHN0eWxlc2hlZXQgZm9yIHRoZSBpbml0aWFsIGxvYWQgb3IgYSBjb2xsZWN0aW9uIG9mIHByb3BlcnRpZXMgaW5jbHVkaW5nXG4gICAgICAgIC8vIHNvbWUgY29udGV4dCB2YXJpYWJsZXMgZm9yIGltcG9ydHNcbiAgICAgICAgdmFyIGhyZWZQYXJ0cyA9IHRoaXMuZXh0cmFjdFVybFBhcnRzKGZpbGVuYW1lLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgIHZhciBocmVmICAgICAgPSBocmVmUGFydHMudXJsO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnVzZUZpbGVDYWNoZSAmJiBmaWxlQ2FjaGVbaHJlZl0pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlc3NUZXh0ID0gZmlsZUNhY2hlW2hyZWZdO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsgY29udGVudHM6IGxlc3NUZXh0LCBmaWxlbmFtZTogaHJlZiwgd2ViSW5mbzogeyBsYXN0TW9kaWZpZWQ6IG5ldyBEYXRlKCkgfX0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtmaWxlbmFtZTogaHJlZiwgbWVzc2FnZTogXCJFcnJvciBsb2FkaW5nIGZpbGUgXCIgKyBocmVmICsgXCIgZXJyb3Igd2FzIFwiICsgZS5tZXNzYWdlfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRvWEhSKGhyZWYsIG9wdGlvbnMubWltZSwgZnVuY3Rpb24gZG9YSFJDYWxsYmFjayhkYXRhLCBsYXN0TW9kaWZpZWQpIHtcbiAgICAgICAgICAgIC8vIHBlciBmaWxlIGNhY2hlXG4gICAgICAgICAgICBmaWxlQ2FjaGVbaHJlZl0gPSBkYXRhO1xuXG4gICAgICAgICAgICAvLyBVc2UgcmVtb3RlIGNvcHkgKHJlLXBhcnNlKVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeyBjb250ZW50czogZGF0YSwgZmlsZW5hbWU6IGhyZWYsIHdlYkluZm86IHsgbGFzdE1vZGlmaWVkOiBsYXN0TW9kaWZpZWQgfX0pO1xuICAgICAgICB9LCBmdW5jdGlvbiBkb1hIUkVycm9yKHN0YXR1cywgdXJsKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh7IHR5cGU6ICdGaWxlJywgbWVzc2FnZTogXCInXCIgKyB1cmwgKyBcIicgd2Fzbid0IGZvdW5kIChcIiArIHN0YXR1cyArIFwiKVwiLCBocmVmOiBocmVmIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZpbGVNYW5hZ2VyO1xufTtcblxufSx7XCIuLi9sZXNzL2Vudmlyb25tZW50L2Fic3RyYWN0LWZpbGUtbWFuYWdlci5qc1wiOjE1fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGZ1bmN0aW9uUmVnaXN0cnkgPSByZXF1aXJlKFwiLi8uLi9sZXNzL2Z1bmN0aW9ucy9mdW5jdGlvbi1yZWdpc3RyeVwiKTtcblxuICAgIGZ1bmN0aW9uIGltYWdlU2l6ZSgpIHtcbiAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgdHlwZTogXCJSdW50aW1lXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBcIkltYWdlIHNpemUgZnVuY3Rpb25zIGFyZSBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdmVyc2lvbiBvZiBsZXNzXCJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2VGdW5jdGlvbnMgPSB7XG4gICAgICAgIFwiaW1hZ2Utc2l6ZVwiOiBmdW5jdGlvbihmaWxlUGF0aE5vZGUpIHtcbiAgICAgICAgICAgIGltYWdlU2l6ZSh0aGlzLCBmaWxlUGF0aE5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9LFxuICAgICAgICBcImltYWdlLXdpZHRoXCI6IGZ1bmN0aW9uKGZpbGVQYXRoTm9kZSkge1xuICAgICAgICAgICAgaW1hZ2VTaXplKHRoaXMsIGZpbGVQYXRoTm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0sXG4gICAgICAgIFwiaW1hZ2UtaGVpZ2h0XCI6IGZ1bmN0aW9uKGZpbGVQYXRoTm9kZSkge1xuICAgICAgICAgICAgaW1hZ2VTaXplKHRoaXMsIGZpbGVQYXRoTm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb25SZWdpc3RyeS5hZGRNdWx0aXBsZShpbWFnZUZ1bmN0aW9ucyk7XG59O1xuXG59LHtcIi4vLi4vbGVzcy9mdW5jdGlvbnMvZnVuY3Rpb24tcmVnaXN0cnlcIjoyMn1dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy9cbi8vIGluZGV4LmpzXG4vLyBTaG91bGQgZXhwb3NlIHRoZSBhZGRpdGlvbmFsIGJyb3dzZXIgZnVuY3Rpb25zIG9uIHRvIHRoZSBsZXNzIG9iamVjdFxuLy9cbnZhciBhZGREYXRhQXR0ciA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpLmFkZERhdGFBdHRyLFxuICAgIGJyb3dzZXIgPSByZXF1aXJlKFwiLi9icm93c2VyXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHdpbmRvdywgb3B0aW9ucykge1xuICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICB2YXIgbGVzcyA9IHJlcXVpcmUoJy4uL2xlc3MnKSgpO1xuXG4gICAgLy9tb2R1bGUuZXhwb3J0cyA9IGxlc3M7XG4gICAgbGVzcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB2YXIgZW52aXJvbm1lbnQgPSBsZXNzLmVudmlyb25tZW50LFxuICAgICAgICBGaWxlTWFuYWdlciA9IHJlcXVpcmUoXCIuL2ZpbGUtbWFuYWdlclwiKShvcHRpb25zLCBsZXNzLmxvZ2dlciksXG4gICAgICAgIGZpbGVNYW5hZ2VyID0gbmV3IEZpbGVNYW5hZ2VyKCk7XG4gICAgZW52aXJvbm1lbnQuYWRkRmlsZU1hbmFnZXIoZmlsZU1hbmFnZXIpO1xuICAgIGxlc3MuRmlsZU1hbmFnZXIgPSBGaWxlTWFuYWdlcjtcblxuICAgIHJlcXVpcmUoXCIuL2xvZy1saXN0ZW5lclwiKShsZXNzLCBvcHRpb25zKTtcbiAgICB2YXIgZXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3ItcmVwb3J0aW5nXCIpKHdpbmRvdywgbGVzcywgb3B0aW9ucyk7XG4gICAgdmFyIGNhY2hlID0gbGVzcy5jYWNoZSA9IG9wdGlvbnMuY2FjaGUgfHwgcmVxdWlyZShcIi4vY2FjaGVcIikod2luZG93LCBvcHRpb25zLCBsZXNzLmxvZ2dlcik7XG4gICAgcmVxdWlyZSgnLi9pbWFnZS1zaXplJykobGVzcy5lbnZpcm9ubWVudCk7XG5cbiAgICAvL1NldHVwIHVzZXIgZnVuY3Rpb25zXG4gICAgaWYgKG9wdGlvbnMuZnVuY3Rpb25zKSB7XG4gICAgICAgIGxlc3MuZnVuY3Rpb25zLmZ1bmN0aW9uUmVnaXN0cnkuYWRkTXVsdGlwbGUob3B0aW9ucy5mdW5jdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciB0eXBlUGF0dGVybiA9IC9edGV4dFxcLyh4LSk/bGVzcyQvO1xuXG4gICAgZnVuY3Rpb24gcG9zdFByb2Nlc3NDU1Moc3R5bGVzKSB7IC8vIGRlcHJlY2F0ZWQsIHVzZSBhIHBsdWdpbiBmb3IgcG9zdHByb2Nlc3N0YXNrc1xuICAgICAgICBpZiAob3B0aW9ucy5wb3N0UHJvY2Vzc29yICYmIHR5cGVvZiBvcHRpb25zLnBvc3RQcm9jZXNzb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0eWxlcyA9IG9wdGlvbnMucG9zdFByb2Nlc3Nvci5jYWxsKHN0eWxlcywgc3R5bGVzKSB8fCBzdHlsZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgICAgICAgdmFyIGNsb25lZCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIGNsb25lZFtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH1cblxuICAgIC8vIG9ubHkgcmVhbGx5IG5lZWRlZCBmb3IgcGhhbnRvbVxuICAgIGZ1bmN0aW9uIGJpbmQoZnVuYywgdGhpc0FyZykge1xuICAgICAgICB2YXIgY3VycnlBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBjdXJyeUFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZFN0eWxlcyhtb2RpZnlWYXJzKSB7XG4gICAgICAgIHZhciBzdHlsZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3R5bGUnKSxcbiAgICAgICAgICAgIHN0eWxlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdHlsZSA9IHN0eWxlc1tpXTtcbiAgICAgICAgICAgIGlmIChzdHlsZS50eXBlLm1hdGNoKHR5cGVQYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZU9wdGlvbnMgPSBjbG9uZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZU9wdGlvbnMubW9kaWZ5VmFycyA9IG1vZGlmeVZhcnM7XG4gICAgICAgICAgICAgICAgdmFyIGxlc3NUZXh0ID0gc3R5bGUuaW5uZXJIVE1MIHx8ICcnO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlT3B0aW9ucy5maWxlbmFtZSA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWYucmVwbGFjZSgvIy4qJC8sICcnKTtcblxuICAgICAgICAgICAgICAgIC8qanNoaW50IGxvb3BmdW5jOnRydWUgKi9cbiAgICAgICAgICAgICAgICAvLyB1c2UgY2xvc3VyZSB0byBzdG9yZSBjdXJyZW50IHN0eWxlXG4gICAgICAgICAgICAgICAgbGVzcy5yZW5kZXIobGVzc1RleHQsIGluc3RhbmNlT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmQoZnVuY3Rpb24oc3R5bGUsIGUsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5hZGQoZSwgXCJpbmxpbmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXN1bHQuY3NzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUuaW5uZXJIVE1MID0gcmVzdWx0LmNzcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIG51bGwsIHN0eWxlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkU3R5bGVTaGVldChzaGVldCwgY2FsbGJhY2ssIHJlbG9hZCwgcmVtYWluaW5nLCBtb2RpZnlWYXJzKSB7XG5cbiAgICAgICAgdmFyIGluc3RhbmNlT3B0aW9ucyA9IGNsb25lKG9wdGlvbnMpO1xuICAgICAgICBhZGREYXRhQXR0cihpbnN0YW5jZU9wdGlvbnMsIHNoZWV0KTtcbiAgICAgICAgaW5zdGFuY2VPcHRpb25zLm1pbWUgPSBzaGVldC50eXBlO1xuXG4gICAgICAgIGlmIChtb2RpZnlWYXJzKSB7XG4gICAgICAgICAgICBpbnN0YW5jZU9wdGlvbnMubW9kaWZ5VmFycyA9IG1vZGlmeVZhcnM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBsb2FkSW5pdGlhbEZpbGVDYWxsYmFjayhsb2FkZWRGaWxlKSB7XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gbG9hZGVkRmlsZS5jb250ZW50cyxcbiAgICAgICAgICAgICAgICBwYXRoID0gbG9hZGVkRmlsZS5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICB3ZWJJbmZvID0gbG9hZGVkRmlsZS53ZWJJbmZvO1xuXG4gICAgICAgICAgICB2YXIgbmV3RmlsZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgY3VycmVudERpcmVjdG9yeTogZmlsZU1hbmFnZXIuZ2V0UGF0aChwYXRoKSxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogcGF0aCxcbiAgICAgICAgICAgICAgICByb290RmlsZW5hbWU6IHBhdGgsXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVVcmxzOiBpbnN0YW5jZU9wdGlvbnMucmVsYXRpdmVVcmxzfTtcblxuICAgICAgICAgICAgbmV3RmlsZUluZm8uZW50cnlQYXRoID0gbmV3RmlsZUluZm8uY3VycmVudERpcmVjdG9yeTtcbiAgICAgICAgICAgIG5ld0ZpbGVJbmZvLnJvb3RwYXRoID0gaW5zdGFuY2VPcHRpb25zLnJvb3RwYXRoIHx8IG5ld0ZpbGVJbmZvLmN1cnJlbnREaXJlY3Rvcnk7XG5cbiAgICAgICAgICAgIGlmICh3ZWJJbmZvKSB7XG4gICAgICAgICAgICAgICAgd2ViSW5mby5yZW1haW5pbmcgPSByZW1haW5pbmc7XG5cbiAgICAgICAgICAgICAgICB2YXIgY3NzID0gY2FjaGUuZ2V0Q1NTKHBhdGgsIHdlYkluZm8sIGluc3RhbmNlT3B0aW9ucy5tb2RpZnlWYXJzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlbG9hZCAmJiBjc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgd2ViSW5mby5sb2NhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGNzcywgZGF0YSwgc2hlZXQsIHdlYkluZm8sIHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vVE9ETyBhZGQgdGVzdHMgYXJvdW5kIGhvdyB0aGlzIGJlaGF2ZXMgd2hlbiByZWxvYWRpbmdcbiAgICAgICAgICAgIGVycm9ycy5yZW1vdmUocGF0aCk7XG5cbiAgICAgICAgICAgIGluc3RhbmNlT3B0aW9ucy5yb290RmlsZUluZm8gPSBuZXdGaWxlSW5mbztcbiAgICAgICAgICAgIGxlc3MucmVuZGVyKGRhdGEsIGluc3RhbmNlT3B0aW9ucywgZnVuY3Rpb24oZSwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5ocmVmID0gcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNzcyA9IHBvc3RQcm9jZXNzQ1NTKHJlc3VsdC5jc3MpO1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXRDU1Moc2hlZXQuaHJlZiwgd2ViSW5mby5sYXN0TW9kaWZpZWQsIGluc3RhbmNlT3B0aW9ucy5tb2RpZnlWYXJzLCByZXN1bHQuY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0LmNzcywgZGF0YSwgc2hlZXQsIHdlYkluZm8sIHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZmlsZU1hbmFnZXIubG9hZEZpbGUoc2hlZXQuaHJlZiwgbnVsbCwgaW5zdGFuY2VPcHRpb25zLCBlbnZpcm9ubWVudCwgZnVuY3Rpb24oZSwgbG9hZGVkRmlsZSkge1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2FkSW5pdGlhbEZpbGVDYWxsYmFjayhsb2FkZWRGaWxlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZFN0eWxlU2hlZXRzKGNhbGxiYWNrLCByZWxvYWQsIG1vZGlmeVZhcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXNzLnNoZWV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbG9hZFN0eWxlU2hlZXQobGVzcy5zaGVldHNbaV0sIGNhbGxiYWNrLCByZWxvYWQsIGxlc3Muc2hlZXRzLmxlbmd0aCAtIChpICsgMSksIG1vZGlmeVZhcnMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdFJ1bm5pbmdNb2RlKCkge1xuICAgICAgICBpZiAobGVzcy5lbnYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGxlc3Mud2F0Y2hUaW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVzcy53YXRjaE1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZU1hbmFnZXIuY2xlYXJGaWxlQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICAgICAgbG9hZFN0eWxlU2hlZXRzKGZ1bmN0aW9uIChlLCBjc3MsIF8sIHNoZWV0LCB3ZWJJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5hZGQoZSwgZS5ocmVmIHx8IHNoZWV0LmhyZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicm93c2VyLmNyZWF0ZUNTUyh3aW5kb3cuZG9jdW1lbnQsIGNzcywgc2hlZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBvcHRpb25zLnBvbGwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBXYXRjaCBtb2RlXG4gICAgLy9cbiAgICBsZXNzLndhdGNoICAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghbGVzcy53YXRjaE1vZGUgKSB7XG4gICAgICAgICAgICBsZXNzLmVudiA9ICdkZXZlbG9wbWVudCc7XG4gICAgICAgICAgICBpbml0UnVubmluZ01vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhdGNoTW9kZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBsZXNzLnVud2F0Y2ggPSBmdW5jdGlvbiAoKSB7Y2xlYXJJbnRlcnZhbChsZXNzLndhdGNoVGltZXIpOyB0aGlzLndhdGNoTW9kZSA9IGZhbHNlOyByZXR1cm4gZmFsc2U7IH07XG5cbiAgICAvL1xuICAgIC8vIFN5bmNocm9ub3VzbHkgZ2V0IGFsbCA8bGluaz4gdGFncyB3aXRoIHRoZSAncmVsJyBhdHRyaWJ1dGUgc2V0IHRvXG4gICAgLy8gXCJzdHlsZXNoZWV0L2xlc3NcIi5cbiAgICAvL1xuICAgIGxlc3MucmVnaXN0ZXJTdHlsZXNoZWV0c0ltbWVkaWF0ZWx5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsaW5rcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaW5rJyk7XG4gICAgICAgIGxlc3Muc2hlZXRzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpbmtzW2ldLnJlbCA9PT0gJ3N0eWxlc2hlZXQvbGVzcycgfHwgKGxpbmtzW2ldLnJlbC5tYXRjaCgvc3R5bGVzaGVldC8pICYmXG4gICAgICAgICAgICAgICAgKGxpbmtzW2ldLnR5cGUubWF0Y2godHlwZVBhdHRlcm4pKSkpIHtcbiAgICAgICAgICAgICAgICBsZXNzLnNoZWV0cy5wdXNoKGxpbmtzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL1xuICAgIC8vIEFzeW5jaHJvbm91c2x5IGdldCBhbGwgPGxpbms+IHRhZ3Mgd2l0aCB0aGUgJ3JlbCcgYXR0cmlidXRlIHNldCB0b1xuICAgIC8vIFwic3R5bGVzaGVldC9sZXNzXCIsIHJldHVybmluZyBhIFByb21pc2UuXG4gICAgLy9cbiAgICBsZXNzLnJlZ2lzdGVyU3R5bGVzaGVldHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgbGVzcy5yZWdpc3RlclN0eWxlc2hlZXRzSW1tZWRpYXRlbHkoKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vXG4gICAgLy8gV2l0aCB0aGlzIGZ1bmN0aW9uLCBpdCdzIHBvc3NpYmxlIHRvIGFsdGVyIHZhcmlhYmxlcyBhbmQgcmUtcmVuZGVyXG4gICAgLy8gQ1NTIHdpdGhvdXQgcmVsb2FkaW5nIGxlc3MtZmlsZXNcbiAgICAvL1xuICAgIGxlc3MubW9kaWZ5VmFycyA9IGZ1bmN0aW9uKHJlY29yZCkge1xuICAgICAgICByZXR1cm4gbGVzcy5yZWZyZXNoKHRydWUsIHJlY29yZCwgZmFsc2UpO1xuICAgIH07XG5cbiAgICBsZXNzLnJlZnJlc2ggPSBmdW5jdGlvbiAocmVsb2FkLCBtb2RpZnlWYXJzLCBjbGVhckZpbGVDYWNoZSkge1xuICAgICAgICBpZiAoKHJlbG9hZCB8fCBjbGVhckZpbGVDYWNoZSkgJiYgY2xlYXJGaWxlQ2FjaGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBmaWxlTWFuYWdlci5jbGVhckZpbGVDYWNoZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRUaW1lLCBlbmRUaW1lLCB0b3RhbE1pbGxpc2Vjb25kcywgcmVtYWluaW5nU2hlZXRzO1xuICAgICAgICAgICAgc3RhcnRUaW1lID0gZW5kVGltZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgICAgIC8vIFNldCBjb3VudGVyIGZvciByZW1haW5pbmcgdW5wcm9jZXNzZWQgc2hlZXRzXG4gICAgICAgICAgICByZW1haW5pbmdTaGVldHMgPSBsZXNzLnNoZWV0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdTaGVldHMgPT09IDApIHtcblxuICAgICAgICAgICAgICAgIGVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIHRvdGFsTWlsbGlzZWNvbmRzID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgICAgICAgICAgICBsZXNzLmxvZ2dlci5pbmZvKFwiTGVzcyBoYXMgZmluaXNoZWQgYW5kIG5vIHNoZWV0cyB3ZXJlIGxvYWRlZC5cIik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgICBlbmRUaW1lOiBlbmRUaW1lLFxuICAgICAgICAgICAgICAgICAgICB0b3RhbE1pbGxpc2Vjb25kczogdG90YWxNaWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgICAgIHNoZWV0czogbGVzcy5zaGVldHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVsaWVzIG9uIGxlc3Muc2hlZXRzIGFycmF5LCBjYWxsYmFjayBzZWVtcyB0byBiZSBndWFyYW50ZWVkIHRvIGJlIGNhbGxlZCBmb3IgZXZlcnkgZWxlbWVudCBvZiB0aGUgYXJyYXlcbiAgICAgICAgICAgICAgICBsb2FkU3R5bGVTaGVldHMoZnVuY3Rpb24gKGUsIGNzcywgXywgc2hlZXQsIHdlYkluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5hZGQoZSwgZS5ocmVmIHx8IHNoZWV0LmhyZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh3ZWJJbmZvLmxvY2FsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXNzLmxvZ2dlci5pbmZvKFwiTG9hZGluZyBcIiArIHNoZWV0LmhyZWYgKyBcIiBmcm9tIGNhY2hlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlc3MubG9nZ2VyLmluZm8oXCJSZW5kZXJlZCBcIiArIHNoZWV0LmhyZWYgKyBcIiBzdWNjZXNzZnVsbHkuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuY3JlYXRlQ1NTKHdpbmRvdy5kb2N1bWVudCwgY3NzLCBzaGVldCk7XG4gICAgICAgICAgICAgICAgICAgIGxlc3MubG9nZ2VyLmluZm8oXCJDU1MgZm9yIFwiICsgc2hlZXQuaHJlZiArIFwiIGdlbmVyYXRlZCBpbiBcIiArIChuZXcgRGF0ZSgpIC0gZW5kVGltZSkgKyAnbXMnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb3VudCBjb21wbGV0ZWQgc2hlZXRcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nU2hlZXRzLS07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGxhc3QgcmVtYWluaW5nIHNoZWV0IHdhcyBwcm9jZXNzZWQgYW5kIHRoZW4gY2FsbCB0aGUgcHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nU2hlZXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbE1pbGxpc2Vjb25kcyA9IG5ldyBEYXRlKCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXNzLmxvZ2dlci5pbmZvKFwiTGVzcyBoYXMgZmluaXNoZWQuIENTUyBnZW5lcmF0ZWQgaW4gXCIgKyB0b3RhbE1pbGxpc2Vjb25kcyArICdtcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kVGltZTogZW5kVGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbE1pbGxpc2Vjb25kczogdG90YWxNaWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hlZXRzOiBsZXNzLnNoZWV0cy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0sIHJlbG9hZCwgbW9kaWZ5VmFycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxvYWRTdHlsZXMobW9kaWZ5VmFycyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBsZXNzLnJlZnJlc2hTdHlsZXMgPSBsb2FkU3R5bGVzO1xuICAgIHJldHVybiBsZXNzO1xufTtcblxufSx7XCIuLi9sZXNzXCI6MzEsXCIuL2Jyb3dzZXJcIjozLFwiLi9jYWNoZVwiOjQsXCIuL2Vycm9yLXJlcG9ydGluZ1wiOjUsXCIuL2ZpbGUtbWFuYWdlclwiOjYsXCIuL2ltYWdlLXNpemVcIjo3LFwiLi9sb2ctbGlzdGVuZXJcIjo5LFwiLi91dGlsc1wiOjEwfV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxlc3MsIG9wdGlvbnMpIHtcblxuICAgIHZhciBsb2dMZXZlbF9kZWJ1ZyA9IDQsXG4gICAgICAgIGxvZ0xldmVsX2luZm8gPSAzLFxuICAgICAgICBsb2dMZXZlbF93YXJuID0gMixcbiAgICAgICAgbG9nTGV2ZWxfZXJyb3IgPSAxO1xuXG4gICAgLy8gVGhlIGFtb3VudCBvZiBsb2dnaW5nIGluIHRoZSBqYXZhc2NyaXB0IGNvbnNvbGUuXG4gICAgLy8gMyAtIERlYnVnLCBpbmZvcm1hdGlvbiBhbmQgZXJyb3JzXG4gICAgLy8gMiAtIEluZm9ybWF0aW9uIGFuZCBlcnJvcnNcbiAgICAvLyAxIC0gRXJyb3JzXG4gICAgLy8gMCAtIE5vbmVcbiAgICAvLyBEZWZhdWx0cyB0byAyXG4gICAgb3B0aW9ucy5sb2dMZXZlbCA9IHR5cGVvZiBvcHRpb25zLmxvZ0xldmVsICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubG9nTGV2ZWwgOiAob3B0aW9ucy5lbnYgPT09ICdkZXZlbG9wbWVudCcgPyAgbG9nTGV2ZWxfaW5mbyA6IGxvZ0xldmVsX2Vycm9yKTtcblxuICAgIGlmICghb3B0aW9ucy5sb2dnZXJzKSB7XG4gICAgICAgIG9wdGlvbnMubG9nZ2VycyA9IFt7XG4gICAgICAgICAgICBkZWJ1ZzogZnVuY3Rpb24obXNnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9nTGV2ZWwgPj0gbG9nTGV2ZWxfZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5mbzogZnVuY3Rpb24obXNnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9nTGV2ZWwgPj0gbG9nTGV2ZWxfaW5mbykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3YXJuOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2dMZXZlbCA+PSBsb2dMZXZlbF93YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24obXNnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9nTGV2ZWwgPj0gbG9nTGV2ZWxfZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5sb2dnZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxlc3MubG9nZ2VyLmFkZExpc3RlbmVyKG9wdGlvbnMubG9nZ2Vyc1tpXSk7XG4gICAgfVxufTtcblxufSx7fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZXh0cmFjdElkOiBmdW5jdGlvbihocmVmKSB7XG4gICAgICAgIHJldHVybiBocmVmLnJlcGxhY2UoL15bYS16LV0rOlxcLys/W15cXC9dKy8sICcnKSAgLy8gUmVtb3ZlIHByb3RvY29sICYgZG9tYWluXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcP1xcJl1saXZlcmVsb2FkPVxcdysvLCAnJykgICAgICAgIC8vIFJlbW92ZSBMaXZlUmVsb2FkIGNhY2hlYnVzdGVyXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxcLy8sICcnKSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcm9vdCAvXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwuW2EtekEtWl0rJC8sICcnKSAgICAgICAgICAgICAgICAvLyBSZW1vdmUgc2ltcGxlIGV4dGVuc2lvblxuICAgICAgICAgICAgLnJlcGxhY2UoL1teXFwuXFx3LV0rL2csICctJykgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgaWxsZWdhbCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwuL2csICc6Jyk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGRvdHMgd2l0aCBjb2xvbnMoZm9yIHZhbGlkIGlkKVxuICAgIH0sXG4gICAgYWRkRGF0YUF0dHI6IGZ1bmN0aW9uKG9wdGlvbnMsIHRhZykge1xuICAgICAgICBmb3IgKHZhciBvcHQgaW4gdGFnLmRhdGFzZXQpIHtcbiAgICAgICAgICAgIGlmICh0YWcuZGF0YXNldC5oYXNPd25Qcm9wZXJ0eShvcHQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdCA9PT0gXCJlbnZcIiB8fCBvcHQgPT09IFwiZHVtcExpbmVOdW1iZXJzXCIgfHwgb3B0ID09PSBcInJvb3RwYXRoXCIgfHwgb3B0ID09PSBcImVycm9yUmVwb3J0aW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tvcHRdID0gdGFnLmRhdGFzZXRbb3B0XTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tvcHRdID0gSlNPTi5wYXJzZSh0YWcuZGF0YXNldFtvcHRdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaChfKSB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbn0se31dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBjb250ZXh0cyA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBjb250ZXh0cztcblxudmFyIGNvcHlGcm9tT3JpZ2luYWwgPSBmdW5jdGlvbiBjb3B5RnJvbU9yaWdpbmFsKG9yaWdpbmFsLCBkZXN0aW5hdGlvbiwgcHJvcGVydGllc1RvQ29weSkge1xuICAgIGlmICghb3JpZ2luYWwpIHsgcmV0dXJuOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXNUb0NvcHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG9yaWdpbmFsLmhhc093blByb3BlcnR5KHByb3BlcnRpZXNUb0NvcHlbaV0pKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0aWVzVG9Db3B5W2ldXSA9IG9yaWdpbmFsW3Byb3BlcnRpZXNUb0NvcHlbaV1dO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLypcbiBwYXJzZSBpcyB1c2VkIHdoaWxzdCBwYXJzaW5nXG4gKi9cbnZhciBwYXJzZUNvcHlQcm9wZXJ0aWVzID0gW1xuICAgIC8vIG9wdGlvbnNcbiAgICAncGF0aHMnLCAgICAgICAgICAgIC8vIG9wdGlvbiAtIHVubW9kaWZpZWQgLSBwYXRocyB0byBzZWFyY2ggZm9yIGltcG9ydHMgb25cbiAgICAncmVsYXRpdmVVcmxzJywgICAgIC8vIG9wdGlvbiAtIHdoZXRoZXIgdG8gYWRqdXN0IFVSTCdzIHRvIGJlIHJlbGF0aXZlXG4gICAgJ3Jvb3RwYXRoJywgICAgICAgICAvLyBvcHRpb24gLSByb290cGF0aCB0byBhcHBlbmQgdG8gVVJMJ3NcbiAgICAnc3RyaWN0SW1wb3J0cycsICAgIC8vIG9wdGlvbiAtXG4gICAgJ2luc2VjdXJlJywgICAgICAgICAvLyBvcHRpb24gLSB3aGV0aGVyIHRvIGFsbG93IGltcG9ydHMgZnJvbSBpbnNlY3VyZSBzc2wgaG9zdHNcbiAgICAnZHVtcExpbmVOdW1iZXJzJywgIC8vIG9wdGlvbiAtIHdoZXRoZXIgdG8gZHVtcCBsaW5lIG51bWJlcnNcbiAgICAnY29tcHJlc3MnLCAgICAgICAgIC8vIG9wdGlvbiAtIHdoZXRoZXIgdG8gY29tcHJlc3NcbiAgICAnc3luY0ltcG9ydCcsICAgICAgIC8vIG9wdGlvbiAtIHdoZXRoZXIgdG8gaW1wb3J0IHN5bmNocm9ub3VzbHlcbiAgICAnY2h1bmtJbnB1dCcsICAgICAgIC8vIG9wdGlvbiAtIHdoZXRoZXIgdG8gY2h1bmsgaW5wdXQuIG1vcmUgcGVyZm9ybWFudCBidXQgY2F1c2VzIHBhcnNlIGlzc3Vlcy5cbiAgICAnbWltZScsICAgICAgICAgICAgIC8vIGJyb3dzZXIgb25seSAtIG1pbWUgdHlwZSBmb3Igc2hlZXQgaW1wb3J0XG4gICAgJ3VzZUZpbGVDYWNoZScsICAgICAvLyBicm93c2VyIG9ubHkgLSB3aGV0aGVyIHRvIHVzZSB0aGUgcGVyIGZpbGUgc2Vzc2lvbiBjYWNoZVxuICAgIC8vIGNvbnRleHRcbiAgICAncHJvY2Vzc0ltcG9ydHMnLCAgIC8vIG9wdGlvbiAmIGNvbnRleHQgLSB3aGV0aGVyIHRvIHByb2Nlc3MgaW1wb3J0cy4gaWYgZmFsc2UgdGhlbiBpbXBvcnRzIHdpbGwgbm90IGJlIGltcG9ydGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlZCBieSB0aGUgaW1wb3J0IG1hbmFnZXIgdG8gc3RvcCBtdWx0aXBsZSBpbXBvcnQgdmlzaXRvcnMgYmVpbmcgY3JlYXRlZC5cbiAgICAncGx1Z2luTWFuYWdlcicgICAgIC8vIFVzZWQgYXMgdGhlIHBsdWdpbiBtYW5hZ2VyIGZvciB0aGUgc2Vzc2lvblxuXTtcblxuY29udGV4dHMuUGFyc2UgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgY29weUZyb21PcmlnaW5hbChvcHRpb25zLCB0aGlzLCBwYXJzZUNvcHlQcm9wZXJ0aWVzKTtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5wYXRocyA9PT0gXCJzdHJpbmdcIikgeyB0aGlzLnBhdGhzID0gW3RoaXMucGF0aHNdOyB9XG59O1xuXG52YXIgZXZhbENvcHlQcm9wZXJ0aWVzID0gW1xuICAgICdwYXRocycsICAgICAgICAgIC8vIGFkZGl0aW9uYWwgaW5jbHVkZSBwYXRoc1xuICAgICdjb21wcmVzcycsICAgICAgIC8vIHdoZXRoZXIgdG8gY29tcHJlc3NcbiAgICAnaWVDb21wYXQnLCAgICAgICAvLyB3aGV0aGVyIHRvIGVuZm9yY2UgSUUgY29tcGF0aWJpbGl0eSAoSUU4IGRhdGEtdXJpKVxuICAgICdzdHJpY3RNYXRoJywgICAgIC8vIHdoZXRoZXIgbWF0aCBoYXMgdG8gYmUgd2l0aGluIHBhcmVudGhlc2lzXG4gICAgJ3N0cmljdFVuaXRzJywgICAgLy8gd2hldGhlciB1bml0cyBuZWVkIHRvIGV2YWx1YXRlIGNvcnJlY3RseVxuICAgICdzb3VyY2VNYXAnLCAgICAgIC8vIHdoZXRoZXIgdG8gb3V0cHV0IGEgc291cmNlIG1hcFxuICAgICdpbXBvcnRNdWx0aXBsZScsIC8vIHdoZXRoZXIgd2UgYXJlIGN1cnJlbnRseSBpbXBvcnRpbmcgbXVsdGlwbGUgY29waWVzXG4gICAgJ3VybEFyZ3MnLCAgICAgICAgLy8gd2hldGhlciB0byBhZGQgYXJncyBpbnRvIHVybCB0b2tlbnNcbiAgICAnamF2YXNjcmlwdEVuYWJsZWQnLC8vIG9wdGlvbiAtIHdoZXRoZXIgSmF2YVNjcmlwdCBpcyBlbmFibGVkLiBpZiB1bmRlZmluZWQsIGRlZmF1bHRzIHRvIHRydWVcbiAgICAncGx1Z2luTWFuYWdlcicsICAvLyBVc2VkIGFzIHRoZSBwbHVnaW4gbWFuYWdlciBmb3IgdGhlIHNlc3Npb25cbiAgICAnaW1wb3J0YW50U2NvcGUnICAvLyB1c2VkIHRvIGJ1YmJsZSB1cCAhaW1wb3J0YW50IHN0YXRlbWVudHNcbiAgICBdO1xuXG5jb250ZXh0cy5FdmFsID0gZnVuY3Rpb24ob3B0aW9ucywgZnJhbWVzKSB7XG4gICAgY29weUZyb21PcmlnaW5hbChvcHRpb25zLCB0aGlzLCBldmFsQ29weVByb3BlcnRpZXMpO1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLnBhdGhzID09PSBcInN0cmluZ1wiKSB7IHRoaXMucGF0aHMgPSBbdGhpcy5wYXRoc107IH1cblxuICAgIHRoaXMuZnJhbWVzID0gZnJhbWVzIHx8IFtdO1xuICAgIHRoaXMuaW1wb3J0YW50U2NvcGUgPSB0aGlzLmltcG9ydGFudFNjb3BlIHx8IFtdO1xufTtcblxuY29udGV4dHMuRXZhbC5wcm90b3R5cGUuaW5QYXJlbnRoZXNpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW5zU3RhY2spIHtcbiAgICAgICAgdGhpcy5wYXJlbnNTdGFjayA9IFtdO1xuICAgIH1cbiAgICB0aGlzLnBhcmVuc1N0YWNrLnB1c2godHJ1ZSk7XG59O1xuXG5jb250ZXh0cy5FdmFsLnByb3RvdHlwZS5vdXRPZlBhcmVudGhlc2lzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucGFyZW5zU3RhY2sucG9wKCk7XG59O1xuXG5jb250ZXh0cy5FdmFsLnByb3RvdHlwZS5pc01hdGhPbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpY3RNYXRoID8gKHRoaXMucGFyZW5zU3RhY2sgJiYgdGhpcy5wYXJlbnNTdGFjay5sZW5ndGgpIDogdHJ1ZTtcbn07XG5cbmNvbnRleHRzLkV2YWwucHJvdG90eXBlLmlzUGF0aFJlbGF0aXZlID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICByZXR1cm4gIS9eKD86W2Etei1dKzp8XFwvfCMpL2kudGVzdChwYXRoKTtcbn07XG5cbmNvbnRleHRzLkV2YWwucHJvdG90eXBlLm5vcm1hbGl6ZVBhdGggPSBmdW5jdGlvbiggcGF0aCApIHtcbiAgICB2YXJcbiAgICAgIHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIikucmV2ZXJzZSgpLFxuICAgICAgc2VnbWVudDtcblxuICAgIHBhdGggPSBbXTtcbiAgICB3aGlsZSAoc2VnbWVudHMubGVuZ3RoICE9PSAwICkge1xuICAgICAgICBzZWdtZW50ID0gc2VnbWVudHMucG9wKCk7XG4gICAgICAgIHN3aXRjaCggc2VnbWVudCApIHtcbiAgICAgICAgICAgIGNhc2UgXCIuXCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiLi5cIjpcbiAgICAgICAgICAgICAgICBpZiAoKHBhdGgubGVuZ3RoID09PSAwKSB8fCAocGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSBcIi4uXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaCggc2VnbWVudCApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2goIHNlZ21lbnQgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXRoLmpvaW4oXCIvXCIpO1xufTtcblxuLy90b2RvIC0gZG8gdGhlIHNhbWUgZm9yIHRoZSB0b0NTUyA/XG5cbn0se31dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdhbGljZWJsdWUnOicjZjBmOGZmJyxcbiAgICAnYW50aXF1ZXdoaXRlJzonI2ZhZWJkNycsXG4gICAgJ2FxdWEnOicjMDBmZmZmJyxcbiAgICAnYXF1YW1hcmluZSc6JyM3ZmZmZDQnLFxuICAgICdhenVyZSc6JyNmMGZmZmYnLFxuICAgICdiZWlnZSc6JyNmNWY1ZGMnLFxuICAgICdiaXNxdWUnOicjZmZlNGM0JyxcbiAgICAnYmxhY2snOicjMDAwMDAwJyxcbiAgICAnYmxhbmNoZWRhbG1vbmQnOicjZmZlYmNkJyxcbiAgICAnYmx1ZSc6JyMwMDAwZmYnLFxuICAgICdibHVldmlvbGV0JzonIzhhMmJlMicsXG4gICAgJ2Jyb3duJzonI2E1MmEyYScsXG4gICAgJ2J1cmx5d29vZCc6JyNkZWI4ODcnLFxuICAgICdjYWRldGJsdWUnOicjNWY5ZWEwJyxcbiAgICAnY2hhcnRyZXVzZSc6JyM3ZmZmMDAnLFxuICAgICdjaG9jb2xhdGUnOicjZDI2OTFlJyxcbiAgICAnY29yYWwnOicjZmY3ZjUwJyxcbiAgICAnY29ybmZsb3dlcmJsdWUnOicjNjQ5NWVkJyxcbiAgICAnY29ybnNpbGsnOicjZmZmOGRjJyxcbiAgICAnY3JpbXNvbic6JyNkYzE0M2MnLFxuICAgICdjeWFuJzonIzAwZmZmZicsXG4gICAgJ2RhcmtibHVlJzonIzAwMDA4YicsXG4gICAgJ2RhcmtjeWFuJzonIzAwOGI4YicsXG4gICAgJ2Rhcmtnb2xkZW5yb2QnOicjYjg4NjBiJyxcbiAgICAnZGFya2dyYXknOicjYTlhOWE5JyxcbiAgICAnZGFya2dyZXknOicjYTlhOWE5JyxcbiAgICAnZGFya2dyZWVuJzonIzAwNjQwMCcsXG4gICAgJ2RhcmtraGFraSc6JyNiZGI3NmInLFxuICAgICdkYXJrbWFnZW50YSc6JyM4YjAwOGInLFxuICAgICdkYXJrb2xpdmVncmVlbic6JyM1NTZiMmYnLFxuICAgICdkYXJrb3JhbmdlJzonI2ZmOGMwMCcsXG4gICAgJ2RhcmtvcmNoaWQnOicjOTkzMmNjJyxcbiAgICAnZGFya3JlZCc6JyM4YjAwMDAnLFxuICAgICdkYXJrc2FsbW9uJzonI2U5OTY3YScsXG4gICAgJ2RhcmtzZWFncmVlbic6JyM4ZmJjOGYnLFxuICAgICdkYXJrc2xhdGVibHVlJzonIzQ4M2Q4YicsXG4gICAgJ2RhcmtzbGF0ZWdyYXknOicjMmY0ZjRmJyxcbiAgICAnZGFya3NsYXRlZ3JleSc6JyMyZjRmNGYnLFxuICAgICdkYXJrdHVycXVvaXNlJzonIzAwY2VkMScsXG4gICAgJ2Rhcmt2aW9sZXQnOicjOTQwMGQzJyxcbiAgICAnZGVlcHBpbmsnOicjZmYxNDkzJyxcbiAgICAnZGVlcHNreWJsdWUnOicjMDBiZmZmJyxcbiAgICAnZGltZ3JheSc6JyM2OTY5NjknLFxuICAgICdkaW1ncmV5JzonIzY5Njk2OScsXG4gICAgJ2RvZGdlcmJsdWUnOicjMWU5MGZmJyxcbiAgICAnZmlyZWJyaWNrJzonI2IyMjIyMicsXG4gICAgJ2Zsb3JhbHdoaXRlJzonI2ZmZmFmMCcsXG4gICAgJ2ZvcmVzdGdyZWVuJzonIzIyOGIyMicsXG4gICAgJ2Z1Y2hzaWEnOicjZmYwMGZmJyxcbiAgICAnZ2FpbnNib3JvJzonI2RjZGNkYycsXG4gICAgJ2dob3N0d2hpdGUnOicjZjhmOGZmJyxcbiAgICAnZ29sZCc6JyNmZmQ3MDAnLFxuICAgICdnb2xkZW5yb2QnOicjZGFhNTIwJyxcbiAgICAnZ3JheSc6JyM4MDgwODAnLFxuICAgICdncmV5JzonIzgwODA4MCcsXG4gICAgJ2dyZWVuJzonIzAwODAwMCcsXG4gICAgJ2dyZWVueWVsbG93JzonI2FkZmYyZicsXG4gICAgJ2hvbmV5ZGV3JzonI2YwZmZmMCcsXG4gICAgJ2hvdHBpbmsnOicjZmY2OWI0JyxcbiAgICAnaW5kaWFucmVkJzonI2NkNWM1YycsXG4gICAgJ2luZGlnbyc6JyM0YjAwODInLFxuICAgICdpdm9yeSc6JyNmZmZmZjAnLFxuICAgICdraGFraSc6JyNmMGU2OGMnLFxuICAgICdsYXZlbmRlcic6JyNlNmU2ZmEnLFxuICAgICdsYXZlbmRlcmJsdXNoJzonI2ZmZjBmNScsXG4gICAgJ2xhd25ncmVlbic6JyM3Y2ZjMDAnLFxuICAgICdsZW1vbmNoaWZmb24nOicjZmZmYWNkJyxcbiAgICAnbGlnaHRibHVlJzonI2FkZDhlNicsXG4gICAgJ2xpZ2h0Y29yYWwnOicjZjA4MDgwJyxcbiAgICAnbGlnaHRjeWFuJzonI2UwZmZmZicsXG4gICAgJ2xpZ2h0Z29sZGVucm9keWVsbG93JzonI2ZhZmFkMicsXG4gICAgJ2xpZ2h0Z3JheSc6JyNkM2QzZDMnLFxuICAgICdsaWdodGdyZXknOicjZDNkM2QzJyxcbiAgICAnbGlnaHRncmVlbic6JyM5MGVlOTAnLFxuICAgICdsaWdodHBpbmsnOicjZmZiNmMxJyxcbiAgICAnbGlnaHRzYWxtb24nOicjZmZhMDdhJyxcbiAgICAnbGlnaHRzZWFncmVlbic6JyMyMGIyYWEnLFxuICAgICdsaWdodHNreWJsdWUnOicjODdjZWZhJyxcbiAgICAnbGlnaHRzbGF0ZWdyYXknOicjNzc4ODk5JyxcbiAgICAnbGlnaHRzbGF0ZWdyZXknOicjNzc4ODk5JyxcbiAgICAnbGlnaHRzdGVlbGJsdWUnOicjYjBjNGRlJyxcbiAgICAnbGlnaHR5ZWxsb3cnOicjZmZmZmUwJyxcbiAgICAnbGltZSc6JyMwMGZmMDAnLFxuICAgICdsaW1lZ3JlZW4nOicjMzJjZDMyJyxcbiAgICAnbGluZW4nOicjZmFmMGU2JyxcbiAgICAnbWFnZW50YSc6JyNmZjAwZmYnLFxuICAgICdtYXJvb24nOicjODAwMDAwJyxcbiAgICAnbWVkaXVtYXF1YW1hcmluZSc6JyM2NmNkYWEnLFxuICAgICdtZWRpdW1ibHVlJzonIzAwMDBjZCcsXG4gICAgJ21lZGl1bW9yY2hpZCc6JyNiYTU1ZDMnLFxuICAgICdtZWRpdW1wdXJwbGUnOicjOTM3MGQ4JyxcbiAgICAnbWVkaXVtc2VhZ3JlZW4nOicjM2NiMzcxJyxcbiAgICAnbWVkaXVtc2xhdGVibHVlJzonIzdiNjhlZScsXG4gICAgJ21lZGl1bXNwcmluZ2dyZWVuJzonIzAwZmE5YScsXG4gICAgJ21lZGl1bXR1cnF1b2lzZSc6JyM0OGQxY2MnLFxuICAgICdtZWRpdW12aW9sZXRyZWQnOicjYzcxNTg1JyxcbiAgICAnbWlkbmlnaHRibHVlJzonIzE5MTk3MCcsXG4gICAgJ21pbnRjcmVhbSc6JyNmNWZmZmEnLFxuICAgICdtaXN0eXJvc2UnOicjZmZlNGUxJyxcbiAgICAnbW9jY2FzaW4nOicjZmZlNGI1JyxcbiAgICAnbmF2YWpvd2hpdGUnOicjZmZkZWFkJyxcbiAgICAnbmF2eSc6JyMwMDAwODAnLFxuICAgICdvbGRsYWNlJzonI2ZkZjVlNicsXG4gICAgJ29saXZlJzonIzgwODAwMCcsXG4gICAgJ29saXZlZHJhYic6JyM2YjhlMjMnLFxuICAgICdvcmFuZ2UnOicjZmZhNTAwJyxcbiAgICAnb3JhbmdlcmVkJzonI2ZmNDUwMCcsXG4gICAgJ29yY2hpZCc6JyNkYTcwZDYnLFxuICAgICdwYWxlZ29sZGVucm9kJzonI2VlZThhYScsXG4gICAgJ3BhbGVncmVlbic6JyM5OGZiOTgnLFxuICAgICdwYWxldHVycXVvaXNlJzonI2FmZWVlZScsXG4gICAgJ3BhbGV2aW9sZXRyZWQnOicjZDg3MDkzJyxcbiAgICAncGFwYXlhd2hpcCc6JyNmZmVmZDUnLFxuICAgICdwZWFjaHB1ZmYnOicjZmZkYWI5JyxcbiAgICAncGVydSc6JyNjZDg1M2YnLFxuICAgICdwaW5rJzonI2ZmYzBjYicsXG4gICAgJ3BsdW0nOicjZGRhMGRkJyxcbiAgICAncG93ZGVyYmx1ZSc6JyNiMGUwZTYnLFxuICAgICdwdXJwbGUnOicjODAwMDgwJyxcbiAgICAncmViZWNjYXB1cnBsZSc6JyM2NjMzOTknLFxuICAgICdyZWQnOicjZmYwMDAwJyxcbiAgICAncm9zeWJyb3duJzonI2JjOGY4ZicsXG4gICAgJ3JveWFsYmx1ZSc6JyM0MTY5ZTEnLFxuICAgICdzYWRkbGVicm93bic6JyM4YjQ1MTMnLFxuICAgICdzYWxtb24nOicjZmE4MDcyJyxcbiAgICAnc2FuZHlicm93bic6JyNmNGE0NjAnLFxuICAgICdzZWFncmVlbic6JyMyZThiNTcnLFxuICAgICdzZWFzaGVsbCc6JyNmZmY1ZWUnLFxuICAgICdzaWVubmEnOicjYTA1MjJkJyxcbiAgICAnc2lsdmVyJzonI2MwYzBjMCcsXG4gICAgJ3NreWJsdWUnOicjODdjZWViJyxcbiAgICAnc2xhdGVibHVlJzonIzZhNWFjZCcsXG4gICAgJ3NsYXRlZ3JheSc6JyM3MDgwOTAnLFxuICAgICdzbGF0ZWdyZXknOicjNzA4MDkwJyxcbiAgICAnc25vdyc6JyNmZmZhZmEnLFxuICAgICdzcHJpbmdncmVlbic6JyMwMGZmN2YnLFxuICAgICdzdGVlbGJsdWUnOicjNDY4MmI0JyxcbiAgICAndGFuJzonI2QyYjQ4YycsXG4gICAgJ3RlYWwnOicjMDA4MDgwJyxcbiAgICAndGhpc3RsZSc6JyNkOGJmZDgnLFxuICAgICd0b21hdG8nOicjZmY2MzQ3JyxcbiAgICAndHVycXVvaXNlJzonIzQwZTBkMCcsXG4gICAgJ3Zpb2xldCc6JyNlZTgyZWUnLFxuICAgICd3aGVhdCc6JyNmNWRlYjMnLFxuICAgICd3aGl0ZSc6JyNmZmZmZmYnLFxuICAgICd3aGl0ZXNtb2tlJzonI2Y1ZjVmNScsXG4gICAgJ3llbGxvdyc6JyNmZmZmMDAnLFxuICAgICd5ZWxsb3dncmVlbic6JyM5YWNkMzInXG59O1xufSx7fV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY29sb3JzOiByZXF1aXJlKFwiLi9jb2xvcnNcIiksXG4gICAgdW5pdENvbnZlcnNpb25zOiByZXF1aXJlKFwiLi91bml0LWNvbnZlcnNpb25zXCIpXG59O1xuXG59LHtcIi4vY29sb3JzXCI6MTIsXCIuL3VuaXQtY29udmVyc2lvbnNcIjoxNH1dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGxlbmd0aDoge1xuICAgICAgICAnbSc6IDEsXG4gICAgICAgICdjbSc6IDAuMDEsXG4gICAgICAgICdtbSc6IDAuMDAxLFxuICAgICAgICAnaW4nOiAwLjAyNTQsXG4gICAgICAgICdweCc6IDAuMDI1NCAvIDk2LFxuICAgICAgICAncHQnOiAwLjAyNTQgLyA3MixcbiAgICAgICAgJ3BjJzogMC4wMjU0IC8gNzIgKiAxMlxuICAgIH0sXG4gICAgZHVyYXRpb246IHtcbiAgICAgICAgJ3MnOiAxLFxuICAgICAgICAnbXMnOiAwLjAwMVxuICAgIH0sXG4gICAgYW5nbGU6IHtcbiAgICAgICAgJ3JhZCc6IDEgLyAoMiAqIE1hdGguUEkpLFxuICAgICAgICAnZGVnJzogMSAvIDM2MCxcbiAgICAgICAgJ2dyYWQnOiAxIC8gNDAwLFxuICAgICAgICAndHVybic6IDFcbiAgICB9XG59O1xufSx7fV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGFic3RyYWN0RmlsZU1hbmFnZXIgPSBmdW5jdGlvbigpIHtcbn07XG5cbmFic3RyYWN0RmlsZU1hbmFnZXIucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcbiAgICB2YXIgaiA9IGZpbGVuYW1lLmxhc3RJbmRleE9mKCc/Jyk7XG4gICAgaWYgKGogPiAwKSB7XG4gICAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWUuc2xpY2UoMCwgaik7XG4gICAgfVxuICAgIGogPSBmaWxlbmFtZS5sYXN0SW5kZXhPZignLycpO1xuICAgIGlmIChqIDwgMCkge1xuICAgICAgICBqID0gZmlsZW5hbWUubGFzdEluZGV4T2YoJ1xcXFwnKTtcbiAgICB9XG4gICAgaWYgKGogPCAwKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gZmlsZW5hbWUuc2xpY2UoMCwgaiArIDEpO1xufTtcblxuYWJzdHJhY3RGaWxlTWFuYWdlci5wcm90b3R5cGUudHJ5QXBwZW5kRXh0ZW5zaW9uID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gICAgcmV0dXJuIC8oXFwuW2Etel0qJCl8KFtcXD87XS4qKSQvLnRlc3QocGF0aCkgPyBwYXRoIDogcGF0aCArIGV4dDtcbn07XG5cbmFic3RyYWN0RmlsZU1hbmFnZXIucHJvdG90eXBlLnRyeUFwcGVuZExlc3NFeHRlbnNpb24gPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5QXBwZW5kRXh0ZW5zaW9uKHBhdGgsICcubGVzcycpO1xufTtcblxuYWJzdHJhY3RGaWxlTWFuYWdlci5wcm90b3R5cGUuc3VwcG9ydHNTeW5jID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuYWJzdHJhY3RGaWxlTWFuYWdlci5wcm90b3R5cGUuYWx3YXlzTWFrZVBhdGhzQWJzb2x1dGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5hYnN0cmFjdEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5pc1BhdGhBYnNvbHV0ZSA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gICAgcmV0dXJuICgvXig/OlthLXotXSs6fFxcL3xcXFxcfCMpL2kpLnRlc3QoZmlsZW5hbWUpO1xufTtcblxuYWJzdHJhY3RGaWxlTWFuYWdlci5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uKGJhc2VQYXRoLCBsYXRlclBhdGgpIHtcbiAgICBpZiAoIWJhc2VQYXRoKSB7XG4gICAgICAgIHJldHVybiBsYXRlclBhdGg7XG4gICAgfVxuICAgIHJldHVybiBiYXNlUGF0aCArIGxhdGVyUGF0aDtcbn07XG5hYnN0cmFjdEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5wYXRoRGlmZiA9IGZ1bmN0aW9uIHBhdGhEaWZmKHVybCwgYmFzZVVybCkge1xuICAgIC8vIGRpZmYgYmV0d2VlbiB0d28gcGF0aHMgdG8gY3JlYXRlIGEgcmVsYXRpdmUgcGF0aFxuXG4gICAgdmFyIHVybFBhcnRzID0gdGhpcy5leHRyYWN0VXJsUGFydHModXJsKSxcbiAgICAgICAgYmFzZVVybFBhcnRzID0gdGhpcy5leHRyYWN0VXJsUGFydHMoYmFzZVVybCksXG4gICAgICAgIGksIG1heCwgdXJsRGlyZWN0b3JpZXMsIGJhc2VVcmxEaXJlY3RvcmllcywgZGlmZiA9IFwiXCI7XG4gICAgaWYgKHVybFBhcnRzLmhvc3RQYXJ0ICE9PSBiYXNlVXJsUGFydHMuaG9zdFBhcnQpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIG1heCA9IE1hdGgubWF4KGJhc2VVcmxQYXJ0cy5kaXJlY3Rvcmllcy5sZW5ndGgsIHVybFBhcnRzLmRpcmVjdG9yaWVzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgIGlmIChiYXNlVXJsUGFydHMuZGlyZWN0b3JpZXNbaV0gIT09IHVybFBhcnRzLmRpcmVjdG9yaWVzW2ldKSB7IGJyZWFrOyB9XG4gICAgfVxuICAgIGJhc2VVcmxEaXJlY3RvcmllcyA9IGJhc2VVcmxQYXJ0cy5kaXJlY3Rvcmllcy5zbGljZShpKTtcbiAgICB1cmxEaXJlY3RvcmllcyA9IHVybFBhcnRzLmRpcmVjdG9yaWVzLnNsaWNlKGkpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBiYXNlVXJsRGlyZWN0b3JpZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGRpZmYgKz0gXCIuLi9cIjtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHVybERpcmVjdG9yaWVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBkaWZmICs9IHVybERpcmVjdG9yaWVzW2ldICsgXCIvXCI7XG4gICAgfVxuICAgIHJldHVybiBkaWZmO1xufTtcbi8vIGhlbHBlciBmdW5jdGlvbiwgbm90IHBhcnQgb2YgQVBJXG5hYnN0cmFjdEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5leHRyYWN0VXJsUGFydHMgPSBmdW5jdGlvbiBleHRyYWN0VXJsUGFydHModXJsLCBiYXNlVXJsKSB7XG4gICAgLy8gdXJsUGFydHNbMV0gPSBwcm90b2NvbDovL2hvc3RuYW1lLyBPUiAvXG4gICAgLy8gdXJsUGFydHNbMl0gPSAvIGlmIHBhdGggcmVsYXRpdmUgdG8gaG9zdCBiYXNlXG4gICAgLy8gdXJsUGFydHNbM10gPSBkaXJlY3Rvcmllc1xuICAgIC8vIHVybFBhcnRzWzRdID0gZmlsZW5hbWVcbiAgICAvLyB1cmxQYXJ0c1s1XSA9IHBhcmFtZXRlcnNcblxuICAgIHZhciB1cmxQYXJ0c1JlZ2V4ID0gL14oKD86W2Etei1dKzopP1xcL3syfSg/OlteXFwvXFw/I10qXFwvKXwoW1xcL1xcXFxdKSk/KCg/OlteXFwvXFxcXFxcPyNdKltcXC9cXFxcXSkqKShbXlxcL1xcXFxcXD8jXSopKFsjXFw/XS4qKT8kL2ksXG4gICAgICAgIHVybFBhcnRzID0gdXJsLm1hdGNoKHVybFBhcnRzUmVnZXgpLFxuICAgICAgICByZXR1cm5lciA9IHt9LCBkaXJlY3RvcmllcyA9IFtdLCBpLCBiYXNlVXJsUGFydHM7XG5cbiAgICBpZiAoIXVybFBhcnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSBzaGVldCBocmVmIC0gJ1wiICsgdXJsICsgXCInXCIpO1xuICAgIH1cblxuICAgIC8vIFN0eWxlc2hlZXRzIGluIElFIGRvbid0IGFsd2F5cyByZXR1cm4gdGhlIGZ1bGwgcGF0aFxuICAgIGlmIChiYXNlVXJsICYmICghdXJsUGFydHNbMV0gfHwgdXJsUGFydHNbMl0pKSB7XG4gICAgICAgIGJhc2VVcmxQYXJ0cyA9IGJhc2VVcmwubWF0Y2godXJsUGFydHNSZWdleCk7XG4gICAgICAgIGlmICghYmFzZVVybFBhcnRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcGFyc2UgcGFnZSB1cmwgLSAnXCIgKyBiYXNlVXJsICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIHVybFBhcnRzWzFdID0gdXJsUGFydHNbMV0gfHwgYmFzZVVybFBhcnRzWzFdIHx8IFwiXCI7XG4gICAgICAgIGlmICghdXJsUGFydHNbMl0pIHtcbiAgICAgICAgICAgIHVybFBhcnRzWzNdID0gYmFzZVVybFBhcnRzWzNdICsgdXJsUGFydHNbM107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXJsUGFydHNbM10pIHtcbiAgICAgICAgZGlyZWN0b3JpZXMgPSB1cmxQYXJ0c1szXS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKS5zcGxpdChcIi9cIik7XG5cbiAgICAgICAgLy8gZXh0cmFjdCBvdXQgLiBiZWZvcmUgLi4gc28gLi4gZG9lc24ndCBhYnNvcmIgYSBub24tZGlyZWN0b3J5XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkaXJlY3Rvcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGRpcmVjdG9yaWVzW2ldID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgIGRpcmVjdG9yaWVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGlyZWN0b3JpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rvcmllc1tpXSA9PT0gXCIuLlwiICYmIGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0b3JpZXMuc3BsaWNlKGkgLSAxLCAyKTtcbiAgICAgICAgICAgICAgICBpIC09IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm5lci5ob3N0UGFydCA9IHVybFBhcnRzWzFdO1xuICAgIHJldHVybmVyLmRpcmVjdG9yaWVzID0gZGlyZWN0b3JpZXM7XG4gICAgcmV0dXJuZXIucGF0aCA9ICh1cmxQYXJ0c1sxXSB8fCBcIlwiKSArIGRpcmVjdG9yaWVzLmpvaW4oXCIvXCIpO1xuICAgIHJldHVybmVyLmZpbGVVcmwgPSByZXR1cm5lci5wYXRoICsgKHVybFBhcnRzWzRdIHx8IFwiXCIpO1xuICAgIHJldHVybmVyLnVybCA9IHJldHVybmVyLmZpbGVVcmwgKyAodXJsUGFydHNbNV0gfHwgXCJcIik7XG4gICAgcmV0dXJuIHJldHVybmVyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhYnN0cmFjdEZpbGVNYW5hZ2VyO1xuXG59LHt9XSwxNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgbG9nZ2VyID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcbnZhciBlbnZpcm9ubWVudCA9IGZ1bmN0aW9uKGV4dGVybmFsRW52aXJvbm1lbnQsIGZpbGVNYW5hZ2Vycykge1xuICAgIHRoaXMuZmlsZU1hbmFnZXJzID0gZmlsZU1hbmFnZXJzIHx8IFtdO1xuICAgIGV4dGVybmFsRW52aXJvbm1lbnQgPSBleHRlcm5hbEVudmlyb25tZW50IHx8IHt9O1xuXG4gICAgdmFyIG9wdGlvbmFsRnVuY3Rpb25zID0gW1wiZW5jb2RlQmFzZTY0XCIsIFwibWltZUxvb2t1cFwiLCBcImNoYXJzZXRMb29rdXBcIiwgXCJnZXRTb3VyY2VNYXBHZW5lcmF0b3JcIl0sXG4gICAgICAgIHJlcXVpcmVkRnVuY3Rpb25zID0gW10sXG4gICAgICAgIGZ1bmN0aW9ucyA9IHJlcXVpcmVkRnVuY3Rpb25zLmNvbmNhdChvcHRpb25hbEZ1bmN0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBmdW5jdGlvbnNbaV0sXG4gICAgICAgICAgICBlbnZpcm9ubWVudEZ1bmMgPSBleHRlcm5hbEVudmlyb25tZW50W3Byb3BOYW1lXTtcbiAgICAgICAgaWYgKGVudmlyb25tZW50RnVuYykge1xuICAgICAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBlbnZpcm9ubWVudEZ1bmMuYmluZChleHRlcm5hbEVudmlyb25tZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChpIDwgcmVxdWlyZWRGdW5jdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oXCJtaXNzaW5nIHJlcXVpcmVkIGZ1bmN0aW9uIGluIGVudmlyb25tZW50IC0gXCIgKyBwcm9wTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5lbnZpcm9ubWVudC5wcm90b3R5cGUuZ2V0RmlsZU1hbmFnZXIgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGN1cnJlbnREaXJlY3RvcnksIG9wdGlvbnMsIGVudmlyb25tZW50LCBpc1N5bmMpIHtcblxuICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJnZXRGaWxlTWFuYWdlciBjYWxsZWQgd2l0aCBubyBmaWxlbmFtZS4uIFBsZWFzZSByZXBvcnQgdGhpcyBpc3N1ZS4gY29udGludWluZy5cIik7XG4gICAgfVxuICAgIGlmIChjdXJyZW50RGlyZWN0b3J5ID09IG51bGwpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJnZXRGaWxlTWFuYWdlciBjYWxsZWQgd2l0aCBudWxsIGRpcmVjdG9yeS4uIFBsZWFzZSByZXBvcnQgdGhpcyBpc3N1ZS4gY29udGludWluZy5cIik7XG4gICAgfVxuXG4gICAgdmFyIGZpbGVNYW5hZ2VycyA9IHRoaXMuZmlsZU1hbmFnZXJzO1xuICAgIGlmIChvcHRpb25zLnBsdWdpbk1hbmFnZXIpIHtcbiAgICAgICAgZmlsZU1hbmFnZXJzID0gW10uY29uY2F0KGZpbGVNYW5hZ2VycykuY29uY2F0KG9wdGlvbnMucGx1Z2luTWFuYWdlci5nZXRGaWxlTWFuYWdlcnMoKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSBmaWxlTWFuYWdlcnMubGVuZ3RoIC0gMTsgaSA+PSAwIDsgaS0tKSB7XG4gICAgICAgIHZhciBmaWxlTWFuYWdlciA9IGZpbGVNYW5hZ2Vyc1tpXTtcbiAgICAgICAgaWYgKGZpbGVNYW5hZ2VyW2lzU3luYyA/IFwic3VwcG9ydHNTeW5jXCIgOiBcInN1cHBvcnRzXCJdKGZpbGVuYW1lLCBjdXJyZW50RGlyZWN0b3J5LCBvcHRpb25zLCBlbnZpcm9ubWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlTWFuYWdlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmVudmlyb25tZW50LnByb3RvdHlwZS5hZGRGaWxlTWFuYWdlciA9IGZ1bmN0aW9uIChmaWxlTWFuYWdlcikge1xuICAgIHRoaXMuZmlsZU1hbmFnZXJzLnB1c2goZmlsZU1hbmFnZXIpO1xufTtcblxuZW52aXJvbm1lbnQucHJvdG90eXBlLmNsZWFyRmlsZU1hbmFnZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmlsZU1hbmFnZXJzID0gW107XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVudmlyb25tZW50O1xuXG59LHtcIi4uL2xvZ2dlclwiOjMzfV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIENvbG9yID0gcmVxdWlyZShcIi4uL3RyZWUvY29sb3JcIiksXG4gICAgZnVuY3Rpb25SZWdpc3RyeSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uLXJlZ2lzdHJ5XCIpO1xuXG4vLyBDb2xvciBCbGVuZGluZ1xuLy8gcmVmOiBodHRwOi8vd3d3LnczLm9yZy9UUi9jb21wb3NpdGluZy0xXG5cbmZ1bmN0aW9uIGNvbG9yQmxlbmQobW9kZSwgY29sb3IxLCBjb2xvcjIpIHtcbiAgICB2YXIgYWIgPSBjb2xvcjEuYWxwaGEsIGNiLCAvLyBiYWNrZHJvcFxuICAgICAgICBhcyA9IGNvbG9yMi5hbHBoYSwgY3MsIC8vIHNvdXJjZVxuICAgICAgICBhciwgY3IsIHIgPSBbXTsgICAgICAgIC8vIHJlc3VsdFxuXG4gICAgYXIgPSBhcyArIGFiICogKDEgLSBhcyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgY2IgPSBjb2xvcjEucmdiW2ldIC8gMjU1O1xuICAgICAgICBjcyA9IGNvbG9yMi5yZ2JbaV0gLyAyNTU7XG4gICAgICAgIGNyID0gbW9kZShjYiwgY3MpO1xuICAgICAgICBpZiAoYXIpIHtcbiAgICAgICAgICAgIGNyID0gKGFzICogY3MgKyBhYiAqIChjYiAtXG4gICAgICAgICAgICAgICAgICBhcyAqIChjYiArIGNzIC0gY3IpKSkgLyBhcjtcbiAgICAgICAgfVxuICAgICAgICByW2ldID0gY3IgKiAyNTU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb2xvcihyLCBhcik7XG59XG5cbnZhciBjb2xvckJsZW5kTW9kZUZ1bmN0aW9ucyA9IHtcbiAgICBtdWx0aXBseTogZnVuY3Rpb24oY2IsIGNzKSB7XG4gICAgICAgIHJldHVybiBjYiAqIGNzO1xuICAgIH0sXG4gICAgc2NyZWVuOiBmdW5jdGlvbihjYiwgY3MpIHtcbiAgICAgICAgcmV0dXJuIGNiICsgY3MgLSBjYiAqIGNzO1xuICAgIH0sXG4gICAgb3ZlcmxheTogZnVuY3Rpb24oY2IsIGNzKSB7XG4gICAgICAgIGNiICo9IDI7XG4gICAgICAgIHJldHVybiAoY2IgPD0gMSkgP1xuICAgICAgICAgICAgY29sb3JCbGVuZE1vZGVGdW5jdGlvbnMubXVsdGlwbHkoY2IsIGNzKSA6XG4gICAgICAgICAgICBjb2xvckJsZW5kTW9kZUZ1bmN0aW9ucy5zY3JlZW4oY2IgLSAxLCBjcyk7XG4gICAgfSxcbiAgICBzb2Z0bGlnaHQ6IGZ1bmN0aW9uKGNiLCBjcykge1xuICAgICAgICB2YXIgZCA9IDEsIGUgPSBjYjtcbiAgICAgICAgaWYgKGNzID4gMC41KSB7XG4gICAgICAgICAgICBlID0gMTtcbiAgICAgICAgICAgIGQgPSAoY2IgPiAwLjI1KSA/IE1hdGguc3FydChjYilcbiAgICAgICAgICAgICAgICA6ICgoMTYgKiBjYiAtIDEyKSAqIGNiICsgNCkgKiBjYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2IgLSAoMSAtIDIgKiBjcykgKiBlICogKGQgLSBjYik7XG4gICAgfSxcbiAgICBoYXJkbGlnaHQ6IGZ1bmN0aW9uKGNiLCBjcykge1xuICAgICAgICByZXR1cm4gY29sb3JCbGVuZE1vZGVGdW5jdGlvbnMub3ZlcmxheShjcywgY2IpO1xuICAgIH0sXG4gICAgZGlmZmVyZW5jZTogZnVuY3Rpb24oY2IsIGNzKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhjYiAtIGNzKTtcbiAgICB9LFxuICAgIGV4Y2x1c2lvbjogZnVuY3Rpb24oY2IsIGNzKSB7XG4gICAgICAgIHJldHVybiBjYiArIGNzIC0gMiAqIGNiICogY3M7XG4gICAgfSxcblxuICAgIC8vIG5vbi13M2MgZnVuY3Rpb25zOlxuICAgIGF2ZXJhZ2U6IGZ1bmN0aW9uKGNiLCBjcykge1xuICAgICAgICByZXR1cm4gKGNiICsgY3MpIC8gMjtcbiAgICB9LFxuICAgIG5lZ2F0aW9uOiBmdW5jdGlvbihjYiwgY3MpIHtcbiAgICAgICAgcmV0dXJuIDEgLSBNYXRoLmFicyhjYiArIGNzIC0gMSk7XG4gICAgfVxufTtcblxuZm9yICh2YXIgZiBpbiBjb2xvckJsZW5kTW9kZUZ1bmN0aW9ucykge1xuICAgIGlmIChjb2xvckJsZW5kTW9kZUZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShmKSkge1xuICAgICAgICBjb2xvckJsZW5kW2ZdID0gY29sb3JCbGVuZC5iaW5kKG51bGwsIGNvbG9yQmxlbmRNb2RlRnVuY3Rpb25zW2ZdKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uUmVnaXN0cnkuYWRkTXVsdGlwbGUoY29sb3JCbGVuZCk7XG5cbn0se1wiLi4vdHJlZS9jb2xvclwiOjUwLFwiLi9mdW5jdGlvbi1yZWdpc3RyeVwiOjIyfV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIERpbWVuc2lvbiA9IHJlcXVpcmUoXCIuLi90cmVlL2RpbWVuc2lvblwiKSxcbiAgICBDb2xvciA9IHJlcXVpcmUoXCIuLi90cmVlL2NvbG9yXCIpLFxuICAgIFF1b3RlZCA9IHJlcXVpcmUoXCIuLi90cmVlL3F1b3RlZFwiKSxcbiAgICBBbm9ueW1vdXMgPSByZXF1aXJlKFwiLi4vdHJlZS9hbm9ueW1vdXNcIiksXG4gICAgZnVuY3Rpb25SZWdpc3RyeSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uLXJlZ2lzdHJ5XCIpLFxuICAgIGNvbG9yRnVuY3Rpb25zO1xuXG5mdW5jdGlvbiBjbGFtcCh2YWwpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgdmFsKSk7XG59XG5mdW5jdGlvbiBoc2xhKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yRnVuY3Rpb25zLmhzbGEoY29sb3IuaCwgY29sb3IucywgY29sb3IubCwgY29sb3IuYSk7XG59XG5mdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmIChuIGluc3RhbmNlb2YgRGltZW5zaW9uKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG4udW5pdC5pcygnJScpID8gbi52YWx1ZSAvIDEwMCA6IG4udmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHtcbiAgICAgICAgICAgIHR5cGU6IFwiQXJndW1lbnRcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiY29sb3IgZnVuY3Rpb25zIHRha2UgbnVtYmVycyBhcyBwYXJhbWV0ZXJzXCJcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBzY2FsZWQobiwgc2l6ZSkge1xuICAgIGlmIChuIGluc3RhbmNlb2YgRGltZW5zaW9uICYmIG4udW5pdC5pcygnJScpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG4udmFsdWUgKiBzaXplIC8gMTAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVtYmVyKG4pO1xuICAgIH1cbn1cbmNvbG9yRnVuY3Rpb25zID0ge1xuICAgIHJnYjogZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yRnVuY3Rpb25zLnJnYmEociwgZywgYiwgMS4wKTtcbiAgICB9LFxuICAgIHJnYmE6IGZ1bmN0aW9uIChyLCBnLCBiLCBhKSB7XG4gICAgICAgIHZhciByZ2IgPSBbciwgZywgYl0ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBzY2FsZWQoYywgMjU1KTsgfSk7XG4gICAgICAgIGEgPSBudW1iZXIoYSk7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IocmdiLCBhKTtcbiAgICB9LFxuICAgIGhzbDogZnVuY3Rpb24gKGgsIHMsIGwpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yRnVuY3Rpb25zLmhzbGEoaCwgcywgbCwgMS4wKTtcbiAgICB9LFxuICAgIGhzbGE6IGZ1bmN0aW9uIChoLCBzLCBsLCBhKSB7XG5cbiAgICAgICAgdmFyIG0xLCBtMjtcblxuICAgICAgICBmdW5jdGlvbiBodWUoaCkge1xuICAgICAgICAgICAgaCA9IGggPCAwID8gaCArIDEgOiAoaCA+IDEgPyBoIC0gMSA6IGgpO1xuICAgICAgICAgICAgaWYgKGggKiA2IDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggKiA2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaCAqIDIgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG0yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaCAqIDMgPCAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIgLyAzIC0gaCkgKiA2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaCA9IChudW1iZXIoaCkgJSAzNjApIC8gMzYwO1xuICAgICAgICBzID0gY2xhbXAobnVtYmVyKHMpKTsgbCA9IGNsYW1wKG51bWJlcihsKSk7IGEgPSBjbGFtcChudW1iZXIoYSkpO1xuXG4gICAgICAgIG0yID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIG0xID0gbCAqIDIgLSBtMjtcblxuICAgICAgICByZXR1cm4gY29sb3JGdW5jdGlvbnMucmdiYShodWUoaCArIDEgLyAzKSAqIDI1NSxcbiAgICAgICAgICAgIGh1ZShoKSAgICAgICAqIDI1NSxcbiAgICAgICAgICAgIGh1ZShoIC0gMSAvIDMpICogMjU1LFxuICAgICAgICAgICAgYSk7XG4gICAgfSxcblxuICAgIGhzdjogZnVuY3Rpb24oaCwgcywgdikge1xuICAgICAgICByZXR1cm4gY29sb3JGdW5jdGlvbnMuaHN2YShoLCBzLCB2LCAxLjApO1xuICAgIH0sXG5cbiAgICBoc3ZhOiBmdW5jdGlvbihoLCBzLCB2LCBhKSB7XG4gICAgICAgIGggPSAoKG51bWJlcihoKSAlIDM2MCkgLyAzNjApICogMzYwO1xuICAgICAgICBzID0gbnVtYmVyKHMpOyB2ID0gbnVtYmVyKHYpOyBhID0gbnVtYmVyKGEpO1xuXG4gICAgICAgIHZhciBpLCBmO1xuICAgICAgICBpID0gTWF0aC5mbG9vcigoaCAvIDYwKSAlIDYpO1xuICAgICAgICBmID0gKGggLyA2MCkgLSBpO1xuXG4gICAgICAgIHZhciB2cyA9IFt2LFxuICAgICAgICAgICAgdiAqICgxIC0gcyksXG4gICAgICAgICAgICB2ICogKDEgLSBmICogcyksXG4gICAgICAgICAgICB2ICogKDEgLSAoMSAtIGYpICogcyldO1xuICAgICAgICB2YXIgcGVybSA9IFtbMCwgMywgMV0sXG4gICAgICAgICAgICBbMiwgMCwgMV0sXG4gICAgICAgICAgICBbMSwgMCwgM10sXG4gICAgICAgICAgICBbMSwgMiwgMF0sXG4gICAgICAgICAgICBbMywgMSwgMF0sXG4gICAgICAgICAgICBbMCwgMSwgMl1dO1xuXG4gICAgICAgIHJldHVybiBjb2xvckZ1bmN0aW9ucy5yZ2JhKHZzW3Blcm1baV1bMF1dICogMjU1LFxuICAgICAgICAgICAgdnNbcGVybVtpXVsxXV0gKiAyNTUsXG4gICAgICAgICAgICB2c1twZXJtW2ldWzJdXSAqIDI1NSxcbiAgICAgICAgICAgIGEpO1xuICAgIH0sXG5cbiAgICBodWU6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihjb2xvci50b0hTTCgpLmgpO1xuICAgIH0sXG4gICAgc2F0dXJhdGlvbjogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGNvbG9yLnRvSFNMKCkucyAqIDEwMCwgJyUnKTtcbiAgICB9LFxuICAgIGxpZ2h0bmVzczogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGNvbG9yLnRvSFNMKCkubCAqIDEwMCwgJyUnKTtcbiAgICB9LFxuICAgIGhzdmh1ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oY29sb3IudG9IU1YoKS5oKTtcbiAgICB9LFxuICAgIGhzdnNhdHVyYXRpb246IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihjb2xvci50b0hTVigpLnMgKiAxMDAsICclJyk7XG4gICAgfSxcbiAgICBoc3Z2YWx1ZTogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGNvbG9yLnRvSFNWKCkudiAqIDEwMCwgJyUnKTtcbiAgICB9LFxuICAgIHJlZDogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGNvbG9yLnJnYlswXSk7XG4gICAgfSxcbiAgICBncmVlbjogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGNvbG9yLnJnYlsxXSk7XG4gICAgfSxcbiAgICBibHVlOiBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oY29sb3IucmdiWzJdKTtcbiAgICB9LFxuICAgIGFscGhhOiBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oY29sb3IudG9IU0woKS5hKTtcbiAgICB9LFxuICAgIGx1bWE6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihjb2xvci5sdW1hKCkgKiBjb2xvci5hbHBoYSAqIDEwMCwgJyUnKTtcbiAgICB9LFxuICAgIGx1bWluYW5jZTogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHZhciBsdW1pbmFuY2UgPVxuICAgICAgICAgICAgKDAuMjEyNiAqIGNvbG9yLnJnYlswXSAvIDI1NSkgK1xuICAgICAgICAgICAgICAgICgwLjcxNTIgKiBjb2xvci5yZ2JbMV0gLyAyNTUpICtcbiAgICAgICAgICAgICAgICAoMC4wNzIyICogY29sb3IucmdiWzJdIC8gMjU1KTtcblxuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihsdW1pbmFuY2UgKiBjb2xvci5hbHBoYSAqIDEwMCwgJyUnKTtcbiAgICB9LFxuICAgIHNhdHVyYXRlOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCwgbWV0aG9kKSB7XG4gICAgICAgIC8vIGZpbHRlcjogc2F0dXJhdGUoMy4yKTtcbiAgICAgICAgLy8gc2hvdWxkIGJlIGtlcHQgYXMgaXMsIHNvIGNoZWNrIGZvciBjb2xvclxuICAgICAgICBpZiAoIWNvbG9yLnJnYikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhzbCA9IGNvbG9yLnRvSFNMKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09IFwidW5kZWZpbmVkXCIgJiYgbWV0aG9kLnZhbHVlID09PSBcInJlbGF0aXZlXCIpIHtcbiAgICAgICAgICAgIGhzbC5zICs9ICBoc2wucyAqIGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhzbC5zICs9IGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgICBoc2wucyA9IGNsYW1wKGhzbC5zKTtcbiAgICAgICAgcmV0dXJuIGhzbGEoaHNsKTtcbiAgICB9LFxuICAgIGRlc2F0dXJhdGU6IGZ1bmN0aW9uIChjb2xvciwgYW1vdW50LCBtZXRob2QpIHtcbiAgICAgICAgdmFyIGhzbCA9IGNvbG9yLnRvSFNMKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09IFwidW5kZWZpbmVkXCIgJiYgbWV0aG9kLnZhbHVlID09PSBcInJlbGF0aXZlXCIpIHtcbiAgICAgICAgICAgIGhzbC5zIC09ICBoc2wucyAqIGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhzbC5zIC09IGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgICBoc2wucyA9IGNsYW1wKGhzbC5zKTtcbiAgICAgICAgcmV0dXJuIGhzbGEoaHNsKTtcbiAgICB9LFxuICAgIGxpZ2h0ZW46IGZ1bmN0aW9uIChjb2xvciwgYW1vdW50LCBtZXRob2QpIHtcbiAgICAgICAgdmFyIGhzbCA9IGNvbG9yLnRvSFNMKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09IFwidW5kZWZpbmVkXCIgJiYgbWV0aG9kLnZhbHVlID09PSBcInJlbGF0aXZlXCIpIHtcbiAgICAgICAgICAgIGhzbC5sICs9ICBoc2wubCAqIGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhzbC5sICs9IGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgICBoc2wubCA9IGNsYW1wKGhzbC5sKTtcbiAgICAgICAgcmV0dXJuIGhzbGEoaHNsKTtcbiAgICB9LFxuICAgIGRhcmtlbjogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQsIG1ldGhvZCkge1xuICAgICAgICB2YXIgaHNsID0gY29sb3IudG9IU0woKTtcblxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtZXRob2QudmFsdWUgPT09IFwicmVsYXRpdmVcIikge1xuICAgICAgICAgICAgaHNsLmwgLT0gIGhzbC5sICogYW1vdW50LnZhbHVlIC8gMTAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaHNsLmwgLT0gYW1vdW50LnZhbHVlIC8gMTAwO1xuICAgICAgICB9XG4gICAgICAgIGhzbC5sID0gY2xhbXAoaHNsLmwpO1xuICAgICAgICByZXR1cm4gaHNsYShoc2wpO1xuICAgIH0sXG4gICAgZmFkZWluOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCwgbWV0aG9kKSB7XG4gICAgICAgIHZhciBoc2wgPSBjb2xvci50b0hTTCgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSBcInVuZGVmaW5lZFwiICYmIG1ldGhvZC52YWx1ZSA9PT0gXCJyZWxhdGl2ZVwiKSB7XG4gICAgICAgICAgICBoc2wuYSArPSAgaHNsLmEgKiBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoc2wuYSArPSBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgaHNsLmEgPSBjbGFtcChoc2wuYSk7XG4gICAgICAgIHJldHVybiBoc2xhKGhzbCk7XG4gICAgfSxcbiAgICBmYWRlb3V0OiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCwgbWV0aG9kKSB7XG4gICAgICAgIHZhciBoc2wgPSBjb2xvci50b0hTTCgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSBcInVuZGVmaW5lZFwiICYmIG1ldGhvZC52YWx1ZSA9PT0gXCJyZWxhdGl2ZVwiKSB7XG4gICAgICAgICAgICBoc2wuYSAtPSAgaHNsLmEgKiBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoc2wuYSAtPSBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgaHNsLmEgPSBjbGFtcChoc2wuYSk7XG4gICAgICAgIHJldHVybiBoc2xhKGhzbCk7XG4gICAgfSxcbiAgICBmYWRlOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCkge1xuICAgICAgICB2YXIgaHNsID0gY29sb3IudG9IU0woKTtcblxuICAgICAgICBoc2wuYSA9IGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgaHNsLmEgPSBjbGFtcChoc2wuYSk7XG4gICAgICAgIHJldHVybiBoc2xhKGhzbCk7XG4gICAgfSxcbiAgICBzcGluOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCkge1xuICAgICAgICB2YXIgaHNsID0gY29sb3IudG9IU0woKTtcbiAgICAgICAgdmFyIGh1ZSA9IChoc2wuaCArIGFtb3VudC52YWx1ZSkgJSAzNjA7XG5cbiAgICAgICAgaHNsLmggPSBodWUgPCAwID8gMzYwICsgaHVlIDogaHVlO1xuXG4gICAgICAgIHJldHVybiBoc2xhKGhzbCk7XG4gICAgfSxcbiAgICAvL1xuICAgIC8vIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEhhbXB0b24gQ2F0bGluLCBOYXRhbGllIFdlaXplbmJhdW0sIGFuZCBDaHJpcyBFcHBzdGVpblxuICAgIC8vIGh0dHA6Ly9zYXNzLWxhbmcuY29tXG4gICAgLy9cbiAgICBtaXg6IGZ1bmN0aW9uIChjb2xvcjEsIGNvbG9yMiwgd2VpZ2h0KSB7XG4gICAgICAgIGlmICghY29sb3IxLnRvSFNMIHx8ICFjb2xvcjIudG9IU0wpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvbG9yMi50eXBlKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZGlyKGNvbG9yMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3ZWlnaHQpIHtcbiAgICAgICAgICAgIHdlaWdodCA9IG5ldyBEaW1lbnNpb24oNTApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwID0gd2VpZ2h0LnZhbHVlIC8gMTAwLjA7XG4gICAgICAgIHZhciB3ID0gcCAqIDIgLSAxO1xuICAgICAgICB2YXIgYSA9IGNvbG9yMS50b0hTTCgpLmEgLSBjb2xvcjIudG9IU0woKS5hO1xuXG4gICAgICAgIHZhciB3MSA9ICgoKHcgKiBhID09IC0xKSA/IHcgOiAodyArIGEpIC8gKDEgKyB3ICogYSkpICsgMSkgLyAyLjA7XG4gICAgICAgIHZhciB3MiA9IDEgLSB3MTtcblxuICAgICAgICB2YXIgcmdiID0gW2NvbG9yMS5yZ2JbMF0gKiB3MSArIGNvbG9yMi5yZ2JbMF0gKiB3MixcbiAgICAgICAgICAgIGNvbG9yMS5yZ2JbMV0gKiB3MSArIGNvbG9yMi5yZ2JbMV0gKiB3MixcbiAgICAgICAgICAgIGNvbG9yMS5yZ2JbMl0gKiB3MSArIGNvbG9yMi5yZ2JbMl0gKiB3Ml07XG5cbiAgICAgICAgdmFyIGFscGhhID0gY29sb3IxLmFscGhhICogcCArIGNvbG9yMi5hbHBoYSAqICgxIC0gcCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyZ2IsIGFscGhhKTtcbiAgICB9LFxuICAgIGdyZXlzY2FsZTogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBjb2xvckZ1bmN0aW9ucy5kZXNhdHVyYXRlKGNvbG9yLCBuZXcgRGltZW5zaW9uKDEwMCkpO1xuICAgIH0sXG4gICAgY29udHJhc3Q6IGZ1bmN0aW9uIChjb2xvciwgZGFyaywgbGlnaHQsIHRocmVzaG9sZCkge1xuICAgICAgICAvLyBmaWx0ZXI6IGNvbnRyYXN0KDMuMik7XG4gICAgICAgIC8vIHNob3VsZCBiZSBrZXB0IGFzIGlzLCBzbyBjaGVjayBmb3IgY29sb3JcbiAgICAgICAgaWYgKCFjb2xvci5yZ2IpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGlnaHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBsaWdodCA9IGNvbG9yRnVuY3Rpb25zLnJnYmEoMjU1LCAyNTUsIDI1NSwgMS4wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRhcmsgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBkYXJrID0gY29sb3JGdW5jdGlvbnMucmdiYSgwLCAwLCAwLCAxLjApO1xuICAgICAgICB9XG4gICAgICAgIC8vRmlndXJlIG91dCB3aGljaCBpcyBhY3R1YWxseSBsaWdodCBhbmQgZGFyayFcbiAgICAgICAgaWYgKGRhcmsubHVtYSgpID4gbGlnaHQubHVtYSgpKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGxpZ2h0O1xuICAgICAgICAgICAgbGlnaHQgPSBkYXJrO1xuICAgICAgICAgICAgZGFyayA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAwLjQzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyZXNob2xkID0gbnVtYmVyKHRocmVzaG9sZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbG9yLmx1bWEoKSA8IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRhcms7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFyZ2I6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gbmV3IEFub255bW91cyhjb2xvci50b0FSR0IoKSk7XG4gICAgfSxcbiAgICBjb2xvcjogZnVuY3Rpb24oYykge1xuICAgICAgICBpZiAoKGMgaW5zdGFuY2VvZiBRdW90ZWQpICYmXG4gICAgICAgICAgICAoL14jKFthLWYwLTldezZ9fFthLWYwLTldezN9KSQvaS50ZXN0KGMudmFsdWUpKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihjLnZhbHVlLnNsaWNlKDEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGMgaW5zdGFuY2VvZiBDb2xvcikgfHwgKGMgPSBDb2xvci5mcm9tS2V5d29yZChjLnZhbHVlKSkpIHtcbiAgICAgICAgICAgIGMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICB0eXBlOiAgICBcIkFyZ3VtZW50XCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBcImFyZ3VtZW50IG11c3QgYmUgYSBjb2xvciBrZXl3b3JkIG9yIDMvNiBkaWdpdCBoZXggZS5nLiAjRkZGXCJcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRpbnQ6IGZ1bmN0aW9uKGNvbG9yLCBhbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yRnVuY3Rpb25zLm1peChjb2xvckZ1bmN0aW9ucy5yZ2IoMjU1LCAyNTUsIDI1NSksIGNvbG9yLCBhbW91bnQpO1xuICAgIH0sXG4gICAgc2hhZGU6IGZ1bmN0aW9uKGNvbG9yLCBhbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yRnVuY3Rpb25zLm1peChjb2xvckZ1bmN0aW9ucy5yZ2IoMCwgMCwgMCksIGNvbG9yLCBhbW91bnQpO1xuICAgIH1cbn07XG5mdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKGNvbG9yRnVuY3Rpb25zKTtcblxufSx7XCIuLi90cmVlL2Fub255bW91c1wiOjQ2LFwiLi4vdHJlZS9jb2xvclwiOjUwLFwiLi4vdHJlZS9kaW1lbnNpb25cIjo1NixcIi4uL3RyZWUvcXVvdGVkXCI6NzMsXCIuL2Z1bmN0aW9uLXJlZ2lzdHJ5XCI6MjJ9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVudmlyb25tZW50KSB7XG4gICAgdmFyIFF1b3RlZCA9IHJlcXVpcmUoXCIuLi90cmVlL3F1b3RlZFwiKSxcbiAgICAgICAgVVJMID0gcmVxdWlyZShcIi4uL3RyZWUvdXJsXCIpLFxuICAgICAgICBmdW5jdGlvblJlZ2lzdHJ5ID0gcmVxdWlyZShcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIiksXG4gICAgICAgIGZhbGxiYWNrID0gZnVuY3Rpb24oZnVuY3Rpb25UaGlzLCBub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVSTChub2RlLCBmdW5jdGlvblRoaXMuaW5kZXgsIGZ1bmN0aW9uVGhpcy5jdXJyZW50RmlsZUluZm8pLmV2YWwoZnVuY3Rpb25UaGlzLmNvbnRleHQpO1xuICAgICAgICB9LFxuICAgICAgICBsb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcblxuICAgIGZ1bmN0aW9uUmVnaXN0cnkuYWRkKFwiZGF0YS11cmlcIiwgZnVuY3Rpb24obWltZXR5cGVOb2RlLCBmaWxlUGF0aE5vZGUpIHtcblxuICAgICAgICBpZiAoIWZpbGVQYXRoTm9kZSkge1xuICAgICAgICAgICAgZmlsZVBhdGhOb2RlID0gbWltZXR5cGVOb2RlO1xuICAgICAgICAgICAgbWltZXR5cGVOb2RlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW1ldHlwZSA9IG1pbWV0eXBlTm9kZSAmJiBtaW1ldHlwZU5vZGUudmFsdWU7XG4gICAgICAgIHZhciBmaWxlUGF0aCA9IGZpbGVQYXRoTm9kZS52YWx1ZTtcbiAgICAgICAgdmFyIGN1cnJlbnRGaWxlSW5mbyA9IHRoaXMuY3VycmVudEZpbGVJbmZvO1xuICAgICAgICB2YXIgY3VycmVudERpcmVjdG9yeSA9IGN1cnJlbnRGaWxlSW5mby5yZWxhdGl2ZVVybHMgP1xuICAgICAgICAgICAgY3VycmVudEZpbGVJbmZvLmN1cnJlbnREaXJlY3RvcnkgOiBjdXJyZW50RmlsZUluZm8uZW50cnlQYXRoO1xuXG4gICAgICAgIHZhciBmcmFnbWVudFN0YXJ0ID0gZmlsZVBhdGguaW5kZXhPZignIycpO1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSAnJztcbiAgICAgICAgaWYgKGZyYWdtZW50U3RhcnQgIT09IC0xKSB7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGZpbGVQYXRoLnNsaWNlKGZyYWdtZW50U3RhcnQpO1xuICAgICAgICAgICAgZmlsZVBhdGggPSBmaWxlUGF0aC5zbGljZSgwLCBmcmFnbWVudFN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaWxlTWFuYWdlciA9IGVudmlyb25tZW50LmdldEZpbGVNYW5hZ2VyKGZpbGVQYXRoLCBjdXJyZW50RGlyZWN0b3J5LCB0aGlzLmNvbnRleHQsIGVudmlyb25tZW50LCB0cnVlKTtcblxuICAgICAgICBpZiAoIWZpbGVNYW5hZ2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsbGJhY2sodGhpcywgZmlsZVBhdGhOb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1c2VCYXNlNjQgPSBmYWxzZTtcblxuICAgICAgICAvLyBkZXRlY3QgdGhlIG1pbWV0eXBlIGlmIG5vdCBnaXZlblxuICAgICAgICBpZiAoIW1pbWV0eXBlTm9kZSkge1xuXG4gICAgICAgICAgICBtaW1ldHlwZSA9IGVudmlyb25tZW50Lm1pbWVMb29rdXAoZmlsZVBhdGgpO1xuXG4gICAgICAgICAgICBpZiAobWltZXR5cGUgPT09IFwiaW1hZ2Uvc3ZnK3htbFwiKSB7XG4gICAgICAgICAgICAgICAgdXNlQmFzZTY0ID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBiYXNlIDY0IHVubGVzcyBpdCdzIGFuIEFTQ0lJIG9yIFVURi04IGZvcm1hdFxuICAgICAgICAgICAgICAgIHZhciBjaGFyc2V0ID0gZW52aXJvbm1lbnQuY2hhcnNldExvb2t1cChtaW1ldHlwZSk7XG4gICAgICAgICAgICAgICAgdXNlQmFzZTY0ID0gWydVUy1BU0NJSScsICdVVEYtOCddLmluZGV4T2YoY2hhcnNldCkgPCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZUJhc2U2NCkgeyBtaW1ldHlwZSArPSAnO2Jhc2U2NCc7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVzZUJhc2U2NCA9IC87YmFzZTY0JC8udGVzdChtaW1ldHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlsZVN5bmMgPSBmaWxlTWFuYWdlci5sb2FkRmlsZVN5bmMoZmlsZVBhdGgsIGN1cnJlbnREaXJlY3RvcnksIHRoaXMuY29udGV4dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICBpZiAoIWZpbGVTeW5jLmNvbnRlbnRzKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIlNraXBwZWQgZGF0YS11cmkgZW1iZWRkaW5nIG9mIFwiICsgZmlsZVBhdGggKyBcIiBiZWNhdXNlIGZpbGUgbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrKHRoaXMsIGZpbGVQYXRoTm9kZSB8fCBtaW1ldHlwZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWYgPSBmaWxlU3luYy5jb250ZW50cztcbiAgICAgICAgaWYgKHVzZUJhc2U2NCAmJiAhZW52aXJvbm1lbnQuZW5jb2RlQmFzZTY0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsbGJhY2sodGhpcywgZmlsZVBhdGhOb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZiA9IHVzZUJhc2U2NCA/IGVudmlyb25tZW50LmVuY29kZUJhc2U2NChidWYpIDogZW5jb2RlVVJJQ29tcG9uZW50KGJ1Zik7XG5cbiAgICAgICAgdmFyIHVyaSA9IFwiZGF0YTpcIiArIG1pbWV0eXBlICsgJywnICsgYnVmICsgZnJhZ21lbnQ7XG5cbiAgICAgICAgLy8gSUU4IGNhbm5vdCBoYW5kbGUgYSBkYXRhLXVyaSBsYXJnZXIgdGhhbiAzMiw3NjggY2hhcmFjdGVycy4gSWYgdGhpcyBpcyBleGNlZWRlZFxuICAgICAgICAvLyBhbmQgdGhlIC0taWVDb21wYXQgZmxhZyBpcyBlbmFibGVkLCByZXR1cm4gYSBub3JtYWwgdXJsKCkgaW5zdGVhZC5cbiAgICAgICAgdmFyIERBVEFfVVJJX01BWCA9IDMyNzY4O1xuICAgICAgICBpZiAodXJpLmxlbmd0aCA+PSBEQVRBX1VSSV9NQVgpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5pZUNvbXBhdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIlNraXBwZWQgZGF0YS11cmkgZW1iZWRkaW5nIG9mIFwiICsgZmlsZVBhdGggKyBcIiBiZWNhdXNlIGl0cyBzaXplIChcIiArIHVyaS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICAgICBcIiBjaGFyYWN0ZXJzKSBleGNlZWRzIElFOC1zYWZlIFwiICsgREFUQV9VUklfTUFYICsgXCIgY2hhcmFjdGVycyFcIik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsbGJhY2sodGhpcywgZmlsZVBhdGhOb2RlIHx8IG1pbWV0eXBlTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFVSTChuZXcgUXVvdGVkKCdcIicgKyB1cmkgKyAnXCInLCB1cmksIGZhbHNlLCB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbyksIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvKTtcbiAgICB9KTtcbn07XG5cbn0se1wiLi4vbG9nZ2VyXCI6MzMsXCIuLi90cmVlL3F1b3RlZFwiOjczLFwiLi4vdHJlZS91cmxcIjo4MCxcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIjoyMn1dLDIwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBLZXl3b3JkID0gcmVxdWlyZShcIi4uL3RyZWUva2V5d29yZFwiKSxcbiAgICBmdW5jdGlvblJlZ2lzdHJ5ID0gcmVxdWlyZShcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIik7XG5cbnZhciBkZWZhdWx0RnVuYyA9IHtcbiAgICBldmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy52YWx1ZV8sIGUgPSB0aGlzLmVycm9yXztcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHYgPyBLZXl3b3JkLlRydWUgOiBLZXl3b3JkLkZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdGhpcy52YWx1ZV8gPSB2O1xuICAgIH0sXG4gICAgZXJyb3I6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuZXJyb3JfID0gZTtcbiAgICB9LFxuICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmFsdWVfID0gdGhpcy5lcnJvcl8gPSBudWxsO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uUmVnaXN0cnkuYWRkKFwiZGVmYXVsdFwiLCBkZWZhdWx0RnVuYy5ldmFsLmJpbmQoZGVmYXVsdEZ1bmMpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0RnVuYztcblxufSx7XCIuLi90cmVlL2tleXdvcmRcIjo2NSxcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIjoyMn1dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBFeHByZXNzaW9uID0gcmVxdWlyZShcIi4uL3RyZWUvZXhwcmVzc2lvblwiKTtcblxudmFyIGZ1bmN0aW9uQ2FsbGVyID0gZnVuY3Rpb24obmFtZSwgY29udGV4dCwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbykge1xuICAgIHRoaXMubmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmN1cnJlbnRGaWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcblxuICAgIHRoaXMuZnVuYyA9IGNvbnRleHQuZnJhbWVzWzBdLmZ1bmN0aW9uUmVnaXN0cnkuZ2V0KHRoaXMubmFtZSk7XG59O1xuZnVuY3Rpb25DYWxsZXIucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmZ1bmMpO1xufTtcbmZ1bmN0aW9uQ2FsbGVyLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24oYXJncykge1xuXG4gICAgLy8gVGhpcyBjb2RlIGlzIHRlcnJpYmxlIGFuZCBzaG91bGQgYmUgcmVwbGFjZWQgYXMgcGVyIHRoaXMgaXNzdWUuLi5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbGVzcy9sZXNzLmpzL2lzc3Vlcy8yNDc3XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykpIHtcbiAgICAgICAgYXJncyA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcIkNvbW1lbnRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09IFwiRXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1Yk5vZGVzID0gaXRlbS52YWx1ZS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJDb21tZW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJOb2Rlc1swXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV4cHJlc3Npb24oc3ViTm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbkNhbGxlcjtcblxufSx7XCIuLi90cmVlL2V4cHJlc3Npb25cIjo1OX1dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmZ1bmN0aW9uIG1ha2VSZWdpc3RyeSggYmFzZSApIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBfZGF0YToge30sXG4gICAgICAgIGFkZDogZnVuY3Rpb24obmFtZSwgZnVuYykge1xuICAgICAgICAgICAgLy8gcHJlY2F1dGlvbmFyeSBjYXNlIGNvbnZlcnNpb24sIGFzIGxhdGVyIHF1ZXJ5aW5nIG9mXG4gICAgICAgICAgICAvLyB0aGUgcmVnaXN0cnkgYnkgZnVuY3Rpb24tY2FsbGVyIHVzZXMgbG93ZXIgY2FzZSBhcyB3ZWxsLlxuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2RhdGEuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvL1RPRE8gd2FyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGF0YVtuYW1lXSA9IGZ1bmM7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZE11bHRpcGxlOiBmdW5jdGlvbihmdW5jdGlvbnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGZ1bmN0aW9ucykuZm9yRWFjaChcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKG5hbWUsIGZ1bmN0aW9uc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtuYW1lXSB8fCAoIGJhc2UgJiYgYmFzZS5nZXQoIG5hbWUgKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaGVyaXQgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlUmVnaXN0cnkoIHRoaXMgKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFrZVJlZ2lzdHJ5KCBudWxsICk7XG59LHt9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVudmlyb25tZW50KSB7XG4gICAgdmFyIGZ1bmN0aW9ucyA9IHtcbiAgICAgICAgZnVuY3Rpb25SZWdpc3RyeTogcmVxdWlyZShcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIiksXG4gICAgICAgIGZ1bmN0aW9uQ2FsbGVyOiByZXF1aXJlKFwiLi9mdW5jdGlvbi1jYWxsZXJcIilcbiAgICB9O1xuXG4gICAgLy9yZWdpc3RlciBmdW5jdGlvbnNcbiAgICByZXF1aXJlKFwiLi9kZWZhdWx0XCIpO1xuICAgIHJlcXVpcmUoXCIuL2NvbG9yXCIpO1xuICAgIHJlcXVpcmUoXCIuL2NvbG9yLWJsZW5kaW5nXCIpO1xuICAgIHJlcXVpcmUoXCIuL2RhdGEtdXJpXCIpKGVudmlyb25tZW50KTtcbiAgICByZXF1aXJlKFwiLi9tYXRoXCIpO1xuICAgIHJlcXVpcmUoXCIuL251bWJlclwiKTtcbiAgICByZXF1aXJlKFwiLi9zdHJpbmdcIik7XG4gICAgcmVxdWlyZShcIi4vc3ZnXCIpKGVudmlyb25tZW50KTtcbiAgICByZXF1aXJlKFwiLi90eXBlc1wiKTtcblxuICAgIHJldHVybiBmdW5jdGlvbnM7XG59O1xuXG59LHtcIi4vY29sb3JcIjoxOCxcIi4vY29sb3ItYmxlbmRpbmdcIjoxNyxcIi4vZGF0YS11cmlcIjoxOSxcIi4vZGVmYXVsdFwiOjIwLFwiLi9mdW5jdGlvbi1jYWxsZXJcIjoyMSxcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIjoyMixcIi4vbWF0aFwiOjI1LFwiLi9udW1iZXJcIjoyNixcIi4vc3RyaW5nXCI6MjcsXCIuL3N2Z1wiOjI4LFwiLi90eXBlc1wiOjI5fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIERpbWVuc2lvbiA9IHJlcXVpcmUoXCIuLi90cmVlL2RpbWVuc2lvblwiKTtcblxudmFyIE1hdGhIZWxwZXIgPSBmdW5jdGlvbigpIHtcbn07XG5NYXRoSGVscGVyLl9tYXRoID0gZnVuY3Rpb24gKGZuLCB1bml0LCBuKSB7XG4gICAgaWYgKCEobiBpbnN0YW5jZW9mIERpbWVuc2lvbikpIHtcbiAgICAgICAgdGhyb3cgeyB0eXBlOiBcIkFyZ3VtZW50XCIsIG1lc3NhZ2U6IFwiYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlclwiIH07XG4gICAgfVxuICAgIGlmICh1bml0ID09IG51bGwpIHtcbiAgICAgICAgdW5pdCA9IG4udW5pdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuID0gbi51bmlmeSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERpbWVuc2lvbihmbihwYXJzZUZsb2F0KG4udmFsdWUpKSwgdW5pdCk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBNYXRoSGVscGVyO1xufSx7XCIuLi90cmVlL2RpbWVuc2lvblwiOjU2fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGZ1bmN0aW9uUmVnaXN0cnkgPSByZXF1aXJlKFwiLi9mdW5jdGlvbi1yZWdpc3RyeVwiKSxcbiAgICBtYXRoSGVscGVyID0gcmVxdWlyZShcIi4vbWF0aC1oZWxwZXIuanNcIik7XG5cbnZhciBtYXRoRnVuY3Rpb25zID0ge1xuICAgIC8vIG5hbWUsICB1bml0XG4gICAgY2VpbDogIG51bGwsXG4gICAgZmxvb3I6IG51bGwsXG4gICAgc3FydDogIG51bGwsXG4gICAgYWJzOiAgIG51bGwsXG4gICAgdGFuOiAgIFwiXCIsXG4gICAgc2luOiAgIFwiXCIsXG4gICAgY29zOiAgIFwiXCIsXG4gICAgYXRhbjogIFwicmFkXCIsXG4gICAgYXNpbjogIFwicmFkXCIsXG4gICAgYWNvczogIFwicmFkXCJcbn07XG5cbmZvciAodmFyIGYgaW4gbWF0aEZ1bmN0aW9ucykge1xuICAgIGlmIChtYXRoRnVuY3Rpb25zLmhhc093blByb3BlcnR5KGYpKSB7XG4gICAgICAgIG1hdGhGdW5jdGlvbnNbZl0gPSBtYXRoSGVscGVyLl9tYXRoLmJpbmQobnVsbCwgTWF0aFtmXSwgbWF0aEZ1bmN0aW9uc1tmXSk7XG4gICAgfVxufVxuXG5tYXRoRnVuY3Rpb25zLnJvdW5kID0gZnVuY3Rpb24gKG4sIGYpIHtcbiAgICB2YXIgZnJhY3Rpb24gPSB0eXBlb2YgZiA9PT0gXCJ1bmRlZmluZWRcIiA/IDAgOiBmLnZhbHVlO1xuICAgIHJldHVybiBtYXRoSGVscGVyLl9tYXRoKGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtLnRvRml4ZWQoZnJhY3Rpb24pOyB9LCBudWxsLCBuKTtcbn07XG5cbmZ1bmN0aW9uUmVnaXN0cnkuYWRkTXVsdGlwbGUobWF0aEZ1bmN0aW9ucyk7XG5cbn0se1wiLi9mdW5jdGlvbi1yZWdpc3RyeVwiOjIyLFwiLi9tYXRoLWhlbHBlci5qc1wiOjI0fV0sMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIERpbWVuc2lvbiA9IHJlcXVpcmUoXCIuLi90cmVlL2RpbWVuc2lvblwiKSxcbiAgICBBbm9ueW1vdXMgPSByZXF1aXJlKFwiLi4vdHJlZS9hbm9ueW1vdXNcIiksXG4gICAgZnVuY3Rpb25SZWdpc3RyeSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uLXJlZ2lzdHJ5XCIpLFxuICAgIG1hdGhIZWxwZXIgPSByZXF1aXJlKFwiLi9tYXRoLWhlbHBlci5qc1wiKTtcblxudmFyIG1pbk1heCA9IGZ1bmN0aW9uIChpc01pbiwgYXJncykge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcbiAgICBzd2l0Y2goYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOiB0aHJvdyB7IHR5cGU6IFwiQXJndW1lbnRcIiwgbWVzc2FnZTogXCJvbmUgb3IgbW9yZSBhcmd1bWVudHMgcmVxdWlyZWRcIiB9O1xuICAgIH1cbiAgICB2YXIgaSwgaiwgY3VycmVudCwgY3VycmVudFVuaWZpZWQsIHJlZmVyZW5jZVVuaWZpZWQsIHVuaXQsIHVuaXRTdGF0aWMsIHVuaXRDbG9uZSxcbiAgICAgICAgb3JkZXIgID0gW10sIC8vIGVsZW1zIG9ubHkgY29udGFpbnMgb3JpZ2luYWwgYXJndW1lbnQgdmFsdWVzLlxuICAgICAgICB2YWx1ZXMgPSB7fTsgLy8ga2V5IGlzIHRoZSB1bml0LnRvU3RyaW5nKCkgZm9yIHVuaWZpZWQgRGltZW5zaW9uIHZhbHVlcyxcbiAgICAvLyB2YWx1ZSBpcyB0aGUgaW5kZXggaW50byB0aGUgb3JkZXIgYXJyYXkuXG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VycmVudCA9IGFyZ3NbaV07XG4gICAgICAgIGlmICghKGN1cnJlbnQgaW5zdGFuY2VvZiBEaW1lbnNpb24pKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzW2ldLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGFyZ3MsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3NbaV0udmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRVbmlmaWVkID0gY3VycmVudC51bml0LnRvU3RyaW5nKCkgPT09IFwiXCIgJiYgdW5pdENsb25lICE9PSB1bmRlZmluZWQgPyBuZXcgRGltZW5zaW9uKGN1cnJlbnQudmFsdWUsIHVuaXRDbG9uZSkudW5pZnkoKSA6IGN1cnJlbnQudW5pZnkoKTtcbiAgICAgICAgdW5pdCA9IGN1cnJlbnRVbmlmaWVkLnVuaXQudG9TdHJpbmcoKSA9PT0gXCJcIiAmJiB1bml0U3RhdGljICE9PSB1bmRlZmluZWQgPyB1bml0U3RhdGljIDogY3VycmVudFVuaWZpZWQudW5pdC50b1N0cmluZygpO1xuICAgICAgICB1bml0U3RhdGljID0gdW5pdCAhPT0gXCJcIiAmJiB1bml0U3RhdGljID09PSB1bmRlZmluZWQgfHwgdW5pdCAhPT0gXCJcIiAmJiBvcmRlclswXS51bmlmeSgpLnVuaXQudG9TdHJpbmcoKSA9PT0gXCJcIiA/IHVuaXQgOiB1bml0U3RhdGljO1xuICAgICAgICB1bml0Q2xvbmUgPSB1bml0ICE9PSBcIlwiICYmIHVuaXRDbG9uZSA9PT0gdW5kZWZpbmVkID8gY3VycmVudC51bml0LnRvU3RyaW5nKCkgOiB1bml0Q2xvbmU7XG4gICAgICAgIGogPSB2YWx1ZXNbXCJcIl0gIT09IHVuZGVmaW5lZCAmJiB1bml0ICE9PSBcIlwiICYmIHVuaXQgPT09IHVuaXRTdGF0aWMgPyB2YWx1ZXNbXCJcIl0gOiB2YWx1ZXNbdW5pdF07XG4gICAgICAgIGlmIChqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh1bml0U3RhdGljICE9PSB1bmRlZmluZWQgJiYgdW5pdCAhPT0gdW5pdFN0YXRpYykge1xuICAgICAgICAgICAgICAgIHRocm93eyB0eXBlOiBcIkFyZ3VtZW50XCIsIG1lc3NhZ2U6IFwiaW5jb21wYXRpYmxlIHR5cGVzXCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlc1t1bml0XSA9IG9yZGVyLmxlbmd0aDtcbiAgICAgICAgICAgIG9yZGVyLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZWZlcmVuY2VVbmlmaWVkID0gb3JkZXJbal0udW5pdC50b1N0cmluZygpID09PSBcIlwiICYmIHVuaXRDbG9uZSAhPT0gdW5kZWZpbmVkID8gbmV3IERpbWVuc2lvbihvcmRlcltqXS52YWx1ZSwgdW5pdENsb25lKS51bmlmeSgpIDogb3JkZXJbal0udW5pZnkoKTtcbiAgICAgICAgaWYgKCBpc01pbiAmJiBjdXJyZW50VW5pZmllZC52YWx1ZSA8IHJlZmVyZW5jZVVuaWZpZWQudmFsdWUgfHxcbiAgICAgICAgICAgICFpc01pbiAmJiBjdXJyZW50VW5pZmllZC52YWx1ZSA+IHJlZmVyZW5jZVVuaWZpZWQudmFsdWUpIHtcbiAgICAgICAgICAgIG9yZGVyW2pdID0gY3VycmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3JkZXIubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmV0dXJuIG9yZGVyWzBdO1xuICAgIH1cbiAgICBhcmdzID0gb3JkZXIubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLnRvQ1NTKHRoaXMuY29udGV4dCk7IH0pLmpvaW4odGhpcy5jb250ZXh0LmNvbXByZXNzID8gXCIsXCIgOiBcIiwgXCIpO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzKChpc01pbiA/IFwibWluXCIgOiBcIm1heFwiKSArIFwiKFwiICsgYXJncyArIFwiKVwiKTtcbn07XG5mdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKHtcbiAgICBtaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1pbk1heCh0cnVlLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbWF4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtaW5NYXgoZmFsc2UsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBjb252ZXJ0OiBmdW5jdGlvbiAodmFsLCB1bml0KSB7XG4gICAgICAgIHJldHVybiB2YWwuY29udmVydFRvKHVuaXQudmFsdWUpO1xuICAgIH0sXG4gICAgcGk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oTWF0aC5QSSk7XG4gICAgfSxcbiAgICBtb2Q6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oYS52YWx1ZSAlIGIudmFsdWUsIGEudW5pdCk7XG4gICAgfSxcbiAgICBwb3c6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB4ID0gbmV3IERpbWVuc2lvbih4KTtcbiAgICAgICAgICAgIHkgPSBuZXcgRGltZW5zaW9uKHkpO1xuICAgICAgICB9IGVsc2UgaWYgKCEoeCBpbnN0YW5jZW9mIERpbWVuc2lvbikgfHwgISh5IGluc3RhbmNlb2YgRGltZW5zaW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiBcIkFyZ3VtZW50XCIsIG1lc3NhZ2U6IFwiYXJndW1lbnRzIG11c3QgYmUgbnVtYmVyc1wiIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihNYXRoLnBvdyh4LnZhbHVlLCB5LnZhbHVlKSwgeC51bml0KTtcbiAgICB9LFxuICAgIHBlcmNlbnRhZ2U6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBtYXRoSGVscGVyLl9tYXRoKGZ1bmN0aW9uKG51bSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bSAqIDEwMDtcbiAgICAgICAgfSwgJyUnLCBuKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0pO1xuXG59LHtcIi4uL3RyZWUvYW5vbnltb3VzXCI6NDYsXCIuLi90cmVlL2RpbWVuc2lvblwiOjU2LFwiLi9mdW5jdGlvbi1yZWdpc3RyeVwiOjIyLFwiLi9tYXRoLWhlbHBlci5qc1wiOjI0fV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIFF1b3RlZCA9IHJlcXVpcmUoXCIuLi90cmVlL3F1b3RlZFwiKSxcbiAgICBBbm9ueW1vdXMgPSByZXF1aXJlKFwiLi4vdHJlZS9hbm9ueW1vdXNcIiksXG4gICAgSmF2YVNjcmlwdCA9IHJlcXVpcmUoXCIuLi90cmVlL2phdmFzY3JpcHRcIiksXG4gICAgZnVuY3Rpb25SZWdpc3RyeSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uLXJlZ2lzdHJ5XCIpO1xuXG5mdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKHtcbiAgICBlOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzKHN0ciBpbnN0YW5jZW9mIEphdmFTY3JpcHQgPyBzdHIuZXZhbHVhdGVkIDogc3RyLnZhbHVlKTtcbiAgICB9LFxuICAgIGVzY2FwZTogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IEFub255bW91cyhcbiAgICAgICAgICAgIGVuY29kZVVSSShzdHIudmFsdWUpLnJlcGxhY2UoLz0vZywgXCIlM0RcIikucmVwbGFjZSgvOi9nLCBcIiUzQVwiKS5yZXBsYWNlKC8jL2csIFwiJTIzXCIpLnJlcGxhY2UoLzsvZywgXCIlM0JcIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwoL2csIFwiJTI4XCIpLnJlcGxhY2UoL1xcKS9nLCBcIiUyOVwiKSk7XG4gICAgfSxcbiAgICByZXBsYWNlOiBmdW5jdGlvbiAoc3RyaW5nLCBwYXR0ZXJuLCByZXBsYWNlbWVudCwgZmxhZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHN0cmluZy52YWx1ZTtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSAocmVwbGFjZW1lbnQudHlwZSA9PT0gXCJRdW90ZWRcIikgP1xuICAgICAgICAgICAgcmVwbGFjZW1lbnQudmFsdWUgOiByZXBsYWNlbWVudC50b0NTUygpO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShuZXcgUmVnRXhwKHBhdHRlcm4udmFsdWUsIGZsYWdzID8gZmxhZ3MudmFsdWUgOiAnJyksIHJlcGxhY2VtZW50KTtcbiAgICAgICAgcmV0dXJuIG5ldyBRdW90ZWQoc3RyaW5nLnF1b3RlIHx8ICcnLCByZXN1bHQsIHN0cmluZy5lc2NhcGVkKTtcbiAgICB9LFxuICAgICclJzogZnVuY3Rpb24gKHN0cmluZyAvKiBhcmcsIGFyZywgLi4uKi8pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICAgcmVzdWx0ID0gc3RyaW5nLnZhbHVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLypqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSAqL1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoLyVbc2RhXS9pLCBmdW5jdGlvbih0b2tlbikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICgoYXJnc1tpXS50eXBlID09PSBcIlF1b3RlZFwiKSAmJlxuICAgICAgICAgICAgICAgICAgICB0b2tlbi5tYXRjaCgvcy9pKSkgPyBhcmdzW2ldLnZhbHVlIDogYXJnc1tpXS50b0NTUygpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbi5tYXRjaCgvW0EtWl0kLykgPyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvJSUvZywgJyUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBRdW90ZWQoc3RyaW5nLnF1b3RlIHx8ICcnLCByZXN1bHQsIHN0cmluZy5lc2NhcGVkKTtcbiAgICB9XG59KTtcblxufSx7XCIuLi90cmVlL2Fub255bW91c1wiOjQ2LFwiLi4vdHJlZS9qYXZhc2NyaXB0XCI6NjMsXCIuLi90cmVlL3F1b3RlZFwiOjczLFwiLi9mdW5jdGlvbi1yZWdpc3RyeVwiOjIyfV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbnZpcm9ubWVudCkge1xuICAgIHZhciBEaW1lbnNpb24gPSByZXF1aXJlKFwiLi4vdHJlZS9kaW1lbnNpb25cIiksXG4gICAgICAgIENvbG9yID0gcmVxdWlyZShcIi4uL3RyZWUvY29sb3JcIiksXG4gICAgICAgIEV4cHJlc3Npb24gPSByZXF1aXJlKFwiLi4vdHJlZS9leHByZXNzaW9uXCIpLFxuICAgICAgICBRdW90ZWQgPSByZXF1aXJlKFwiLi4vdHJlZS9xdW90ZWRcIiksXG4gICAgICAgIFVSTCA9IHJlcXVpcmUoXCIuLi90cmVlL3VybFwiKSxcbiAgICAgICAgZnVuY3Rpb25SZWdpc3RyeSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uLXJlZ2lzdHJ5XCIpO1xuXG4gICAgZnVuY3Rpb25SZWdpc3RyeS5hZGQoXCJzdmctZ3JhZGllbnRcIiwgZnVuY3Rpb24oZGlyZWN0aW9uKSB7XG5cbiAgICAgICAgdmFyIHN0b3BzLFxuICAgICAgICAgICAgZ3JhZGllbnREaXJlY3Rpb25TdmcsXG4gICAgICAgICAgICBncmFkaWVudFR5cGUgPSBcImxpbmVhclwiLFxuICAgICAgICAgICAgcmVjdGFuZ2xlRGltZW5zaW9uID0gJ3g9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIjFcIiBoZWlnaHQ9XCIxXCInLFxuICAgICAgICAgICAgcmVuZGVyRW52ID0ge2NvbXByZXNzOiBmYWxzZX0sXG4gICAgICAgICAgICByZXR1cm5lcixcbiAgICAgICAgICAgIGRpcmVjdGlvblZhbHVlID0gZGlyZWN0aW9uLnRvQ1NTKHJlbmRlckVudiksXG5cdFx0XHRpLCBjb2xvciwgcG9zaXRpb24sIHBvc2l0aW9uVmFsdWUsIGFscGhhO1xuXG4gICAgICAgIGZ1bmN0aW9uIHRocm93QXJndW1lbnREZXNjcmlwdG9yKCkge1xuICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiBcIkFyZ3VtZW50XCIsXG5cdFx0XHRcdFx0bWVzc2FnZTogXCJzdmctZ3JhZGllbnQgZXhwZWN0cyBkaXJlY3Rpb24sIHN0YXJ0X2NvbG9yIFtzdGFydF9wb3NpdGlvbl0sIFtjb2xvciBwb3NpdGlvbixdLi4uLFwiICtcblx0XHRcdFx0XHRcdFx0XCIgZW5kX2NvbG9yIFtlbmRfcG9zaXRpb25dIG9yIGRpcmVjdGlvbiwgY29sb3IgbGlzdFwiIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzWzFdLnZhbHVlLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0FyZ3VtZW50RGVzY3JpcHRvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcHMgPSBhcmd1bWVudHNbMV0udmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIHRocm93QXJndW1lbnREZXNjcmlwdG9yKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdG9wcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvblZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIFwidG8gYm90dG9tXCI6XG4gICAgICAgICAgICAgICAgZ3JhZGllbnREaXJlY3Rpb25TdmcgPSAneDE9XCIwJVwiIHkxPVwiMCVcIiB4Mj1cIjAlXCIgeTI9XCIxMDAlXCInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInRvIHJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgZ3JhZGllbnREaXJlY3Rpb25TdmcgPSAneDE9XCIwJVwiIHkxPVwiMCVcIiB4Mj1cIjEwMCVcIiB5Mj1cIjAlXCInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInRvIGJvdHRvbSByaWdodFwiOlxuICAgICAgICAgICAgICAgIGdyYWRpZW50RGlyZWN0aW9uU3ZnID0gJ3gxPVwiMCVcIiB5MT1cIjAlXCIgeDI9XCIxMDAlXCIgeTI9XCIxMDAlXCInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInRvIHRvcCByaWdodFwiOlxuICAgICAgICAgICAgICAgIGdyYWRpZW50RGlyZWN0aW9uU3ZnID0gJ3gxPVwiMCVcIiB5MT1cIjEwMCVcIiB4Mj1cIjEwMCVcIiB5Mj1cIjAlXCInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVsbGlwc2VcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlbGxpcHNlIGF0IGNlbnRlclwiOlxuICAgICAgICAgICAgICAgIGdyYWRpZW50VHlwZSA9IFwicmFkaWFsXCI7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnREaXJlY3Rpb25TdmcgPSAnY3g9XCI1MCVcIiBjeT1cIjUwJVwiIHI9XCI3NSVcIic7XG4gICAgICAgICAgICAgICAgcmVjdGFuZ2xlRGltZW5zaW9uID0gJ3g9XCItNTBcIiB5PVwiLTUwXCIgd2lkdGg9XCIxMDFcIiBoZWlnaHQ9XCIxMDFcIic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogXCJBcmd1bWVudFwiLCBtZXNzYWdlOiBcInN2Zy1ncmFkaWVudCBkaXJlY3Rpb24gbXVzdCBiZSAndG8gYm90dG9tJywgJ3RvIHJpZ2h0JyxcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiICd0byBib3R0b20gcmlnaHQnLCAndG8gdG9wIHJpZ2h0JyBvciAnZWxsaXBzZSBhdCBjZW50ZXInXCIgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5lciA9ICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgPz4nICtcbiAgICAgICAgICAgICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2ZXJzaW9uPVwiMS4xXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIHZpZXdCb3g9XCIwIDAgMSAxXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cIm5vbmVcIj4nICtcbiAgICAgICAgICAgICc8JyArIGdyYWRpZW50VHlwZSArICdHcmFkaWVudCBpZD1cImdyYWRpZW50XCIgZ3JhZGllbnRVbml0cz1cInVzZXJTcGFjZU9uVXNlXCIgJyArIGdyYWRpZW50RGlyZWN0aW9uU3ZnICsgJz4nO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzdG9wcy5sZW5ndGg7IGkrPSAxKSB7XG4gICAgICAgICAgICBpZiAoc3RvcHNbaV0gaW5zdGFuY2VvZiBFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBzdG9wc1tpXS52YWx1ZVswXTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHN0b3BzW2ldLnZhbHVlWzFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2xvciA9IHN0b3BzW2ldO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIShjb2xvciBpbnN0YW5jZW9mIENvbG9yKSB8fCAoISgoaSA9PT0gMCB8fCBpICsgMSA9PT0gc3RvcHMubGVuZ3RoKSAmJiBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSAmJiAhKHBvc2l0aW9uIGluc3RhbmNlb2YgRGltZW5zaW9uKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0FyZ3VtZW50RGVzY3JpcHRvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zaXRpb25WYWx1ZSA9IHBvc2l0aW9uID8gcG9zaXRpb24udG9DU1MocmVuZGVyRW52KSA6IGkgPT09IDAgPyBcIjAlXCIgOiBcIjEwMCVcIjtcbiAgICAgICAgICAgIGFscGhhID0gY29sb3IuYWxwaGE7XG4gICAgICAgICAgICByZXR1cm5lciArPSAnPHN0b3Agb2Zmc2V0PVwiJyArIHBvc2l0aW9uVmFsdWUgKyAnXCIgc3RvcC1jb2xvcj1cIicgKyBjb2xvci50b1JHQigpICsgJ1wiJyArIChhbHBoYSA8IDEgPyAnIHN0b3Atb3BhY2l0eT1cIicgKyBhbHBoYSArICdcIicgOiAnJykgKyAnLz4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybmVyICs9ICc8LycgKyBncmFkaWVudFR5cGUgKyAnR3JhZGllbnQ+JyArXG4gICAgICAgICAgICAnPHJlY3QgJyArIHJlY3RhbmdsZURpbWVuc2lvbiArICcgZmlsbD1cInVybCgjZ3JhZGllbnQpXCIgLz48L3N2Zz4nO1xuXG4gICAgICAgIHJldHVybmVyID0gZW5jb2RlVVJJQ29tcG9uZW50KHJldHVybmVyKTtcblxuICAgICAgICByZXR1cm5lciA9IFwiZGF0YTppbWFnZS9zdmcreG1sLFwiICsgcmV0dXJuZXI7XG4gICAgICAgIHJldHVybiBuZXcgVVJMKG5ldyBRdW90ZWQoXCInXCIgKyByZXR1cm5lciArIFwiJ1wiLCByZXR1cm5lciwgZmFsc2UsIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvKSwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8pO1xuICAgIH0pO1xufTtcblxufSx7XCIuLi90cmVlL2NvbG9yXCI6NTAsXCIuLi90cmVlL2RpbWVuc2lvblwiOjU2LFwiLi4vdHJlZS9leHByZXNzaW9uXCI6NTksXCIuLi90cmVlL3F1b3RlZFwiOjczLFwiLi4vdHJlZS91cmxcIjo4MCxcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIjoyMn1dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBLZXl3b3JkID0gcmVxdWlyZShcIi4uL3RyZWUva2V5d29yZFwiKSxcbiAgICBEZXRhY2hlZFJ1bGVzZXQgPSByZXF1aXJlKFwiLi4vdHJlZS9kZXRhY2hlZC1ydWxlc2V0XCIpLFxuICAgIERpbWVuc2lvbiA9IHJlcXVpcmUoXCIuLi90cmVlL2RpbWVuc2lvblwiKSxcbiAgICBDb2xvciA9IHJlcXVpcmUoXCIuLi90cmVlL2NvbG9yXCIpLFxuICAgIFF1b3RlZCA9IHJlcXVpcmUoXCIuLi90cmVlL3F1b3RlZFwiKSxcbiAgICBBbm9ueW1vdXMgPSByZXF1aXJlKFwiLi4vdHJlZS9hbm9ueW1vdXNcIiksXG4gICAgVVJMID0gcmVxdWlyZShcIi4uL3RyZWUvdXJsXCIpLFxuICAgIE9wZXJhdGlvbiA9IHJlcXVpcmUoXCIuLi90cmVlL29wZXJhdGlvblwiKSxcbiAgICBmdW5jdGlvblJlZ2lzdHJ5ID0gcmVxdWlyZShcIi4vZnVuY3Rpb24tcmVnaXN0cnlcIik7XG5cbnZhciBpc2EgPSBmdW5jdGlvbiAobiwgVHlwZSkge1xuICAgICAgICByZXR1cm4gKG4gaW5zdGFuY2VvZiBUeXBlKSA/IEtleXdvcmQuVHJ1ZSA6IEtleXdvcmQuRmFsc2U7XG4gICAgfSxcbiAgICBpc3VuaXQgPSBmdW5jdGlvbiAobiwgdW5pdCkge1xuICAgICAgICBpZiAodW5pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyB7IHR5cGU6IFwiQXJndW1lbnRcIiwgbWVzc2FnZTogXCJtaXNzaW5nIHRoZSByZXF1aXJlZCBzZWNvbmQgYXJndW1lbnQgdG8gaXN1bml0LlwiIH07XG4gICAgICAgIH1cbiAgICAgICAgdW5pdCA9IHR5cGVvZiB1bml0LnZhbHVlID09PSBcInN0cmluZ1wiID8gdW5pdC52YWx1ZSA6IHVuaXQ7XG4gICAgICAgIGlmICh0eXBlb2YgdW5pdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiBcIkFyZ3VtZW50XCIsIG1lc3NhZ2U6IFwiU2Vjb25kIGFyZ3VtZW50IHRvIGlzdW5pdCBzaG91bGQgYmUgYSB1bml0IG9yIGEgc3RyaW5nLlwiIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChuIGluc3RhbmNlb2YgRGltZW5zaW9uKSAmJiBuLnVuaXQuaXModW5pdCkgPyBLZXl3b3JkLlRydWUgOiBLZXl3b3JkLkZhbHNlO1xuICAgIH0sXG4gICAgZ2V0SXRlbXNGcm9tTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgLy8gaGFuZGxlIG5vbi1hcnJheSB2YWx1ZXMgYXMgYW4gYXJyYXkgb2YgbGVuZ3RoIDFcbiAgICAgICAgLy8gcmV0dXJuICd1bmRlZmluZWQnIGlmIGluZGV4IGlzIGludmFsaWRcbiAgICAgICAgdmFyIGl0ZW1zID0gQXJyYXkuaXNBcnJheShub2RlLnZhbHVlKSA/XG4gICAgICAgICAgICBub2RlLnZhbHVlIDogQXJyYXkobm9kZSk7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH07XG5mdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKHtcbiAgICBpc3J1bGVzZXQ6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBpc2EobiwgRGV0YWNoZWRSdWxlc2V0KTtcbiAgICB9LFxuICAgIGlzY29sb3I6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBpc2EobiwgQ29sb3IpO1xuICAgIH0sXG4gICAgaXNudW1iZXI6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBpc2EobiwgRGltZW5zaW9uKTtcbiAgICB9LFxuICAgIGlzc3RyaW5nOiBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gaXNhKG4sIFF1b3RlZCk7XG4gICAgfSxcbiAgICBpc2tleXdvcmQ6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBpc2EobiwgS2V5d29yZCk7XG4gICAgfSxcbiAgICBpc3VybDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIGlzYShuLCBVUkwpO1xuICAgIH0sXG4gICAgaXNwaXhlbDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIGlzdW5pdChuLCAncHgnKTtcbiAgICB9LFxuICAgIGlzcGVyY2VudGFnZTogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIGlzdW5pdChuLCAnJScpO1xuICAgIH0sXG4gICAgaXNlbTogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIGlzdW5pdChuLCAnZW0nKTtcbiAgICB9LFxuICAgIGlzdW5pdDogaXN1bml0LFxuICAgIHVuaXQ6IGZ1bmN0aW9uICh2YWwsIHVuaXQpIHtcbiAgICAgICAgaWYgKCEodmFsIGluc3RhbmNlb2YgRGltZW5zaW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiBcIkFyZ3VtZW50XCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJ0aGUgZmlyc3QgYXJndW1lbnQgdG8gdW5pdCBtdXN0IGJlIGEgbnVtYmVyXCIgK1xuICAgICAgICAgICAgICAgICAgICAodmFsIGluc3RhbmNlb2YgT3BlcmF0aW9uID8gXCIuIEhhdmUgeW91IGZvcmdvdHRlbiBwYXJlbnRoZXNpcz9cIiA6IFwiXCIpIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQpIHtcbiAgICAgICAgICAgIGlmICh1bml0IGluc3RhbmNlb2YgS2V5d29yZCkge1xuICAgICAgICAgICAgICAgIHVuaXQgPSB1bml0LnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bml0ID0gdW5pdC50b0NTUygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pdCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24odmFsLnZhbHVlLCB1bml0KTtcbiAgICB9LFxuICAgIFwiZ2V0LXVuaXRcIjogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXMobi51bml0KTtcbiAgICB9LFxuICAgIGV4dHJhY3Q6IGZ1bmN0aW9uKHZhbHVlcywgaW5kZXgpIHtcbiAgICAgICAgaW5kZXggPSBpbmRleC52YWx1ZSAtIDE7IC8vICgxLWJhc2VkIGluZGV4KVxuXG4gICAgICAgIHJldHVybiBnZXRJdGVtc0Zyb21Ob2RlKHZhbHVlcylbaW5kZXhdO1xuICAgIH0sXG4gICAgbGVuZ3RoOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oZ2V0SXRlbXNGcm9tTm9kZSh2YWx1ZXMpLmxlbmd0aCk7XG4gICAgfVxufSk7XG5cbn0se1wiLi4vdHJlZS9hbm9ueW1vdXNcIjo0NixcIi4uL3RyZWUvY29sb3JcIjo1MCxcIi4uL3RyZWUvZGV0YWNoZWQtcnVsZXNldFwiOjU1LFwiLi4vdHJlZS9kaW1lbnNpb25cIjo1NixcIi4uL3RyZWUva2V5d29yZFwiOjY1LFwiLi4vdHJlZS9vcGVyYXRpb25cIjo3MSxcIi4uL3RyZWUvcXVvdGVkXCI6NzMsXCIuLi90cmVlL3VybFwiOjgwLFwiLi9mdW5jdGlvbi1yZWdpc3RyeVwiOjIyfV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGNvbnRleHRzID0gcmVxdWlyZShcIi4vY29udGV4dHNcIiksXG4gICAgUGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXIvcGFyc2VyJyksXG4gICAgRnVuY3Rpb25JbXBvcnRlciA9IHJlcXVpcmUoJy4vcGx1Z2lucy9mdW5jdGlvbi1pbXBvcnRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVudmlyb25tZW50KSB7XG5cbiAgICAvLyBGaWxlSW5mbyA9IHtcbiAgICAvLyAgJ3JlbGF0aXZlVXJscycgLSBvcHRpb24gLSB3aGV0aGVyIHRvIGFkanVzdCBVUkwncyB0byBiZSByZWxhdGl2ZVxuICAgIC8vICAnZmlsZW5hbWUnIC0gZnVsbCByZXNvbHZlZCBmaWxlbmFtZSBvZiBjdXJyZW50IGZpbGVcbiAgICAvLyAgJ3Jvb3RwYXRoJyAtIHBhdGggdG8gYXBwZW5kIHRvIG5vcm1hbCBVUkxzIGZvciB0aGlzIG5vZGVcbiAgICAvLyAgJ2N1cnJlbnREaXJlY3RvcnknIC0gcGF0aCB0byB0aGUgY3VycmVudCBmaWxlLCBhYnNvbHV0ZVxuICAgIC8vICAncm9vdEZpbGVuYW1lJyAtIGZpbGVuYW1lIG9mIHRoZSBiYXNlIGZpbGVcbiAgICAvLyAgJ2VudHJ5UGF0aCcgLSBhYnNvbHV0ZSBwYXRoIHRvIHRoZSBlbnRyeSBmaWxlXG4gICAgLy8gICdyZWZlcmVuY2UnIC0gd2hldGhlciB0aGUgZmlsZSBzaG91bGQgbm90IGJlIG91dHB1dCBhbmQgb25seSBvdXRwdXQgcGFydHMgdGhhdCBhcmUgcmVmZXJlbmNlZFxuXG4gICAgdmFyIEltcG9ydE1hbmFnZXIgPSBmdW5jdGlvbihjb250ZXh0LCByb290RmlsZUluZm8pIHtcbiAgICAgICAgdGhpcy5yb290RmlsZW5hbWUgPSByb290RmlsZUluZm8uZmlsZW5hbWU7XG4gICAgICAgIHRoaXMucGF0aHMgPSBjb250ZXh0LnBhdGhzIHx8IFtdOyAgLy8gU2VhcmNoIHBhdGhzLCB3aGVuIGltcG9ydGluZ1xuICAgICAgICB0aGlzLmNvbnRlbnRzID0ge307ICAgICAgICAgICAgIC8vIG1hcCAtIGZpbGVuYW1lIHRvIGNvbnRlbnRzIG9mIGFsbCB0aGUgZmlsZXNcbiAgICAgICAgdGhpcy5jb250ZW50c0lnbm9yZWRDaGFycyA9IHt9OyAvLyBtYXAgLSBmaWxlbmFtZSB0byBsaW5lcyBhdCB0aGUgYmVnaW5uaW5nIG9mIGVhY2ggZmlsZSB0byBpZ25vcmVcbiAgICAgICAgdGhpcy5taW1lID0gY29udGV4dC5taW1lO1xuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgLy8gRGVwcmVjYXRlZD8gVW51c2VkIG91dHNpZGUgb2YgaGVyZSwgY291bGQgYmUgdXNlZnVsLlxuICAgICAgICB0aGlzLnF1ZXVlID0gW107ICAgICAgICAvLyBGaWxlcyB3aGljaCBoYXZlbid0IGJlZW4gaW1wb3J0ZWQgeWV0XG4gICAgICAgIHRoaXMuZmlsZXMgPSB7fTsgICAgICAgIC8vIEhvbGRzIHRoZSBpbXBvcnRlZCBwYXJzZSB0cmVlcy5cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhbiBpbXBvcnQgdG8gYmUgaW1wb3J0ZWRcbiAgICAgKiBAcGFyYW0gcGF0aCAtIHRoZSByYXcgcGF0aFxuICAgICAqIEBwYXJhbSB0cnlBcHBlbmRMZXNzRXh0ZW5zaW9uIC0gd2hldGhlciB0byB0cnkgYXBwZW5kaW5nIHRoZSBsZXNzIGV4dGVuc2lvbiAoaWYgdGhlIHBhdGggaGFzIG5vIGV4dGVuc2lvbilcbiAgICAgKiBAcGFyYW0gY3VycmVudEZpbGVJbmZvIC0gdGhlIGN1cnJlbnQgZmlsZSBpbmZvICh1c2VkIGZvciBpbnN0YW5jZSB0byB3b3JrIG91dCByZWxhdGl2ZSBwYXRocylcbiAgICAgKiBAcGFyYW0gaW1wb3J0T3B0aW9ucyAtIGltcG9ydCBvcHRpb25zXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gY2FsbGJhY2sgZm9yIHdoZW4gaXQgaXMgaW1wb3J0ZWRcbiAgICAgKi9cbiAgICBJbXBvcnRNYW5hZ2VyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHBhdGgsIHRyeUFwcGVuZExlc3NFeHRlbnNpb24sIGN1cnJlbnRGaWxlSW5mbywgaW1wb3J0T3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGltcG9ydE1hbmFnZXIgPSB0aGlzO1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2gocGF0aCk7XG5cbiAgICAgICAgdmFyIGZpbGVQYXJzZWRGdW5jID0gZnVuY3Rpb24gKGUsIHJvb3QsIGZ1bGxQYXRoKSB7XG4gICAgICAgICAgICBpbXBvcnRNYW5hZ2VyLnF1ZXVlLnNwbGljZShpbXBvcnRNYW5hZ2VyLnF1ZXVlLmluZGV4T2YocGF0aCksIDEpOyAvLyBSZW1vdmUgdGhlIHBhdGggZnJvbSB0aGUgcXVldWVcblxuICAgICAgICAgICAgdmFyIGltcG9ydGVkRXF1YWxzUm9vdCA9IGZ1bGxQYXRoID09PSBpbXBvcnRNYW5hZ2VyLnJvb3RGaWxlbmFtZTtcbiAgICAgICAgICAgIGlmIChpbXBvcnRPcHRpb25zLm9wdGlvbmFsICYmIGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7cnVsZXM6W119LCBmYWxzZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbXBvcnRNYW5hZ2VyLmZpbGVzW2Z1bGxQYXRoXSA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgaWYgKGUgJiYgIWltcG9ydE1hbmFnZXIuZXJyb3IpIHsgaW1wb3J0TWFuYWdlci5lcnJvciA9IGU7IH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlLCByb290LCBpbXBvcnRlZEVxdWFsc1Jvb3QsIGZ1bGxQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbmV3RmlsZUluZm8gPSB7XG4gICAgICAgICAgICByZWxhdGl2ZVVybHM6IHRoaXMuY29udGV4dC5yZWxhdGl2ZVVybHMsXG4gICAgICAgICAgICBlbnRyeVBhdGg6IGN1cnJlbnRGaWxlSW5mby5lbnRyeVBhdGgsXG4gICAgICAgICAgICByb290cGF0aDogY3VycmVudEZpbGVJbmZvLnJvb3RwYXRoLFxuICAgICAgICAgICAgcm9vdEZpbGVuYW1lOiBjdXJyZW50RmlsZUluZm8ucm9vdEZpbGVuYW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGZpbGVNYW5hZ2VyID0gZW52aXJvbm1lbnQuZ2V0RmlsZU1hbmFnZXIocGF0aCwgY3VycmVudEZpbGVJbmZvLmN1cnJlbnREaXJlY3RvcnksIHRoaXMuY29udGV4dCwgZW52aXJvbm1lbnQpO1xuXG4gICAgICAgIGlmICghZmlsZU1hbmFnZXIpIHtcbiAgICAgICAgICAgIGZpbGVQYXJzZWRGdW5jKHsgbWVzc2FnZTogXCJDb3VsZCBub3QgZmluZCBhIGZpbGUtbWFuYWdlciBmb3IgXCIgKyBwYXRoIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyeUFwcGVuZExlc3NFeHRlbnNpb24pIHtcbiAgICAgICAgICAgIHBhdGggPSBmaWxlTWFuYWdlci50cnlBcHBlbmRFeHRlbnNpb24ocGF0aCwgaW1wb3J0T3B0aW9ucy5wbHVnaW4gPyBcIi5qc1wiIDogXCIubGVzc1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2FkRmlsZUNhbGxiYWNrID0gZnVuY3Rpb24obG9hZGVkRmlsZSkge1xuICAgICAgICAgICAgdmFyIHJlc29sdmVkRmlsZW5hbWUgPSBsb2FkZWRGaWxlLmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gbG9hZGVkRmlsZS5jb250ZW50cy5yZXBsYWNlKC9eXFx1RkVGRi8sICcnKTtcblxuICAgICAgICAgICAgLy8gUGFzcyBvbiBhbiB1cGRhdGVkIHJvb3RwYXRoIGlmIHBhdGggb2YgaW1wb3J0ZWQgZmlsZSBpcyByZWxhdGl2ZSBhbmQgZmlsZVxuICAgICAgICAgICAgLy8gaXMgaW4gYSAoc3VifHN1cCkgZGlyZWN0b3J5XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRXhhbXBsZXM6XG4gICAgICAgICAgICAvLyAtIElmIHBhdGggb2YgaW1wb3J0ZWQgZmlsZSBpcyAnbW9kdWxlL25hdi9uYXYubGVzcycgYW5kIHJvb3RwYXRoIGlzICdsZXNzLycsXG4gICAgICAgICAgICAvLyAgIHRoZW4gcm9vdHBhdGggc2hvdWxkIGJlY29tZSAnbGVzcy9tb2R1bGUvbmF2LydcbiAgICAgICAgICAgIC8vIC0gSWYgcGF0aCBvZiBpbXBvcnRlZCBmaWxlIGlzICcuLi9taXhpbnMubGVzcycgYW5kIHJvb3RwYXRoIGlzICdsZXNzLycsXG4gICAgICAgICAgICAvLyAgIHRoZW4gcm9vdHBhdGggc2hvdWxkIGJlY29tZSAnbGVzcy8uLi8nXG4gICAgICAgICAgICBuZXdGaWxlSW5mby5jdXJyZW50RGlyZWN0b3J5ID0gZmlsZU1hbmFnZXIuZ2V0UGF0aChyZXNvbHZlZEZpbGVuYW1lKTtcbiAgICAgICAgICAgIGlmIChuZXdGaWxlSW5mby5yZWxhdGl2ZVVybHMpIHtcbiAgICAgICAgICAgICAgICBuZXdGaWxlSW5mby5yb290cGF0aCA9IGZpbGVNYW5hZ2VyLmpvaW4oXG4gICAgICAgICAgICAgICAgICAgIChpbXBvcnRNYW5hZ2VyLmNvbnRleHQucm9vdHBhdGggfHwgXCJcIiksXG4gICAgICAgICAgICAgICAgICAgIGZpbGVNYW5hZ2VyLnBhdGhEaWZmKG5ld0ZpbGVJbmZvLmN1cnJlbnREaXJlY3RvcnksIG5ld0ZpbGVJbmZvLmVudHJ5UGF0aCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlTWFuYWdlci5pc1BhdGhBYnNvbHV0ZShuZXdGaWxlSW5mby5yb290cGF0aCkgJiYgZmlsZU1hbmFnZXIuYWx3YXlzTWFrZVBhdGhzQWJzb2x1dGUoKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdGaWxlSW5mby5yb290cGF0aCA9IGZpbGVNYW5hZ2VyLmpvaW4obmV3RmlsZUluZm8uZW50cnlQYXRoLCBuZXdGaWxlSW5mby5yb290cGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3RmlsZUluZm8uZmlsZW5hbWUgPSByZXNvbHZlZEZpbGVuYW1lO1xuXG4gICAgICAgICAgICB2YXIgbmV3RW52ID0gbmV3IGNvbnRleHRzLlBhcnNlKGltcG9ydE1hbmFnZXIuY29udGV4dCk7XG5cbiAgICAgICAgICAgIG5ld0Vudi5wcm9jZXNzSW1wb3J0cyA9IGZhbHNlO1xuICAgICAgICAgICAgaW1wb3J0TWFuYWdlci5jb250ZW50c1tyZXNvbHZlZEZpbGVuYW1lXSA9IGNvbnRlbnRzO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudEZpbGVJbmZvLnJlZmVyZW5jZSB8fCBpbXBvcnRPcHRpb25zLnJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgIG5ld0ZpbGVJbmZvLnJlZmVyZW5jZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbXBvcnRPcHRpb25zLnBsdWdpbikge1xuICAgICAgICAgICAgICAgIG5ldyBGdW5jdGlvbkltcG9ydGVyKG5ld0VudiwgbmV3RmlsZUluZm8pLmV2YWwoY29udGVudHMsIGZ1bmN0aW9uIChlLCByb290KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYXJzZWRGdW5jKGUsIHJvb3QsIHJlc29sdmVkRmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbXBvcnRPcHRpb25zLmlubGluZSkge1xuICAgICAgICAgICAgICAgIGZpbGVQYXJzZWRGdW5jKG51bGwsIGNvbnRlbnRzLCByZXNvbHZlZEZpbGVuYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3IFBhcnNlcihuZXdFbnYsIGltcG9ydE1hbmFnZXIsIG5ld0ZpbGVJbmZvKS5wYXJzZShjb250ZW50cywgZnVuY3Rpb24gKGUsIHJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhcnNlZEZ1bmMoZSwgcm9vdCwgcmVzb2x2ZWRGaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHByb21pc2UgPSBmaWxlTWFuYWdlci5sb2FkRmlsZShwYXRoLCBjdXJyZW50RmlsZUluZm8uY3VycmVudERpcmVjdG9yeSwgdGhpcy5jb250ZXh0LCBlbnZpcm9ubWVudCxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGVyciwgbG9hZGVkRmlsZSkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGZpbGVQYXJzZWRGdW5jKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvYWRGaWxlQ2FsbGJhY2sobG9hZGVkRmlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKGxvYWRGaWxlQ2FsbGJhY2ssIGZpbGVQYXJzZWRGdW5jKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEltcG9ydE1hbmFnZXI7XG59O1xuXG59LHtcIi4vY29udGV4dHNcIjoxMSxcIi4vcGFyc2VyL3BhcnNlclwiOjM4LFwiLi9wbHVnaW5zL2Z1bmN0aW9uLWltcG9ydGVyXCI6NDB9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVudmlyb25tZW50LCBmaWxlTWFuYWdlcnMpIHtcbiAgICB2YXIgU291cmNlTWFwT3V0cHV0LCBTb3VyY2VNYXBCdWlsZGVyLCBQYXJzZVRyZWUsIEltcG9ydE1hbmFnZXIsIEVudmlyb25tZW50O1xuXG4gICAgdmFyIGxlc3MgPSB7XG4gICAgICAgIHZlcnNpb246IFsyLCA3LCAyXSxcbiAgICAgICAgZGF0YTogcmVxdWlyZSgnLi9kYXRhJyksXG4gICAgICAgIHRyZWU6IHJlcXVpcmUoJy4vdHJlZScpLFxuICAgICAgICBFbnZpcm9ubWVudDogKEVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vZW52aXJvbm1lbnQvZW52aXJvbm1lbnRcIikpLFxuICAgICAgICBBYnN0cmFjdEZpbGVNYW5hZ2VyOiByZXF1aXJlKFwiLi9lbnZpcm9ubWVudC9hYnN0cmFjdC1maWxlLW1hbmFnZXJcIiksXG4gICAgICAgIGVudmlyb25tZW50OiAoZW52aXJvbm1lbnQgPSBuZXcgRW52aXJvbm1lbnQoZW52aXJvbm1lbnQsIGZpbGVNYW5hZ2VycykpLFxuICAgICAgICB2aXNpdG9yczogcmVxdWlyZSgnLi92aXNpdG9ycycpLFxuICAgICAgICBQYXJzZXI6IHJlcXVpcmUoJy4vcGFyc2VyL3BhcnNlcicpLFxuICAgICAgICBmdW5jdGlvbnM6IHJlcXVpcmUoJy4vZnVuY3Rpb25zJykoZW52aXJvbm1lbnQpLFxuICAgICAgICBjb250ZXh0czogcmVxdWlyZShcIi4vY29udGV4dHNcIiksXG4gICAgICAgIFNvdXJjZU1hcE91dHB1dDogKFNvdXJjZU1hcE91dHB1dCA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1vdXRwdXQnKShlbnZpcm9ubWVudCkpLFxuICAgICAgICBTb3VyY2VNYXBCdWlsZGVyOiAoU291cmNlTWFwQnVpbGRlciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1idWlsZGVyJykoU291cmNlTWFwT3V0cHV0LCBlbnZpcm9ubWVudCkpLFxuICAgICAgICBQYXJzZVRyZWU6IChQYXJzZVRyZWUgPSByZXF1aXJlKCcuL3BhcnNlLXRyZWUnKShTb3VyY2VNYXBCdWlsZGVyKSksXG4gICAgICAgIEltcG9ydE1hbmFnZXI6IChJbXBvcnRNYW5hZ2VyID0gcmVxdWlyZSgnLi9pbXBvcnQtbWFuYWdlcicpKGVudmlyb25tZW50KSksXG4gICAgICAgIHJlbmRlcjogcmVxdWlyZShcIi4vcmVuZGVyXCIpKGVudmlyb25tZW50LCBQYXJzZVRyZWUsIEltcG9ydE1hbmFnZXIpLFxuICAgICAgICBwYXJzZTogcmVxdWlyZShcIi4vcGFyc2VcIikoZW52aXJvbm1lbnQsIFBhcnNlVHJlZSwgSW1wb3J0TWFuYWdlciksXG4gICAgICAgIExlc3NFcnJvcjogcmVxdWlyZSgnLi9sZXNzLWVycm9yJyksXG4gICAgICAgIHRyYW5zZm9ybVRyZWU6IHJlcXVpcmUoJy4vdHJhbnNmb3JtLXRyZWUnKSxcbiAgICAgICAgdXRpbHM6IHJlcXVpcmUoJy4vdXRpbHMnKSxcbiAgICAgICAgUGx1Z2luTWFuYWdlcjogcmVxdWlyZSgnLi9wbHVnaW4tbWFuYWdlcicpLFxuICAgICAgICBsb2dnZXI6IHJlcXVpcmUoJy4vbG9nZ2VyJylcbiAgICB9O1xuXG4gICAgcmV0dXJuIGxlc3M7XG59O1xuXG59LHtcIi4vY29udGV4dHNcIjoxMSxcIi4vZGF0YVwiOjEzLFwiLi9lbnZpcm9ubWVudC9hYnN0cmFjdC1maWxlLW1hbmFnZXJcIjoxNSxcIi4vZW52aXJvbm1lbnQvZW52aXJvbm1lbnRcIjoxNixcIi4vZnVuY3Rpb25zXCI6MjMsXCIuL2ltcG9ydC1tYW5hZ2VyXCI6MzAsXCIuL2xlc3MtZXJyb3JcIjozMixcIi4vbG9nZ2VyXCI6MzMsXCIuL3BhcnNlXCI6MzUsXCIuL3BhcnNlLXRyZWVcIjozNCxcIi4vcGFyc2VyL3BhcnNlclwiOjM4LFwiLi9wbHVnaW4tbWFuYWdlclwiOjM5LFwiLi9yZW5kZXJcIjo0MSxcIi4vc291cmNlLW1hcC1idWlsZGVyXCI6NDIsXCIuL3NvdXJjZS1tYXAtb3V0cHV0XCI6NDMsXCIuL3RyYW5zZm9ybS10cmVlXCI6NDQsXCIuL3RyZWVcIjo2MixcIi4vdXRpbHNcIjo4MyxcIi4vdmlzaXRvcnNcIjo4N31dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG52YXIgTGVzc0Vycm9yID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBMZXNzRXJyb3IoZSwgaW1wb3J0TWFuYWdlciwgY3VycmVudEZpbGVuYW1lKSB7XG5cbiAgICBFcnJvci5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIGZpbGVuYW1lID0gZS5maWxlbmFtZSB8fCBjdXJyZW50RmlsZW5hbWU7XG5cbiAgICBpZiAoaW1wb3J0TWFuYWdlciAmJiBmaWxlbmFtZSkge1xuICAgICAgICB2YXIgaW5wdXQgPSBpbXBvcnRNYW5hZ2VyLmNvbnRlbnRzW2ZpbGVuYW1lXSxcbiAgICAgICAgICAgIGxvYyA9IHV0aWxzLmdldExvY2F0aW9uKGUuaW5kZXgsIGlucHV0KSxcbiAgICAgICAgICAgIGxpbmUgPSBsb2MubGluZSxcbiAgICAgICAgICAgIGNvbCAgPSBsb2MuY29sdW1uLFxuICAgICAgICAgICAgY2FsbExpbmUgPSBlLmNhbGwgJiYgdXRpbHMuZ2V0TG9jYXRpb24oZS5jYWxsLCBpbnB1dCkubGluZSxcbiAgICAgICAgICAgIGxpbmVzID0gaW5wdXQuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgIHRoaXMudHlwZSA9IGUudHlwZSB8fCAnU3ludGF4JztcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICB0aGlzLmluZGV4ID0gZS5pbmRleDtcbiAgICAgICAgdGhpcy5saW5lID0gdHlwZW9mIGxpbmUgPT09ICdudW1iZXInID8gbGluZSArIDEgOiBudWxsO1xuICAgICAgICB0aGlzLmNhbGxMaW5lID0gY2FsbExpbmUgKyAxO1xuICAgICAgICB0aGlzLmNhbGxFeHRyYWN0ID0gbGluZXNbY2FsbExpbmVdO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbDtcbiAgICAgICAgdGhpcy5leHRyYWN0ID0gW1xuICAgICAgICAgICAgbGluZXNbbGluZSAtIDFdLFxuICAgICAgICAgICAgbGluZXNbbGluZV0sXG4gICAgICAgICAgICBsaW5lc1tsaW5lICsgMV1cbiAgICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlID0gZS5tZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSBlLnN0YWNrO1xufTtcblxuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBGID0gZnVuY3Rpb24gKCkge307XG4gICAgRi5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG4gICAgTGVzc0Vycm9yLnByb3RvdHlwZSA9IG5ldyBGKCk7XG59IGVsc2Uge1xuICAgIExlc3NFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG59XG5cbkxlc3NFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZXNzRXJyb3I7XG5cbn0se1wiLi91dGlsc1wiOjgzfV0sMzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZXJyb3I6IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICB0aGlzLl9maXJlRXZlbnQoXCJlcnJvclwiLCBtc2cpO1xuICAgIH0sXG4gICAgd2FybjogZnVuY3Rpb24obXNnKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudChcIndhcm5cIiwgbXNnKTtcbiAgICB9LFxuICAgIGluZm86IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICB0aGlzLl9maXJlRXZlbnQoXCJpbmZvXCIsIG1zZyk7XG4gICAgfSxcbiAgICBkZWJ1ZzogZnVuY3Rpb24obXNnKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudChcImRlYnVnXCIsIG1zZyk7XG4gICAgfSxcbiAgICBhZGRMaXN0ZW5lcjogZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH0sXG4gICAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBfZmlyZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBtc2cpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsb2dGdW5jdGlvbiA9IHRoaXMuX2xpc3RlbmVyc1tpXVt0eXBlXTtcbiAgICAgICAgICAgIGlmIChsb2dGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9saXN0ZW5lcnM6IFtdXG59O1xuXG59LHt9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTGVzc0Vycm9yID0gcmVxdWlyZSgnLi9sZXNzLWVycm9yJyksXG4gICAgdHJhbnNmb3JtVHJlZSA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybS10cmVlXCIpLFxuICAgIGxvZ2dlciA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihTb3VyY2VNYXBCdWlsZGVyKSB7XG4gICAgdmFyIFBhcnNlVHJlZSA9IGZ1bmN0aW9uKHJvb3QsIGltcG9ydHMpIHtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5pbXBvcnRzID0gaW1wb3J0cztcbiAgICB9O1xuXG4gICAgUGFyc2VUcmVlLnByb3RvdHlwZS50b0NTUyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGV2YWxkUm9vdCwgcmVzdWx0ID0ge30sIHNvdXJjZU1hcEJ1aWxkZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBldmFsZFJvb3QgPSB0cmFuc2Zvcm1UcmVlKHRoaXMucm9vdCwgb3B0aW9ucyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBMZXNzRXJyb3IoZSwgdGhpcy5pbXBvcnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3MgPSBCb29sZWFuKG9wdGlvbnMuY29tcHJlc3MpO1xuICAgICAgICAgICAgaWYgKGNvbXByZXNzKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJUaGUgY29tcHJlc3Mgb3B0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFdlIHJlY29tbWVuZCB5b3UgdXNlIGEgZGVkaWNhdGVkIGNzcyBtaW5pZmllciwgZm9yIGluc3RhbmNlIHNlZSBsZXNzLXBsdWdpbi1jbGVhbi1jc3MuXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG9DU1NPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzOiBjb21wcmVzcyxcbiAgICAgICAgICAgICAgICBkdW1wTGluZU51bWJlcnM6IG9wdGlvbnMuZHVtcExpbmVOdW1iZXJzLFxuICAgICAgICAgICAgICAgIHN0cmljdFVuaXRzOiBCb29sZWFuKG9wdGlvbnMuc3RyaWN0VW5pdHMpLFxuICAgICAgICAgICAgICAgIG51bVByZWNpc2lvbjogOH07XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZU1hcEJ1aWxkZXIgPSBuZXcgU291cmNlTWFwQnVpbGRlcihvcHRpb25zLnNvdXJjZU1hcCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNzcyA9IHNvdXJjZU1hcEJ1aWxkZXIudG9DU1MoZXZhbGRSb290LCB0b0NTU09wdGlvbnMsIHRoaXMuaW1wb3J0cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jc3MgPSBldmFsZFJvb3QudG9DU1ModG9DU1NPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IExlc3NFcnJvcihlLCB0aGlzLmltcG9ydHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucGx1Z2luTWFuYWdlcikge1xuICAgICAgICAgICAgdmFyIHBvc3RQcm9jZXNzb3JzID0gb3B0aW9ucy5wbHVnaW5NYW5hZ2VyLmdldFBvc3RQcm9jZXNzb3JzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3RQcm9jZXNzb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNzcyA9IHBvc3RQcm9jZXNzb3JzW2ldLnByb2Nlc3MocmVzdWx0LmNzcywgeyBzb3VyY2VNYXA6IHNvdXJjZU1hcEJ1aWxkZXIsIG9wdGlvbnM6IG9wdGlvbnMsIGltcG9ydHM6IHRoaXMuaW1wb3J0cyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zb3VyY2VNYXApIHtcbiAgICAgICAgICAgIHJlc3VsdC5tYXAgPSBzb3VyY2VNYXBCdWlsZGVyLmdldEV4dGVybmFsU291cmNlTWFwKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuaW1wb3J0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBmaWxlIGluIHRoaXMuaW1wb3J0cy5maWxlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW1wb3J0cy5maWxlcy5oYXNPd25Qcm9wZXJ0eShmaWxlKSAmJiBmaWxlICE9PSB0aGlzLmltcG9ydHMucm9vdEZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmltcG9ydHMucHVzaChmaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlVHJlZTtcbn07XG5cbn0se1wiLi9sZXNzLWVycm9yXCI6MzIsXCIuL2xvZ2dlclwiOjMzLFwiLi90cmFuc2Zvcm0tdHJlZVwiOjQ0fV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIFByb21pc2VDb25zdHJ1Y3RvcixcbiAgICBjb250ZXh0cyA9IHJlcXVpcmUoXCIuL2NvbnRleHRzXCIpLFxuICAgIFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyL3BhcnNlcicpLFxuICAgIFBsdWdpbk1hbmFnZXIgPSByZXF1aXJlKCcuL3BsdWdpbi1tYW5hZ2VyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZW52aXJvbm1lbnQsIFBhcnNlVHJlZSwgSW1wb3J0TWFuYWdlcikge1xuICAgIHZhciBwYXJzZSA9IGZ1bmN0aW9uIChpbnB1dCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoIVByb21pc2VDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgIFByb21pc2VDb25zdHJ1Y3RvciA9IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHJlcXVpcmUoJ3Byb21pc2UnKSA6IFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2VDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcGFyc2UuY2FsbChzZWxmLCBpbnB1dCwgb3B0aW9ucywgZnVuY3Rpb24oZXJyLCBvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgcm9vdEZpbGVJbmZvLFxuICAgICAgICAgICAgICAgIHBsdWdpbk1hbmFnZXIgPSBuZXcgUGx1Z2luTWFuYWdlcih0aGlzKTtcblxuICAgICAgICAgICAgcGx1Z2luTWFuYWdlci5hZGRQbHVnaW5zKG9wdGlvbnMucGx1Z2lucyk7XG4gICAgICAgICAgICBvcHRpb25zLnBsdWdpbk1hbmFnZXIgPSBwbHVnaW5NYW5hZ2VyO1xuXG4gICAgICAgICAgICBjb250ZXh0ID0gbmV3IGNvbnRleHRzLlBhcnNlKG9wdGlvbnMpO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yb290RmlsZUluZm8pIHtcbiAgICAgICAgICAgICAgICByb290RmlsZUluZm8gPSBvcHRpb25zLnJvb3RGaWxlSW5mbztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZSB8fCBcImlucHV0XCI7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5UGF0aCA9IGZpbGVuYW1lLnJlcGxhY2UoL1teXFwvXFxcXF0qJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgIHJvb3RGaWxlSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVVybHM6IGNvbnRleHQucmVsYXRpdmVVcmxzLFxuICAgICAgICAgICAgICAgICAgICByb290cGF0aDogY29udGV4dC5yb290cGF0aCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGlyZWN0b3J5OiBlbnRyeVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5UGF0aDogZW50cnlQYXRoLFxuICAgICAgICAgICAgICAgICAgICByb290RmlsZW5hbWU6IGZpbGVuYW1lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBhZGQgaW4gYSBtaXNzaW5nIHRyYWlsaW5nIHNsYXNoXG4gICAgICAgICAgICAgICAgaWYgKHJvb3RGaWxlSW5mby5yb290cGF0aCAmJiByb290RmlsZUluZm8ucm9vdHBhdGguc2xpY2UoLTEpICE9PSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICByb290RmlsZUluZm8ucm9vdHBhdGggKz0gXCIvXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW1wb3J0cyA9IG5ldyBJbXBvcnRNYW5hZ2VyKGNvbnRleHQsIHJvb3RGaWxlSW5mbyk7XG5cbiAgICAgICAgICAgIG5ldyBQYXJzZXIoY29udGV4dCwgaW1wb3J0cywgcm9vdEZpbGVJbmZvKVxuICAgICAgICAgICAgICAgIC5wYXJzZShpbnB1dCwgZnVuY3Rpb24gKGUsIHJvb3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSkgeyByZXR1cm4gY2FsbGJhY2soZSk7IH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByb290LCBpbXBvcnRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcGFyc2U7XG59O1xuXG59LHtcIi4vY29udGV4dHNcIjoxMSxcIi4vcGFyc2VyL3BhcnNlclwiOjM4LFwiLi9wbHVnaW4tbWFuYWdlclwiOjM5LFwicHJvbWlzZVwiOnVuZGVmaW5lZH1dLDM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIFNwbGl0IHRoZSBpbnB1dCBpbnRvIGNodW5rcy5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBmYWlsKSB7XG4gICAgdmFyIGxlbiA9IGlucHV0Lmxlbmd0aCwgbGV2ZWwgPSAwLCBwYXJlbkxldmVsID0gMCxcbiAgICAgICAgbGFzdE9wZW5pbmcsIGxhc3RPcGVuaW5nUGFyZW4sIGxhc3RNdWx0aUNvbW1lbnQsIGxhc3RNdWx0aUNvbW1lbnRFbmRCcmFjZSxcbiAgICAgICAgY2h1bmtzID0gW10sIGVtaXRGcm9tID0gMCxcbiAgICAgICAgY2h1bmtlckN1cnJlbnRJbmRleCwgY3VycmVudENodW5rU3RhcnRJbmRleCwgY2MsIGNjMiwgbWF0Y2hlZDtcblxuICAgIGZ1bmN0aW9uIGVtaXRDaHVuayhmb3JjZSkge1xuICAgICAgICB2YXIgbGVuID0gY2h1bmtlckN1cnJlbnRJbmRleCAtIGVtaXRGcm9tO1xuICAgICAgICBpZiAoKChsZW4gPCA1MTIpICYmICFmb3JjZSkgfHwgIWxlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNodW5rcy5wdXNoKGlucHV0LnNsaWNlKGVtaXRGcm9tLCBjaHVua2VyQ3VycmVudEluZGV4ICsgMSkpO1xuICAgICAgICBlbWl0RnJvbSA9IGNodW5rZXJDdXJyZW50SW5kZXggKyAxO1xuICAgIH1cblxuICAgIGZvciAoY2h1bmtlckN1cnJlbnRJbmRleCA9IDA7IGNodW5rZXJDdXJyZW50SW5kZXggPCBsZW47IGNodW5rZXJDdXJyZW50SW5kZXgrKykge1xuICAgICAgICBjYyA9IGlucHV0LmNoYXJDb2RlQXQoY2h1bmtlckN1cnJlbnRJbmRleCk7XG4gICAgICAgIGlmICgoKGNjID49IDk3KSAmJiAoY2MgPD0gMTIyKSkgfHwgKGNjIDwgMzQpKSB7XG4gICAgICAgICAgICAvLyBhLXogb3Igd2hpdGVzcGFjZVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGNjKSB7XG4gICAgICAgICAgICBjYXNlIDQwOiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgICAgICAgICBwYXJlbkxldmVsKys7XG4gICAgICAgICAgICAgICAgbGFzdE9wZW5pbmdQYXJlbiA9IGNodW5rZXJDdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIDQxOiAgICAgICAgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgICAgICAgICBpZiAoLS1wYXJlbkxldmVsIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbChcIm1pc3Npbmcgb3BlbmluZyBgKGBcIiwgY2h1bmtlckN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSA1OTogICAgICAgICAgICAgICAgICAgICAgICAvLyA7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbkxldmVsKSB7IGVtaXRDaHVuaygpOyB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIDEyMzogICAgICAgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICBsZXZlbCsrO1xuICAgICAgICAgICAgICAgIGxhc3RPcGVuaW5nID0gY2h1bmtlckN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgMTI1OiAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICgtLWxldmVsIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbChcIm1pc3Npbmcgb3BlbmluZyBge2BcIiwgY2h1bmtlckN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbGV2ZWwgJiYgIXBhcmVuTGV2ZWwpIHsgZW1pdENodW5rKCk7IH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgOTI6ICAgICAgICAgICAgICAgICAgICAgICAgLy8gXFxcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmtlckN1cnJlbnRJbmRleCA8IGxlbiAtIDEpIHsgY2h1bmtlckN1cnJlbnRJbmRleCsrOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKFwidW5lc2NhcGVkIGBcXFxcYFwiLCBjaHVua2VyQ3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgY2FzZSA5NjogICAgICAgICAgICAgICAgICAgICAgICAvLyBcIiwgJyBhbmQgYFxuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSAwO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVua1N0YXJ0SW5kZXggPSBjaHVua2VyQ3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgIGZvciAoY2h1bmtlckN1cnJlbnRJbmRleCA9IGNodW5rZXJDdXJyZW50SW5kZXggKyAxOyBjaHVua2VyQ3VycmVudEluZGV4IDwgbGVuOyBjaHVua2VyQ3VycmVudEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2MyID0gaW5wdXQuY2hhckNvZGVBdChjaHVua2VyQ3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNjMiA+IDk2KSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYzIgPT0gY2MpIHsgbWF0Y2hlZCA9IDE7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYzIgPT0gOTIpIHsgICAgICAgIC8vIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmtlckN1cnJlbnRJbmRleCA9PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoXCJ1bmVzY2FwZWQgYFxcXFxgXCIsIGNodW5rZXJDdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtlckN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoXCJ1bm1hdGNoZWQgYFwiICsgU3RyaW5nLmZyb21DaGFyQ29kZShjYykgKyBcImBcIiwgY3VycmVudENodW5rU3RhcnRJbmRleCk7XG4gICAgICAgICAgICBjYXNlIDQ3OiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC8sIGNoZWNrIGZvciBjb21tZW50XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVuTGV2ZWwgfHwgKGNodW5rZXJDdXJyZW50SW5kZXggPT0gbGVuIC0gMSkpIHsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICBjYzIgPSBpbnB1dC5jaGFyQ29kZUF0KGNodW5rZXJDdXJyZW50SW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoY2MyID09IDQ3KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC8vLCBmaW5kIGxuZmVlZFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNodW5rZXJDdXJyZW50SW5kZXggPSBjaHVua2VyQ3VycmVudEluZGV4ICsgMjsgY2h1bmtlckN1cnJlbnRJbmRleCA8IGxlbjsgY2h1bmtlckN1cnJlbnRJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYzIgPSBpbnB1dC5jaGFyQ29kZUF0KGNodW5rZXJDdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjYzIgPD0gMTMpICYmICgoY2MyID09IDEwKSB8fCAoY2MyID09IDEzKSkpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2MyID09IDQyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC8qLCBmaW5kICovXG4gICAgICAgICAgICAgICAgICAgIGxhc3RNdWx0aUNvbW1lbnQgPSBjdXJyZW50Q2h1bmtTdGFydEluZGV4ID0gY2h1bmtlckN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjaHVua2VyQ3VycmVudEluZGV4ID0gY2h1bmtlckN1cnJlbnRJbmRleCArIDI7IGNodW5rZXJDdXJyZW50SW5kZXggPCBsZW4gLSAxOyBjaHVua2VyQ3VycmVudEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjMiA9IGlucHV0LmNoYXJDb2RlQXQoY2h1bmtlckN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2MyID09IDEyNSkgeyBsYXN0TXVsdGlDb21tZW50RW5kQnJhY2UgPSBjaHVua2VyQ3VycmVudEluZGV4OyB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2MyICE9IDQyKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChjaHVua2VyQ3VycmVudEluZGV4ICsgMSkgPT0gNDcpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmtlckN1cnJlbnRJbmRleCA9PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbChcIm1pc3NpbmcgY2xvc2luZyBgKi9gXCIsIGN1cnJlbnRDaHVua1N0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNodW5rZXJDdXJyZW50SW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIDQyOiAgICAgICAgICAgICAgICAgICAgICAgLy8gKiwgY2hlY2sgZm9yIHVubWF0Y2hlZCAqL1xuICAgICAgICAgICAgICAgIGlmICgoY2h1bmtlckN1cnJlbnRJbmRleCA8IGxlbiAtIDEpICYmIChpbnB1dC5jaGFyQ29kZUF0KGNodW5rZXJDdXJyZW50SW5kZXggKyAxKSA9PSA0NykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoXCJ1bm1hdGNoZWQgYC8qYFwiLCBjaHVua2VyQ3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGV2ZWwgIT09IDApIHtcbiAgICAgICAgaWYgKChsYXN0TXVsdGlDb21tZW50ID4gbGFzdE9wZW5pbmcpICYmIChsYXN0TXVsdGlDb21tZW50RW5kQnJhY2UgPiBsYXN0TXVsdGlDb21tZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwoXCJtaXNzaW5nIGNsb3NpbmcgYH1gIG9yIGAqL2BcIiwgbGFzdE9wZW5pbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwoXCJtaXNzaW5nIGNsb3NpbmcgYH1gXCIsIGxhc3RPcGVuaW5nKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyZW5MZXZlbCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFpbChcIm1pc3NpbmcgY2xvc2luZyBgKWBcIiwgbGFzdE9wZW5pbmdQYXJlbik7XG4gICAgfVxuXG4gICAgZW1pdENodW5rKHRydWUpO1xuICAgIHJldHVybiBjaHVua3M7XG59O1xuXG59LHt9XSwzNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgY2h1bmtlciA9IHJlcXVpcmUoJy4vY2h1bmtlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbnB1dCwgICAgICAgLy8gTGVTUyBpbnB1dCBzdHJpbmdcbiAgICAgICAgaiwgICAgICAgICAgIC8vIGN1cnJlbnQgY2h1bmtcbiAgICAgICAgc2F2ZVN0YWNrID0gW10sICAgLy8gaG9sZHMgc3RhdGUgZm9yIGJhY2t0cmFja2luZ1xuICAgICAgICBmdXJ0aGVzdCwgICAgLy8gZnVydGhlc3QgaW5kZXggdGhlIHBhcnNlciBoYXMgZ29uZSB0b1xuICAgICAgICBmdXJ0aGVzdFBvc3NpYmxlRXJyb3JNZXNzYWdlLC8vIGlmIHRoaXMgaXMgZnVydGhlc3Qgd2UgZ290IHRvLCB0aGlzIGlzIHRoZSBwcm9iYWJseSBjYXVzZVxuICAgICAgICBjaHVua3MsICAgICAgLy8gY2h1bmtpZmllZCBpbnB1dFxuICAgICAgICBjdXJyZW50LCAgICAgLy8gY3VycmVudCBjaHVua1xuICAgICAgICBjdXJyZW50UG9zLCAgLy8gaW5kZXggb2YgY3VycmVudCBjaHVuaywgaW4gYGlucHV0YFxuICAgICAgICBwYXJzZXJJbnB1dCA9IHt9O1xuXG4gICAgdmFyIENIQVJDT0RFX1NQQUNFID0gMzIsXG4gICAgICAgIENIQVJDT0RFX1RBQiA9IDksXG4gICAgICAgIENIQVJDT0RFX0xGID0gMTAsXG4gICAgICAgIENIQVJDT0RFX0NSID0gMTMsXG4gICAgICAgIENIQVJDT0RFX1BMVVMgPSA0MyxcbiAgICAgICAgQ0hBUkNPREVfQ09NTUEgPSA0NCxcbiAgICAgICAgQ0hBUkNPREVfRk9SV0FSRF9TTEFTSCA9IDQ3LFxuICAgICAgICBDSEFSQ09ERV85ID0gNTc7XG5cbiAgICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZShsZW5ndGgpIHtcbiAgICAgICAgdmFyIG9sZGkgPSBwYXJzZXJJbnB1dC5pLCBvbGRqID0gaixcbiAgICAgICAgICAgIGN1cnIgPSBwYXJzZXJJbnB1dC5pIC0gY3VycmVudFBvcyxcbiAgICAgICAgICAgIGVuZEluZGV4ID0gcGFyc2VySW5wdXQuaSArIGN1cnJlbnQubGVuZ3RoIC0gY3VycixcbiAgICAgICAgICAgIG1lbSA9IChwYXJzZXJJbnB1dC5pICs9IGxlbmd0aCksXG4gICAgICAgICAgICBpbnAgPSBpbnB1dCxcbiAgICAgICAgICAgIGMsIG5leHRDaGFyLCBjb21tZW50O1xuXG4gICAgICAgIGZvciAoOyBwYXJzZXJJbnB1dC5pIDwgZW5kSW5kZXg7IHBhcnNlcklucHV0LmkrKykge1xuICAgICAgICAgICAgYyA9IGlucC5jaGFyQ29kZUF0KHBhcnNlcklucHV0LmkpO1xuXG4gICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuYXV0b0NvbW1lbnRBYnNvcmIgJiYgYyA9PT0gQ0hBUkNPREVfRk9SV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgICAgIG5leHRDaGFyID0gaW5wLmNoYXJBdChwYXJzZXJJbnB1dC5pICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IHtpbmRleDogcGFyc2VySW5wdXQuaSwgaXNMaW5lQ29tbWVudDogdHJ1ZX07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0TmV3TGluZSA9IGlucC5pbmRleE9mKFwiXFxuXCIsIHBhcnNlcklucHV0LmkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHROZXdMaW5lIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5ld0xpbmUgPSBlbmRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5pID0gbmV4dE5ld0xpbmU7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQudGV4dCA9IGlucC5zdWJzdHIoY29tbWVudC5pbmRleCwgcGFyc2VySW5wdXQuaSAtIGNvbW1lbnQuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0U3RhclNsYXNoID0gaW5wLmluZGV4T2YoXCIqL1wiLCBwYXJzZXJJbnB1dC5pICsgMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U3RhclNsYXNoID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHBhcnNlcklucHV0LmksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogaW5wLnN1YnN0cihwYXJzZXJJbnB1dC5pLCBuZXh0U3RhclNsYXNoICsgMiAtIHBhcnNlcklucHV0LmkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTGluZUNvbW1lbnQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuaSArPSBjb21tZW50LnRleHQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmNvbW1lbnRTdG9yZS5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgoYyAhPT0gQ0hBUkNPREVfU1BBQ0UpICYmIChjICE9PSBDSEFSQ09ERV9MRikgJiYgKGMgIT09IENIQVJDT0RFX1RBQikgJiYgKGMgIT09IENIQVJDT0RFX0NSKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc2xpY2UobGVuZ3RoICsgcGFyc2VySW5wdXQuaSAtIG1lbSArIGN1cnIpO1xuICAgICAgICBjdXJyZW50UG9zID0gcGFyc2VySW5wdXQuaTtcblxuICAgICAgICBpZiAoIWN1cnJlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaiA8IGNodW5rcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNodW5rc1srK2pdO1xuICAgICAgICAgICAgICAgIHNraXBXaGl0ZXNwYWNlKDApOyAvLyBza2lwIHNwYWNlIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBjaHVua1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyB0aGluZ3MgY2hhbmdlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VySW5wdXQuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9sZGkgIT09IHBhcnNlcklucHV0LmkgfHwgb2xkaiAhPT0gajtcbiAgICB9XG5cbiAgICBwYXJzZXJJbnB1dC5zYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGN1cnJlbnRQb3MgPSBwYXJzZXJJbnB1dC5pO1xuICAgICAgICBzYXZlU3RhY2sucHVzaCggeyBjdXJyZW50OiBjdXJyZW50LCBpOiBwYXJzZXJJbnB1dC5pLCBqOiBqIH0pO1xuICAgIH07XG4gICAgcGFyc2VySW5wdXQucmVzdG9yZSA9IGZ1bmN0aW9uKHBvc3NpYmxlRXJyb3JNZXNzYWdlKSB7XG5cbiAgICAgICAgaWYgKHBhcnNlcklucHV0LmkgPiBmdXJ0aGVzdCB8fCAocGFyc2VySW5wdXQuaSA9PT0gZnVydGhlc3QgJiYgcG9zc2libGVFcnJvck1lc3NhZ2UgJiYgIWZ1cnRoZXN0UG9zc2libGVFcnJvck1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBmdXJ0aGVzdCA9IHBhcnNlcklucHV0Lmk7XG4gICAgICAgICAgICBmdXJ0aGVzdFBvc3NpYmxlRXJyb3JNZXNzYWdlID0gcG9zc2libGVFcnJvck1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXRlID0gc2F2ZVN0YWNrLnBvcCgpO1xuICAgICAgICBjdXJyZW50ID0gc3RhdGUuY3VycmVudDtcbiAgICAgICAgY3VycmVudFBvcyA9IHBhcnNlcklucHV0LmkgPSBzdGF0ZS5pO1xuICAgICAgICBqID0gc3RhdGUuajtcbiAgICB9O1xuICAgIHBhcnNlcklucHV0LmZvcmdldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzYXZlU3RhY2sucG9wKCk7XG4gICAgfTtcbiAgICBwYXJzZXJJbnB1dC5pc1doaXRlc3BhY2UgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIHZhciBwb3MgPSBwYXJzZXJJbnB1dC5pICsgKG9mZnNldCB8fCAwKSxcbiAgICAgICAgICAgIGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIHJldHVybiAoY29kZSA9PT0gQ0hBUkNPREVfU1BBQ0UgfHwgY29kZSA9PT0gQ0hBUkNPREVfQ1IgfHwgY29kZSA9PT0gQ0hBUkNPREVfVEFCIHx8IGNvZGUgPT09IENIQVJDT0RFX0xGKTtcbiAgICB9O1xuXG4gICAgLy8gU3BlY2lhbGl6YXRpb24gb2YgJCh0b2spXG4gICAgcGFyc2VySW5wdXQuJHJlID0gZnVuY3Rpb24odG9rKSB7XG4gICAgICAgIGlmIChwYXJzZXJJbnB1dC5pID4gY3VycmVudFBvcykge1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc2xpY2UocGFyc2VySW5wdXQuaSAtIGN1cnJlbnRQb3MpO1xuICAgICAgICAgICAgY3VycmVudFBvcyA9IHBhcnNlcklucHV0Lmk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbSA9IHRvay5leGVjKGN1cnJlbnQpO1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgc2tpcFdoaXRlc3BhY2UobVswXS5sZW5ndGgpO1xuICAgICAgICBpZiAodHlwZW9mIG0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG0ubGVuZ3RoID09PSAxID8gbVswXSA6IG07XG4gICAgfTtcblxuICAgIHBhcnNlcklucHV0LiRjaGFyID0gZnVuY3Rpb24odG9rKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQXQocGFyc2VySW5wdXQuaSkgIT09IHRvaykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcFdoaXRlc3BhY2UoMSk7XG4gICAgICAgIHJldHVybiB0b2s7XG4gICAgfTtcblxuICAgIHBhcnNlcklucHV0LiRzdHIgPSBmdW5jdGlvbih0b2spIHtcbiAgICAgICAgdmFyIHRva0xlbmd0aCA9IHRvay5sZW5ndGg7XG5cbiAgICAgICAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL3N0cmluZy1zdGFydHN3aXRoLzIxXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQXQocGFyc2VySW5wdXQuaSArIGkpICE9PSB0b2suY2hhckF0KGkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBza2lwV2hpdGVzcGFjZSh0b2tMZW5ndGgpO1xuICAgICAgICByZXR1cm4gdG9rO1xuICAgIH07XG5cbiAgICBwYXJzZXJJbnB1dC4kcXVvdGVkID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHN0YXJ0Q2hhciA9IGlucHV0LmNoYXJBdChwYXJzZXJJbnB1dC5pKTtcbiAgICAgICAgaWYgKHN0YXJ0Q2hhciAhPT0gXCInXCIgJiYgc3RhcnRDaGFyICE9PSAnXCInKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IGlucHV0Lmxlbmd0aCxcbiAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiA9IHBhcnNlcklucHV0Lmk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgKyBjdXJyZW50UG9zaXRpb24gPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5leHRDaGFyID0gaW5wdXQuY2hhckF0KGkgKyBjdXJyZW50UG9zaXRpb24pO1xuICAgICAgICAgICAgc3dpdGNoKG5leHRDaGFyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHN0YXJ0Q2hhcjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ciA9IGlucHV0LnN1YnN0cihjdXJyZW50UG9zaXRpb24sIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgc2tpcFdoaXRlc3BhY2UoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHBhcnNlcklucHV0LmF1dG9Db21tZW50QWJzb3JiID0gdHJ1ZTtcbiAgICBwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUgPSBbXTtcbiAgICBwYXJzZXJJbnB1dC5maW5pc2hlZCA9IGZhbHNlO1xuXG4gICAgLy8gU2FtZSBhcyAkKCksIGJ1dCBkb24ndCBjaGFuZ2UgdGhlIHN0YXRlIG9mIHRoZSBwYXJzZXIsXG4gICAgLy8ganVzdCByZXR1cm4gdGhlIG1hdGNoLlxuICAgIHBhcnNlcklucHV0LnBlZWsgPSBmdW5jdGlvbih0b2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2pzcGVyZi5jb20vc3RyaW5nLXN0YXJ0c3dpdGgvMjFcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJBdChwYXJzZXJJbnB1dC5pICsgaSkgIT09IHRvay5jaGFyQXQoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRvay50ZXN0KGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFNwZWNpYWxpemF0aW9uIG9mIHBlZWsoKVxuICAgIC8vIFRPRE8gcmVtb3ZlIG9yIGNoYW5nZSBzb21lIGN1cnJlbnRDaGFyIGNhbGxzIHRvIHBlZWtDaGFyXG4gICAgcGFyc2VySW5wdXQucGVla0NoYXIgPSBmdW5jdGlvbih0b2spIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LmNoYXJBdChwYXJzZXJJbnB1dC5pKSA9PT0gdG9rO1xuICAgIH07XG5cbiAgICBwYXJzZXJJbnB1dC5jdXJyZW50Q2hhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuY2hhckF0KHBhcnNlcklucHV0LmkpO1xuICAgIH07XG5cbiAgICBwYXJzZXJJbnB1dC5nZXRJbnB1dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfTtcblxuICAgIHBhcnNlcklucHV0LnBlZWtOb3ROdW1lcmljID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjID0gaW5wdXQuY2hhckNvZGVBdChwYXJzZXJJbnB1dC5pKTtcbiAgICAgICAgLy9JcyB0aGUgZmlyc3QgY2hhciBvZiB0aGUgZGltZW5zaW9uIDAtOSwgJy4nLCAnKycgb3IgJy0nXG4gICAgICAgIHJldHVybiAoYyA+IENIQVJDT0RFXzkgfHwgYyA8IENIQVJDT0RFX1BMVVMpIHx8IGMgPT09IENIQVJDT0RFX0ZPUldBUkRfU0xBU0ggfHwgYyA9PT0gQ0hBUkNPREVfQ09NTUE7XG4gICAgfTtcblxuICAgIHBhcnNlcklucHV0LnN0YXJ0ID0gZnVuY3Rpb24oc3RyLCBjaHVua0lucHV0LCBmYWlsRnVuY3Rpb24pIHtcbiAgICAgICAgaW5wdXQgPSBzdHI7XG4gICAgICAgIHBhcnNlcklucHV0LmkgPSBqID0gY3VycmVudFBvcyA9IGZ1cnRoZXN0ID0gMDtcblxuICAgICAgICAvLyBjaHVua2luZyBhcHBhcmVudGx5IG1ha2VzIHRoaW5ncyBxdWlja2VyIChidXQgbXkgdGVzdHMgaW5kaWNhdGVcbiAgICAgICAgLy8gaXQgbWlnaHQgYWN0dWFsbHkgbWFrZSB0aGluZ3Mgc2xvd2VyIGluIG5vZGUgYXQgbGVhc3QpXG4gICAgICAgIC8vIGFuZCBpdCBpcyBhIG5vbi1wZXJmZWN0IHBhcnNlIC0gaXQgY2FuJ3QgcmVjb2duaXNlXG4gICAgICAgIC8vIHVucXVvdGVkIHVybHMsIG1lYW5pbmcgaXQgY2FuJ3QgZGlzdGluZ3Vpc2ggY29tbWVudHNcbiAgICAgICAgLy8gbWVhbmluZyBjb21tZW50cyB3aXRoIHF1b3RlcyBvciB7fSgpIGluIHRoZW0gZ2V0ICdjb3VudGVkJ1xuICAgICAgICAvLyBhbmQgdGhlbiBsZWFkIHRvIHBhcnNlIGVycm9ycy5cbiAgICAgICAgLy8gSW4gYWRkaXRpb24gaWYgdGhlIGNodW5raW5nIGNodW5rcyBpbiB0aGUgd3JvbmcgcGxhY2Ugd2UgbWlnaHRcbiAgICAgICAgLy8gbm90IGJlIGFibGUgdG8gcGFyc2UgYSBwYXJzZXIgc3RhdGVtZW50IGluIG9uZSBnb1xuICAgICAgICAvLyB0aGlzIGlzIG9mZmljaWFsbHkgZGVwcmVjYXRlZCBidXQgY2FuIGJlIHN3aXRjaGVkIG9uIHZpYSBhbiBvcHRpb25cbiAgICAgICAgLy8gaW4gdGhlIGNhc2UgaXQgY2F1c2VzIHRvbyBtdWNoIHBlcmZvcm1hbmNlIGlzc3Vlcy5cbiAgICAgICAgaWYgKGNodW5rSW5wdXQpIHtcbiAgICAgICAgICAgIGNodW5rcyA9IGNodW5rZXIoc3RyLCBmYWlsRnVuY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2h1bmtzID0gW3N0cl07XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50ID0gY2h1bmtzWzBdO1xuXG4gICAgICAgIHNraXBXaGl0ZXNwYWNlKDApO1xuICAgIH07XG5cbiAgICBwYXJzZXJJbnB1dC5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UsXG4gICAgICAgICAgICBpc0ZpbmlzaGVkID0gcGFyc2VySW5wdXQuaSA+PSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHBhcnNlcklucHV0LmkgPCBmdXJ0aGVzdCkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGZ1cnRoZXN0UG9zc2libGVFcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICBwYXJzZXJJbnB1dC5pID0gZnVydGhlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzRmluaXNoZWQ6IGlzRmluaXNoZWQsXG4gICAgICAgICAgICBmdXJ0aGVzdDogcGFyc2VySW5wdXQuaSxcbiAgICAgICAgICAgIGZ1cnRoZXN0UG9zc2libGVFcnJvck1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICBmdXJ0aGVzdFJlYWNoZWRFbmQ6IHBhcnNlcklucHV0LmkgPj0gaW5wdXQubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIGZ1cnRoZXN0Q2hhcjogaW5wdXRbcGFyc2VySW5wdXQuaV1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHBhcnNlcklucHV0O1xufTtcblxufSx7XCIuL2NodW5rZXJcIjozNn1dLDM4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBMZXNzRXJyb3IgPSByZXF1aXJlKCcuLi9sZXNzLWVycm9yJyksXG4gICAgdHJlZSA9IHJlcXVpcmUoXCIuLi90cmVlXCIpLFxuICAgIHZpc2l0b3JzID0gcmVxdWlyZShcIi4uL3Zpc2l0b3JzXCIpLFxuICAgIGdldFBhcnNlcklucHV0ID0gcmVxdWlyZShcIi4vcGFyc2VyLWlucHV0XCIpLFxuICAgIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuXG4vL1xuLy8gbGVzcy5qcyAtIHBhcnNlclxuLy9cbi8vICAgIEEgcmVsYXRpdmVseSBzdHJhaWdodC1mb3J3YXJkIHByZWRpY3RpdmUgcGFyc2VyLlxuLy8gICAgVGhlcmUgaXMgbm8gdG9rZW5pemF0aW9uL2xleGluZyBzdGFnZSwgdGhlIGlucHV0IGlzIHBhcnNlZFxuLy8gICAgaW4gb25lIHN3ZWVwLlxuLy9cbi8vICAgIFRvIG1ha2UgdGhlIHBhcnNlciBmYXN0IGVub3VnaCB0byBydW4gaW4gdGhlIGJyb3dzZXIsIHNldmVyYWxcbi8vICAgIG9wdGltaXphdGlvbiBoYWQgdG8gYmUgbWFkZTpcbi8vXG4vLyAgICAtIE1hdGNoaW5nIGFuZCBzbGljaW5nIG9uIGEgaHVnZSBpbnB1dCBpcyBvZnRlbiBjYXVzZSBvZiBzbG93ZG93bnMuXG4vLyAgICAgIFRoZSBzb2x1dGlvbiBpcyB0byBjaHVua2lmeSB0aGUgaW5wdXQgaW50byBzbWFsbGVyIHN0cmluZ3MuXG4vLyAgICAgIFRoZSBjaHVua3MgYXJlIHN0b3JlZCBpbiB0aGUgYGNodW5rc2AgdmFyLFxuLy8gICAgICBgamAgaG9sZHMgdGhlIGN1cnJlbnQgY2h1bmsgaW5kZXgsIGFuZCBgY3VycmVudFBvc2AgaG9sZHNcbi8vICAgICAgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNodW5rIGluIHJlbGF0aW9uIHRvIGBpbnB1dGAuXG4vLyAgICAgIFRoaXMgZ2l2ZXMgdXMgYW4gYWxtb3N0IDR4IHNwZWVkLXVwLlxuLy9cbi8vICAgIC0gSW4gbWFueSBjYXNlcywgd2UgZG9uJ3QgbmVlZCB0byBtYXRjaCBpbmRpdmlkdWFsIHRva2Vucztcbi8vICAgICAgZm9yIGV4YW1wbGUsIGlmIGEgdmFsdWUgZG9lc24ndCBob2xkIGFueSB2YXJpYWJsZXMsIG9wZXJhdGlvbnNcbi8vICAgICAgb3IgZHluYW1pYyByZWZlcmVuY2VzLCB0aGUgcGFyc2VyIGNhbiBlZmZlY3RpdmVseSAnc2tpcCcgaXQsXG4vLyAgICAgIHRyZWF0aW5nIGl0IGFzIGEgbGl0ZXJhbC5cbi8vICAgICAgQW4gZXhhbXBsZSB3b3VsZCBiZSAnMXB4IHNvbGlkICMwMDAnIC0gd2hpY2ggZXZhbHVhdGVzIHRvIGl0c2VsZixcbi8vICAgICAgd2UgZG9uJ3QgbmVlZCB0byBrbm93IHdoYXQgdGhlIGluZGl2aWR1YWwgY29tcG9uZW50cyBhcmUuXG4vLyAgICAgIFRoZSBkcmF3YmFjaywgb2YgY291cnNlIGlzIHRoYXQgeW91IGRvbid0IGdldCB0aGUgYmVuZWZpdHMgb2Zcbi8vICAgICAgc3ludGF4LWNoZWNraW5nIG9uIHRoZSBDU1MuIFRoaXMgZ2l2ZXMgdXMgYSA1MCUgc3BlZWQtdXAgaW4gdGhlIHBhcnNlcixcbi8vICAgICAgYW5kIGEgc21hbGxlciBzcGVlZC11cCBpbiB0aGUgY29kZS1nZW4uXG4vL1xuLy9cbi8vICAgIFRva2VuIG1hdGNoaW5nIGlzIGRvbmUgd2l0aCB0aGUgYCRgIGZ1bmN0aW9uLCB3aGljaCBlaXRoZXIgdGFrZXNcbi8vICAgIGEgdGVybWluYWwgc3RyaW5nIG9yIHJlZ2V4cCwgb3IgYSBub24tdGVybWluYWwgZnVuY3Rpb24gdG8gY2FsbC5cbi8vICAgIEl0IGFsc28gdGFrZXMgY2FyZSBvZiBtb3ZpbmcgYWxsIHRoZSBpbmRpY2VzIGZvcndhcmRzLlxuLy9gXG4vL1xudmFyIFBhcnNlciA9IGZ1bmN0aW9uIFBhcnNlcihjb250ZXh0LCBpbXBvcnRzLCBmaWxlSW5mbykge1xuICAgIHZhciBwYXJzZXJzLFxuICAgICAgICBwYXJzZXJJbnB1dCA9IGdldFBhcnNlcklucHV0KCk7XG5cbiAgICBmdW5jdGlvbiBlcnJvcihtc2csIHR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IExlc3NFcnJvcihcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyc2VySW5wdXQuaSxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZUluZm8uZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSB8fCAnU3ludGF4JyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2dcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbXBvcnRzXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwZWN0KGFyZywgbXNnLCBpbmRleCkge1xuICAgICAgICAvLyBzb21lIG9sZGVyIGJyb3dzZXJzIHJldHVybiB0eXBlb2YgJ2Z1bmN0aW9uJyBmb3IgUmVnRXhwXG4gICAgICAgIHZhciByZXN1bHQgPSAoYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24pID8gYXJnLmNhbGwocGFyc2VycykgOiBwYXJzZXJJbnB1dC4kcmUoYXJnKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlcnJvcihtc2cgfHwgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnID8gXCJleHBlY3RlZCAnXCIgKyBhcmcgKyBcIicgZ290ICdcIiArIHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgKyBcIidcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwidW5leHBlY3RlZCB0b2tlblwiKSk7XG4gICAgfVxuXG4gICAgLy8gU3BlY2lhbGl6YXRpb24gb2YgZXhwZWN0KClcbiAgICBmdW5jdGlvbiBleHBlY3RDaGFyKGFyZywgbXNnKSB7XG4gICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcihhcmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yKG1zZyB8fCBcImV4cGVjdGVkICdcIiArIGFyZyArIFwiJyBnb3QgJ1wiICsgcGFyc2VySW5wdXQuY3VycmVudENoYXIoKSArIFwiJ1wiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREZWJ1Z0luZm8oaW5kZXgpIHtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gZmlsZUluZm8uZmlsZW5hbWU7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IHV0aWxzLmdldExvY2F0aW9uKGluZGV4LCBwYXJzZXJJbnB1dC5nZXRJbnB1dCgpKS5saW5lICsgMSxcbiAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlbmFtZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gVGhlIFBhcnNlclxuICAgIC8vXG4gICAgcmV0dXJuIHtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBQYXJzZSBhbiBpbnB1dCBzdHJpbmcgaW50byBhbiBhYnN0cmFjdCBzeW50YXggdHJlZSxcbiAgICAgICAgLy8gQHBhcmFtIHN0ciBBIHN0cmluZyBjb250YWluaW5nICdsZXNzJyBtYXJrdXBcbiAgICAgICAgLy8gQHBhcmFtIGNhbGxiYWNrIGNhbGwgYGNhbGxiYWNrYCB3aGVuIGRvbmUuXG4gICAgICAgIC8vIEBwYXJhbSBbYWRkaXRpb25hbERhdGFdIEFuIG9wdGlvbmFsIG1hcCB3aGljaCBjYW4gY29udGFpbnMgdmFycyAtIGEgbWFwIChrZXksIHZhbHVlKSBvZiB2YXJpYWJsZXMgdG8gYXBwbHlcbiAgICAgICAgLy9cbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChzdHIsIGNhbGxiYWNrLCBhZGRpdGlvbmFsRGF0YSkge1xuICAgICAgICAgICAgdmFyIHJvb3QsIGVycm9yID0gbnVsbCwgZ2xvYmFsVmFycywgbW9kaWZ5VmFycywgaWdub3JlZCwgcHJlVGV4dCA9IFwiXCI7XG5cbiAgICAgICAgICAgIGdsb2JhbFZhcnMgPSAoYWRkaXRpb25hbERhdGEgJiYgYWRkaXRpb25hbERhdGEuZ2xvYmFsVmFycykgPyBQYXJzZXIuc2VyaWFsaXplVmFycyhhZGRpdGlvbmFsRGF0YS5nbG9iYWxWYXJzKSArICdcXG4nIDogJyc7XG4gICAgICAgICAgICBtb2RpZnlWYXJzID0gKGFkZGl0aW9uYWxEYXRhICYmIGFkZGl0aW9uYWxEYXRhLm1vZGlmeVZhcnMpID8gJ1xcbicgKyBQYXJzZXIuc2VyaWFsaXplVmFycyhhZGRpdGlvbmFsRGF0YS5tb2RpZnlWYXJzKSA6ICcnO1xuXG4gICAgICAgICAgICBpZiAoY29udGV4dC5wbHVnaW5NYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZVByb2Nlc3NvcnMgPSBjb250ZXh0LnBsdWdpbk1hbmFnZXIuZ2V0UHJlUHJvY2Vzc29ycygpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlUHJvY2Vzc29ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBwcmVQcm9jZXNzb3JzW2ldLnByb2Nlc3Moc3RyLCB7IGNvbnRleHQ6IGNvbnRleHQsIGltcG9ydHM6IGltcG9ydHMsIGZpbGVJbmZvOiBmaWxlSW5mbyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChnbG9iYWxWYXJzIHx8IChhZGRpdGlvbmFsRGF0YSAmJiBhZGRpdGlvbmFsRGF0YS5iYW5uZXIpKSB7XG4gICAgICAgICAgICAgICAgcHJlVGV4dCA9ICgoYWRkaXRpb25hbERhdGEgJiYgYWRkaXRpb25hbERhdGEuYmFubmVyKSA/IGFkZGl0aW9uYWxEYXRhLmJhbm5lciA6IFwiXCIpICsgZ2xvYmFsVmFycztcbiAgICAgICAgICAgICAgICBpZ25vcmVkID0gaW1wb3J0cy5jb250ZW50c0lnbm9yZWRDaGFycztcbiAgICAgICAgICAgICAgICBpZ25vcmVkW2ZpbGVJbmZvLmZpbGVuYW1lXSA9IGlnbm9yZWRbZmlsZUluZm8uZmlsZW5hbWVdIHx8IDA7XG4gICAgICAgICAgICAgICAgaWdub3JlZFtmaWxlSW5mby5maWxlbmFtZV0gKz0gcHJlVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9cXHJcXG4/L2csICdcXG4nKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBwb3RlbnRpYWwgVVRGIEJ5dGUgT3JkZXIgTWFya1xuICAgICAgICAgICAgc3RyID0gcHJlVGV4dCArIHN0ci5yZXBsYWNlKC9eXFx1RkVGRi8sICcnKSArIG1vZGlmeVZhcnM7XG4gICAgICAgICAgICBpbXBvcnRzLmNvbnRlbnRzW2ZpbGVJbmZvLmZpbGVuYW1lXSA9IHN0cjtcblxuICAgICAgICAgICAgLy8gU3RhcnQgd2l0aCB0aGUgcHJpbWFyeSBydWxlLlxuICAgICAgICAgICAgLy8gVGhlIHdob2xlIHN5bnRheCB0cmVlIGlzIGhlbGQgdW5kZXIgYSBSdWxlc2V0IG5vZGUsXG4gICAgICAgICAgICAvLyB3aXRoIHRoZSBgcm9vdGAgcHJvcGVydHkgc2V0IHRvIHRydWUsIHNvIG5vIGB7fWAgYXJlXG4gICAgICAgICAgICAvLyBvdXRwdXQuIFRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgaW5wdXQgaXMgcGFyc2VkLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zdGFydChzdHIsIGNvbnRleHQuY2h1bmtJbnB1dCwgZnVuY3Rpb24gZmFpbChtc2csIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBMZXNzRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1BhcnNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlSW5mby5maWxlbmFtZVxuICAgICAgICAgICAgICAgICAgICB9LCBpbXBvcnRzKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJvb3QgPSBuZXcodHJlZS5SdWxlc2V0KShudWxsLCB0aGlzLnBhcnNlcnMucHJpbWFyeSgpKTtcbiAgICAgICAgICAgICAgICByb290LnJvb3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJvb3QuZmlyc3RSb290ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IExlc3NFcnJvcihlLCBpbXBvcnRzLCBmaWxlSW5mby5maWxlbmFtZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBgaWAgaXMgc21hbGxlciB0aGFuIHRoZSBgaW5wdXQubGVuZ3RoIC0gMWAsXG4gICAgICAgICAgICAvLyBpdCBtZWFucyB0aGUgcGFyc2VyIHdhc24ndCBhYmxlIHRvIHBhcnNlIHRoZSB3aG9sZVxuICAgICAgICAgICAgLy8gc3RyaW5nLCBzbyB3ZSd2ZSBnb3QgYSBwYXJzaW5nIGVycm9yLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFdlIHRyeSB0byBleHRyYWN0IGEgXFxuIGRlbGltaXRlZCBzdHJpbmcsXG4gICAgICAgICAgICAvLyBzaG93aW5nIHRoZSBsaW5lIHdoZXJlIHRoZSBwYXJzZSBlcnJvciBvY2N1cnJlZC5cbiAgICAgICAgICAgIC8vIFdlIHNwbGl0IGl0IHVwIGludG8gdHdvIHBhcnRzICh0aGUgcGFydCB3aGljaCBwYXJzZWQsXG4gICAgICAgICAgICAvLyBhbmQgdGhlIHBhcnQgd2hpY2ggZGlkbid0KSwgc28gd2UgY2FuIGNvbG9yIHRoZW0gZGlmZmVyZW50bHkuXG4gICAgICAgICAgICB2YXIgZW5kSW5mbyA9IHBhcnNlcklucHV0LmVuZCgpO1xuICAgICAgICAgICAgaWYgKCFlbmRJbmZvLmlzRmluaXNoZWQpIHtcblxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZW5kSW5mby5mdXJ0aGVzdFBvc3NpYmxlRXJyb3JNZXNzYWdlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlVucmVjb2duaXNlZCBpbnB1dFwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSW5mby5mdXJ0aGVzdENoYXIgPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIi4gUG9zc2libHkgbWlzc2luZyBvcGVuaW5nICd7J1wiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVuZEluZm8uZnVydGhlc3RDaGFyID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIuIFBvc3NpYmx5IG1pc3Npbmcgb3BlbmluZyAnKCdcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmRJbmZvLmZ1cnRoZXN0UmVhY2hlZEVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIi4gUG9zc2libHkgbWlzc2luZyBzb21ldGhpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IExlc3NFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUGFyc2VcIixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGVuZEluZm8uZnVydGhlc3QsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlSW5mby5maWxlbmFtZVxuICAgICAgICAgICAgICAgIH0sIGltcG9ydHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZmluaXNoID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlID0gZXJyb3IgfHwgZSB8fCBpbXBvcnRzLmVycm9yO1xuXG4gICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIExlc3NFcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBuZXcgTGVzc0Vycm9yKGUsIGltcG9ydHMsIGZpbGVJbmZvLmZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByb290KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoY29udGV4dC5wcm9jZXNzSW1wb3J0cyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBuZXcgdmlzaXRvcnMuSW1wb3J0VmlzaXRvcihpbXBvcnRzLCBmaW5pc2gpXG4gICAgICAgICAgICAgICAgICAgIC5ydW4ocm9vdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvL1xuICAgICAgICAvLyBIZXJlIGluLCB0aGUgcGFyc2luZyBydWxlcy9mdW5jdGlvbnNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIGJhc2ljIHN0cnVjdHVyZSBvZiB0aGUgc3ludGF4IHRyZWUgZ2VuZXJhdGVkIGlzIGFzIGZvbGxvd3M6XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgUnVsZXNldCAtPiAgUnVsZSAtPiBWYWx1ZSAtPiBFeHByZXNzaW9uIC0+IEVudGl0eVxuICAgICAgICAvL1xuICAgICAgICAvLyBIZXJlJ3Mgc29tZSBMZXNzIGNvZGU6XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgIC5jbGFzcyB7XG4gICAgICAgIC8vICAgICAgY29sb3I6ICNmZmY7XG4gICAgICAgIC8vICAgICAgYm9yZGVyOiAxcHggc29saWQgIzAwMDtcbiAgICAgICAgLy8gICAgICB3aWR0aDogQHcgKyA0cHg7XG4gICAgICAgIC8vICAgICAgPiAuY2hpbGQgey4uLn1cbiAgICAgICAgLy8gICAgfVxuICAgICAgICAvL1xuICAgICAgICAvLyBBbmQgaGVyZSdzIHdoYXQgdGhlIHBhcnNlIHRyZWUgbWlnaHQgbG9vayBsaWtlOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgUnVsZXNldCAoU2VsZWN0b3IgJy5jbGFzcycsIFtcbiAgICAgICAgLy8gICAgICAgICBSdWxlIChcImNvbG9yXCIsICBWYWx1ZSAoW0V4cHJlc3Npb24gW0NvbG9yICNmZmZdXSkpXG4gICAgICAgIC8vICAgICAgICAgUnVsZSAoXCJib3JkZXJcIiwgVmFsdWUgKFtFeHByZXNzaW9uIFtEaW1lbnNpb24gMXB4XVtLZXl3b3JkIFwic29saWRcIl1bQ29sb3IgIzAwMF1dKSlcbiAgICAgICAgLy8gICAgICAgICBSdWxlIChcIndpZHRoXCIsICBWYWx1ZSAoW0V4cHJlc3Npb24gW09wZXJhdGlvbiBcIiArIFwiIFtWYXJpYWJsZSBcIkB3XCJdW0RpbWVuc2lvbiA0cHhdXV0pKVxuICAgICAgICAvLyAgICAgICAgIFJ1bGVzZXQgKFNlbGVjdG9yIFtFbGVtZW50ICc+JywgJy5jaGlsZCddLCBbLi4uXSlcbiAgICAgICAgLy8gICAgIF0pXG4gICAgICAgIC8vXG4gICAgICAgIC8vICBJbiBnZW5lcmFsLCBtb3N0IHJ1bGVzIHdpbGwgdHJ5IHRvIHBhcnNlIGEgdG9rZW4gd2l0aCB0aGUgYCRyZSgpYCBmdW5jdGlvbiwgYW5kIGlmIHRoZSByZXR1cm5cbiAgICAgICAgLy8gIHZhbHVlIGlzIHRydWx5LCB3aWxsIHJldHVybiBhIG5ldyBub2RlLCBvZiB0aGUgcmVsZXZhbnQgdHlwZS4gU29tZXRpbWVzLCB3ZSBuZWVkIHRvIGNoZWNrXG4gICAgICAgIC8vICBmaXJzdCwgYmVmb3JlIHBhcnNpbmcsIHRoYXQncyB3aGVuIHdlIHVzZSBgcGVlaygpYC5cbiAgICAgICAgLy9cbiAgICAgICAgcGFyc2VyczogcGFyc2VycyA9IHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgYHByaW1hcnlgIHJ1bGUgaXMgdGhlICplbnRyeSogYW5kICpleGl0KiBwb2ludCBvZiB0aGUgcGFyc2VyLlxuICAgICAgICAgICAgLy8gVGhlIHJ1bGVzIGhlcmUgY2FuIGFwcGVhciBhdCBhbnkgbGV2ZWwgb2YgdGhlIHBhcnNlIHRyZWUuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhlIHJlY3Vyc2l2ZSBuYXR1cmUgb2YgdGhlIGdyYW1tYXIgaXMgYW4gaW50ZXJwbGF5IGJldHdlZW4gdGhlIGBibG9ja2BcbiAgICAgICAgICAgIC8vIHJ1bGUsIHdoaWNoIHJlcHJlc2VudHMgYHsgLi4uIH1gLCB0aGUgYHJ1bGVzZXRgIHJ1bGUsIGFuZCB0aGlzIGBwcmltYXJ5YCBydWxlLFxuICAgICAgICAgICAgLy8gYXMgcmVwcmVzZW50ZWQgYnkgdGhpcyBzaW1wbGlmaWVkIGdyYW1tYXI6XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgIHByaW1hcnkgIOKGkiAgKHJ1bGVzZXQgfCBydWxlKStcbiAgICAgICAgICAgIC8vICAgICBydWxlc2V0ICDihpIgIHNlbGVjdG9yKyBibG9ja1xuICAgICAgICAgICAgLy8gICAgIGJsb2NrICAgIOKGkiAgJ3snIHByaW1hcnkgJ30nXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gT25seSBhdCBvbmUgcG9pbnQgaXMgdGhlIHByaW1hcnkgcnVsZSBub3QgY2FsbGVkIGZyb20gdGhlXG4gICAgICAgICAgICAvLyBibG9jayBydWxlOiBhdCB0aGUgcm9vdCBsZXZlbC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBwcmltYXJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1peGluID0gdGhpcy5taXhpbiwgcm9vdCA9IFtdLCBub2RlO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLmNvbW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZSkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsd2F5cyBwcm9jZXNzIGNvbW1lbnRzIGJlZm9yZSBkZWNpZGluZyBpZiBmaW5pc2hlZFxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5wZWVrKCd9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuZXh0ZW5kUnVsZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QuY29uY2F0KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbWl4aW4uZGVmaW5pdGlvbigpIHx8IHRoaXMucnVsZSgpIHx8IHRoaXMucnVsZXNldCgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtaXhpbi5jYWxsKCkgfHwgdGhpcy5ydWxlc2V0Q2FsbCgpIHx8IHRoaXMuZW50aXRpZXMuY2FsbCgpIHx8IHRoaXMuZGlyZWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmRTZW1pQ29sb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChwYXJzZXJJbnB1dC4kY2hhcihcIjtcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFNlbWlDb2xvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kU2VtaUNvbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIGNvbW1lbnRzIGFyZSBjb2xsZWN0ZWQgYnkgdGhlIG1haW4gcGFyc2luZyBtZWNoYW5pc20gYW5kIHRoZW4gYXNzaWduZWQgdG8gbm9kZXNcbiAgICAgICAgICAgIC8vIHdoZXJlIHRoZSBjdXJyZW50IHN0cnVjdHVyZSBhbGxvd3MgaXRcbiAgICAgICAgICAgIGNvbW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuY29tbWVudFN0b3JlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHBhcnNlcklucHV0LmNvbW1lbnRTdG9yZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuQ29tbWVudCkoY29tbWVudC50ZXh0LCBjb21tZW50LmlzTGluZUNvbW1lbnQsIGNvbW1lbnQuaW5kZXgsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRW50aXRpZXMgYXJlIHRva2VucyB3aGljaCBjYW4gYmUgZm91bmQgaW5zaWRlIGFuIEV4cHJlc3Npb25cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBlbnRpdGllczoge1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gQSBzdHJpbmcsIHdoaWNoIHN1cHBvcnRzIGVzY2FwaW5nIFwiIGFuZCAnXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgXCJtaWxreSB3YXlcIiAnaGVcXCdzIHRoZSBvbmUhJ1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgcXVvdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHIsIGluZGV4ID0gcGFyc2VySW5wdXQuaSwgaXNFc2NhcGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoXCJ+XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IHBhcnNlcklucHV0LiRxdW90ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuUXVvdGVkKShzdHIuY2hhckF0KDApLCBzdHIuc3Vic3RyKDEsIHN0ci5sZW5ndGggLSAyKSwgaXNFc2NhcGVkLCBpbmRleCwgZmlsZUluZm8pO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEEgY2F0Y2gtYWxsIHdvcmQsIHN1Y2ggYXM6XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgYmxhY2sgYm9yZGVyLWNvbGxhcHNlXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0gcGFyc2VySW5wdXQuJGNoYXIoXCIlXCIpIHx8IHBhcnNlcklucHV0LiRyZSgvXltfQS1aYS16LV1bX0EtWmEtejAtOS1dKi8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyZWUuQ29sb3IuZnJvbUtleXdvcmQoaykgfHwgbmV3KHRyZWUuS2V5d29yZCkoayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBBIGZ1bmN0aW9uIGNhbGxcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICByZ2IoMjU1LCAwLCAyNTUpXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBXZSBhbHNvIHRyeSB0byBjYXRjaCBJRSdzIGBhbHBoYSgpYCwgYnV0IGxldCB0aGUgYGFscGhhYCBwYXJzZXJcbiAgICAgICAgICAgICAgICAvLyBkZWFsIHdpdGggdGhlIGRldGFpbHMuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBUaGUgYXJndW1lbnRzIGFyZSBwYXJzZWQgd2l0aCB0aGUgYGVudGl0aWVzLmFyZ3VtZW50c2AgcGFyc2VyLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgY2FsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSwgbmFtZUxDLCBhcmdzLCBhbHBoYSwgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nhc2UtaW5zZW5zaXRpdmUtcmVnZXgtdnMtc3RydG9sb3dlci10aGVuLXJlZ2V4LzE4XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5wZWVrKC9edXJsXFwoL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHBhcnNlcklucHV0LiRyZSgvXihbXFx3LV0rfCV8cHJvZ2lkOltcXHdcXC5dKylcXCgvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuYW1lKSB7IHBhcnNlcklucHV0LmZvcmdldCgpOyByZXR1cm47IH1cblxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZUxDID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lTEMgPT09ICdhbHBoYScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gcGFyc2Vycy5hbHBoYSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFscGhhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IHRoaXMuYXJndW1lbnRzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEgcGFyc2VySW5wdXQuJGNoYXIoJyknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZShcIkNvdWxkIG5vdCBwYXJzZSBjYWxsIGFyZ3VtZW50cyBvciBtaXNzaW5nICcpJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuQ2FsbCkobmFtZSwgYXJncywgaW5kZXgsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJnc1NlbWlDb2xvbiA9IFtdLCBhcmdzQ29tbWEgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NlbWlDb2xvblNlcGFyYXRlZCwgdmFsdWUsIGFyZztcblxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gcGFyc2Vycy5kZXRhY2hlZFJ1bGVzZXQoKSB8fCB0aGlzLmFzc2lnbm1lbnQoKSB8fCBwYXJzZXJzLmV4cHJlc3Npb24oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhcmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcudmFsdWUgJiYgYXJnLnZhbHVlLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhcmcudmFsdWVbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzQ29tbWEucHVzaCh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignLCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignOycpIHx8IGlzU2VtaUNvbG9uU2VwYXJhdGVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NlbWlDb2xvblNlcGFyYXRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyh0cmVlLlZhbHVlKShleHByZXNzaW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NTZW1pQ29sb24ucHVzaCh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1NlbWlDb2xvblNlcGFyYXRlZCA/IGFyZ3NTZW1pQ29sb24gOiBhcmdzQ29tbWE7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsaXRlcmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbigpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbG9yKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVvdGVkKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5pY29kZURlc2NyaXB0b3IoKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gQXNzaWdubWVudHMgYXJlIGFyZ3VtZW50IGVudGl0aWVzIGZvciBjYWxscy5cbiAgICAgICAgICAgICAgICAvLyBUaGV5IGFyZSBwcmVzZW50IGluIGllIGZpbHRlciBwcm9wZXJ0aWVzIGFzIHNob3duIGJlbG93LlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICAgIGZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhKCAqb3BhY2l0eT01MCogKVxuICAgICAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgICAgICBhc3NpZ25tZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXksIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlcklucHV0LiRyZSgvXlxcdysoPz1cXHM/PSkvaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignPScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZXJzLmVudGl0eSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLkFzc2lnbm1lbnQpKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdXJsKCkgdG9rZW5zXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgYSBzcGVjaWZpYyBydWxlIGZvciB1cmxzLCBiZWNhdXNlIHRoZXkgZG9uJ3QgcmVhbGx5IGJlaGF2ZSBsaWtlXG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmQgZnVuY3Rpb24gY2FsbHMuIFRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhlIGFyZ3VtZW50IGRvZXNuJ3QgaGF2ZVxuICAgICAgICAgICAgICAgIC8vIHRvIGJlIGVuY2xvc2VkIHdpdGhpbiBhIHN0cmluZywgc28gaXQgY2FuJ3QgYmUgcGFyc2VkIGFzIGFuIEV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB1cmw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlLCBpbmRleCA9IHBhcnNlcklucHV0Lmk7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuYXV0b0NvbW1lbnRBYnNvcmIgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRzdHIoXCJ1cmwoXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5hdXRvQ29tbWVudEFic29yYiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucXVvdGVkKCkgfHwgdGhpcy52YXJpYWJsZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuJHJlKC9eKD86KD86XFxcXFtcXChcXCknXCJdKXxbXlxcKFxcKSdcIl0pKy8pIHx8IFwiXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuYXV0b0NvbW1lbnRBYnNvcmIgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdENoYXIoJyknKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuVVJMKSgodmFsdWUudmFsdWUgIT0gbnVsbCB8fCB2YWx1ZSBpbnN0YW5jZW9mIHRyZWUuVmFyaWFibGUpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA6IG5ldyh0cmVlLkFub255bW91cykodmFsdWUpLCBpbmRleCwgZmlsZUluZm8pO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEEgVmFyaWFibGUgZW50aXR5LCBzdWNoIGFzIGBAZmlua2AsIGluXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgd2lkdGg6IEBmaW5rICsgMnB4XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgYSBkaWZmZXJlbnQgcGFyc2VyIGZvciB2YXJpYWJsZSBkZWZpbml0aW9ucyxcbiAgICAgICAgICAgICAgICAvLyBzZWUgYHBhcnNlcnMudmFyaWFibGVgLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgdmFyaWFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUsIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuY3VycmVudENoYXIoKSA9PT0gJ0AnICYmIChuYW1lID0gcGFyc2VySW5wdXQuJHJlKC9eQEA/W1xcdy1dKy8pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLlZhcmlhYmxlKShuYW1lLCBpbmRleCwgZmlsZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIEEgdmFyaWFibGUgZW50aXR5IHVzaW5nIHRoZSBwcm90ZWN0aXZlIHt9IGUuZy4gQHt2YXJ9XG4gICAgICAgICAgICAgICAgdmFyaWFibGVDdXJseTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VybHksIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuY3VycmVudENoYXIoKSA9PT0gJ0AnICYmIChjdXJseSA9IHBhcnNlcklucHV0LiRyZSgvXkBcXHsoW1xcdy1dKylcXH0vKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5WYXJpYWJsZSkoXCJAXCIgKyBjdXJseVsxXSwgaW5kZXgsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEEgSGV4YWRlY2ltYWwgY29sb3JcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICAjNEYzQzJGXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBgcmdiYCBhbmQgYGhzbGAgY29sb3JzIGFyZSBwYXJzZWQgdGhyb3VnaCB0aGUgYGVudGl0aWVzLmNhbGxgIHBhcnNlci5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGNvbG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZ2I7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgPT09ICcjJyAmJiAocmdiID0gcGFyc2VySW5wdXQuJHJlKC9eIyhbQS1GYS1mMC05XXs2fXxbQS1GYS1mMC05XXszfSkvKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmlwIGNvbG9ucywgYnJhY2tldHMsIHdoaXRlc3BhY2VzIGFuZCBvdGhlciBjaGFyYWN0ZXJzIHRoYXQgc2hvdWxkIG5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmaW5pdGVseSBiZSBwYXJ0IG9mIGNvbG9yIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yQ2FuZGlkYXRlU3RyaW5nID0gcmdiLmlucHV0Lm1hdGNoKC9eIyhbXFx3XSspLiovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yQ2FuZGlkYXRlU3RyaW5nID0gY29sb3JDYW5kaWRhdGVTdHJpbmdbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbG9yQ2FuZGlkYXRlU3RyaW5nLm1hdGNoKC9eW0EtRmEtZjAtOV0rJC8pKSB7IC8vIHZlcmlmeSBpZiBjYW5kaWRhdGUgY29uc2lzdHMgb25seSBvZiBhbGxvd2VkIEhFWCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJJbnZhbGlkIEhFWCBjb2xvciBjb2RlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLkNvbG9yKShyZ2JbMV0sIHVuZGVmaW5lZCwgJyMnICsgY29sb3JDYW5kaWRhdGVTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGNvbG9yS2V5d29yZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdXRvQ29tbWVudEFic29yYiA9IHBhcnNlcklucHV0LmF1dG9Db21tZW50QWJzb3JiO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5hdXRvQ29tbWVudEFic29yYiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgayA9IHBhcnNlcklucHV0LiRyZSgvXltfQS1aYS16LV1bX0EtWmEtejAtOS1dKy8pO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5hdXRvQ29tbWVudEFic29yYiA9IGF1dG9Db21tZW50QWJzb3JiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gdHJlZS5Db2xvci5mcm9tS2V5d29yZChrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC4kc3RyKGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gQSBEaW1lbnNpb24sIHRoYXQgaXMsIGEgbnVtYmVyIGFuZCBhIHVuaXRcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICAwLjVlbSA5NSVcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQucGVla05vdE51bWVyaWMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFyc2VySW5wdXQuJHJlKC9eKFsrLV0/XFxkKlxcLj9cXGQrKSglfFthLXpfXSspPy9pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuRGltZW5zaW9uKSh2YWx1ZVsxXSwgdmFsdWVbMl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gQSB1bmljb2RlIGRlc2NyaXB0b3IsIGFzIGlzIHVzZWQgaW4gdW5pY29kZS1yYW5nZVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVSswPz8gIG9yIFUrMDBBMS0wMEE5XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB1bmljb2RlRGVzY3JpcHRvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgdWQgPSBwYXJzZXJJbnB1dC4kcmUoL15VXFwrWzAtOWEtZkEtRj9dKyhcXC1bMC05YS1mQS1GP10rKT8vKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuVW5pY29kZURlc2NyaXB0b3IpKHVkWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEphdmFTY3JpcHQgY29kZSB0byBiZSBldmFsdWF0ZWRcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICBgd2luZG93LmxvY2F0aW9uLmhyZWZgXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBqYXZhc2NyaXB0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBqcywgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZXNjYXBlID0gcGFyc2VySW5wdXQuJGNoYXIoXCJ+XCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIganNRdW90ZSA9IHBhcnNlcklucHV0LiRjaGFyKFwiYFwiKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWpzUXVvdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGpzID0gcGFyc2VySW5wdXQuJHJlKC9eW15gXSpgLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuSmF2YVNjcmlwdCkoanMuc3Vic3RyKDAsIGpzLmxlbmd0aCAtIDEpLCBCb29sZWFuKGVzY2FwZSksIGluZGV4LCBmaWxlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZShcImludmFsaWQgamF2YXNjcmlwdCBkZWZpbml0aW9uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgdmFyaWFibGUgcGFydCBvZiBhIHZhcmlhYmxlIGRlZmluaXRpb24uIFVzZWQgaW4gdGhlIGBydWxlYCBwYXJzZXJcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgQGZpbms6XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFyaWFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpID09PSAnQCcgJiYgKG5hbWUgPSBwYXJzZXJJbnB1dC4kcmUoL14oQFtcXHctXSspXFxzKjovKSkpIHsgcmV0dXJuIG5hbWVbMV07IH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgdmFyaWFibGUgcGFydCBvZiBhIHZhcmlhYmxlIGRlZmluaXRpb24uIFVzZWQgaW4gdGhlIGBydWxlYCBwYXJzZXJcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgQGZpbmsoKTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBydWxlc2V0Q2FsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgPT09ICdAJyAmJiAobmFtZSA9IHBhcnNlcklucHV0LiRyZSgvXihAW1xcdy1dKylcXChcXHMqXFwpXFxzKjsvKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlJ1bGVzZXRDYWxsKG5hbWVbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBleHRlbmQgc3ludGF4IC0gdXNlZCB0byBleHRlbmQgc2VsZWN0b3JzXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbihpc1J1bGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMsIGUsIGluZGV4ID0gcGFyc2VySW5wdXQuaSwgb3B0aW9uLCBleHRlbmRMaXN0LCBleHRlbmQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRzdHIoaXNSdWxlID8gXCImOmV4dGVuZChcIiA6IFwiOmV4dGVuZChcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoISAob3B0aW9uID0gcGFyc2VySW5wdXQuJHJlKC9eKGFsbCkoPz1cXHMqKFxcKXwsKSkvKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLmVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBbIGUgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbiAmJiBvcHRpb25bMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwiTWlzc2luZyB0YXJnZXQgc2VsZWN0b3IgZm9yIDpleHRlbmQoKS5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kID0gbmV3KHRyZWUuRXh0ZW5kKShuZXcodHJlZS5TZWxlY3RvcikoZWxlbWVudHMpLCBvcHRpb24sIGluZGV4LCBmaWxlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRlbmRMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRMaXN0LnB1c2goZXh0ZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZExpc3QgPSBbIGV4dGVuZCBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAocGFyc2VySW5wdXQuJGNoYXIoXCIsXCIpKTtcblxuICAgICAgICAgICAgICAgIGV4cGVjdCgvXlxcKS8pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzUnVsZSkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoL147Lyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVuZExpc3Q7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gZXh0ZW5kUnVsZSAtIHVzZWQgaW4gYSBydWxlIHRvIGV4dGVuZCBhbGwgdGhlIHBhcmVudCBzZWxlY3RvcnNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBleHRlbmRSdWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlbmQodHJ1ZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gTWl4aW5zXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgbWl4aW46IHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEEgTWl4aW4gY2FsbCwgd2l0aCBhbiBvcHRpb25hbCBhcmd1bWVudCBsaXN0XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgI21peGlucyA+IC5zcXVhcmUoI2ZmZik7XG4gICAgICAgICAgICAgICAgLy8gICAgIC5yb3VuZGVkKDRweCwgYmxhY2spO1xuICAgICAgICAgICAgICAgIC8vICAgICAuYnV0dG9uO1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVGhlIGB3aGlsZWAgbG9vcCBpcyB0aGVyZSBiZWNhdXNlIG1peGlucyBjYW4gYmVcbiAgICAgICAgICAgICAgICAvLyBuYW1lc3BhY2VkLCBidXQgd2Ugb25seSBzdXBwb3J0IHRoZSBjaGlsZCBhbmQgZGVzY2VuZGFudFxuICAgICAgICAgICAgICAgIC8vIHNlbGVjdG9yIGZvciBub3cuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBjYWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gcGFyc2VySW5wdXQuY3VycmVudENoYXIoKSwgaW1wb3J0YW50ID0gZmFsc2UsIGluZGV4ID0gcGFyc2VySW5wdXQuaSwgZWxlbUluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMsIGVsZW0sIGUsIGMsIGFyZ3M7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgIT09ICcuJyAmJiBzICE9PSAnIycpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpOyAvLyBzdG9wIHVzIGFic29yYmluZyBwYXJ0IG9mIGFuIGludmFsaWQgc2VsZWN0b3JcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbUluZGV4ID0gcGFyc2VySW5wdXQuaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBwYXJzZXJJbnB1dC4kcmUoL15bIy5dKD86W1xcdy1dfFxcXFwoPzpbQS1GYS1mMC05XXsxLDZ9ID98W15BLUZhLWYwLTldKSkrLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBuZXcodHJlZS5FbGVtZW50KShjLCBlLCBlbGVtSW5kZXgsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gWyBlbGVtIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gcGFyc2VySW5wdXQuJGNoYXIoJz4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCcoJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gdGhpcy5hcmdzKHRydWUpLmFyZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0Q2hhcignKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2Vycy5pbXBvcnRhbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGFudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJzLmVuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLm1peGluLkNhbGwpKGVsZW1lbnRzLCBhcmdzLCBpbmRleCwgZmlsZUluZm8sIGltcG9ydGFudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhcmdzOiBmdW5jdGlvbiAoaXNDYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRpdGllcyA9IHBhcnNlcnMuZW50aXRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lciA9IHsgYXJnczpudWxsLCB2YXJpYWRpYzogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zID0gW10sIGFyZ3NTZW1pQ29sb24gPSBbXSwgYXJnc0NvbW1hID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NlbWlDb2xvblNlcGFyYXRlZCwgZXhwcmVzc2lvbkNvbnRhaW5zTmFtZWQsIG5hbWUsIG5hbWVMb29wLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsIGFyZywgZXhwYW5kO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IHBhcnNlcnMuZGV0YWNoZWRSdWxlc2V0KCkgfHwgcGFyc2Vycy5leHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmNvbW1lbnRTdG9yZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kc3RyKFwiLi4uXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVyLnZhcmlhZGljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKFwiO1wiKSAmJiAhaXNTZW1pQ29sb25TZXBhcmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VtaUNvbG9uU2VwYXJhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaXNTZW1pQ29sb25TZXBhcmF0ZWQgPyBhcmdzU2VtaUNvbG9uIDogYXJnc0NvbW1hKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnB1c2goeyB2YXJpYWRpYzogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGVudGl0aWVzLnZhcmlhYmxlKCkgfHwgZW50aXRpZXMubGl0ZXJhbCgpIHx8IGVudGl0aWVzLmtleXdvcmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZUxvb3AgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy50aHJvd0F3YXlDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZy50aHJvd0F3YXlDb21tZW50cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhcmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZhcmlhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy52YWx1ZSAmJiBhcmcudmFsdWUubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gYXJnLnZhbHVlWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gYXJnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsICYmIHZhbCBpbnN0YW5jZW9mIHRyZWUuVmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJzonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VtaUNvbG9uU2VwYXJhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJDYW5ub3QgbWl4IDsgYW5kICwgYXMgZGVsaW1pdGVyIHR5cGVzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbkNvbnRhaW5zTmFtZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZXJzLmRldGFjaGVkUnVsZXNldCgpIHx8IHBhcnNlcnMuZXhwcmVzc2lvbigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihcImNvdWxkIG5vdCB1bmRlcnN0YW5kIHZhbHVlIGZvciBuYW1lZCBhcmd1bWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVyLmFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZUxvb3AgPSAobmFtZSA9IHZhbC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlcklucHV0LiRzdHIoXCIuLi5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVyLnZhcmlhZGljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcihcIjtcIikgJiYgIWlzU2VtaUNvbG9uU2VwYXJhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTZW1pQ29sb25TZXBhcmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlzU2VtaUNvbG9uU2VwYXJhdGVkID8gYXJnc1NlbWlDb2xvbiA6IGFyZ3NDb21tYSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHVzaCh7IG5hbWU6IGFyZy5uYW1lLCB2YXJpYWRpYzogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzQ2FsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZUxvb3AgPSB2YWwubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NDb21tYS5wdXNoKHsgbmFtZTpuYW1lTG9vcCwgdmFsdWU6dmFsdWUsIGV4cGFuZDpleHBhbmQgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignLCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignOycpIHx8IGlzU2VtaUNvbG9uU2VwYXJhdGVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbkNvbnRhaW5zTmFtZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJDYW5ub3QgbWl4IDsgYW5kICwgYXMgZGVsaW1pdGVyIHR5cGVzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VtaUNvbG9uU2VwYXJhdGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3KHRyZWUuVmFsdWUpKGV4cHJlc3Npb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1NlbWlDb2xvbi5wdXNoKHsgbmFtZTpuYW1lLCB2YWx1ZTp2YWx1ZSwgZXhwYW5kOmV4cGFuZCB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbkNvbnRhaW5zTmFtZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5lci5hcmdzID0gaXNTZW1pQ29sb25TZXBhcmF0ZWQgPyBhcmdzU2VtaUNvbG9uIDogYXJnc0NvbW1hO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuZXI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEEgTWl4aW4gZGVmaW5pdGlvbiwgd2l0aCBhIGxpc3Qgb2YgcGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICAgIC5yb3VuZGVkIChAcmFkaXVzOiAycHgsIEBjb2xvcikge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAuLi5cbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVW50aWwgd2UgaGF2ZSBhIGZpbmVyIGdyYWluZWQgc3RhdGUtbWFjaGluZSwgd2UgaGF2ZSB0b1xuICAgICAgICAgICAgICAgIC8vIGRvIGEgbG9vay1haGVhZCwgdG8gbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgYSBtaXhpbiBjYWxsLlxuICAgICAgICAgICAgICAgIC8vIFNlZSB0aGUgYHJ1bGVgIGZ1bmN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gV2Ugc3RhcnQgYnkgbWF0Y2hpbmcgYC5yb3VuZGVkIChgLCBhbmQgdGhlbiBwcm9jZWVkIG9uIHRvXG4gICAgICAgICAgICAgICAgLy8gdGhlIGFyZ3VtZW50IGxpc3QsIHdoaWNoIGhhcyBvcHRpb25hbCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgICAgICAgICAgICAvLyBXZSBzdG9yZSB0aGUgcGFyYW1ldGVycyBpbiBgcGFyYW1zYCwgd2l0aCBhIGB2YWx1ZWAga2V5LFxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgdmFsdWUsIHN1Y2ggYXMgaW4gdGhlIGNhc2Ugb2YgYEByYWRpdXNgLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gT25jZSB3ZSd2ZSBnb3Qgb3VyIHBhcmFtcyBsaXN0LCBhbmQgYSBjbG9zaW5nIGApYCwgd2UgcGFyc2VcbiAgICAgICAgICAgICAgICAvLyB0aGUgYHsuLi59YCBibG9jay5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUsIHBhcmFtcyA9IFtdLCBtYXRjaCwgcnVsZXNldCwgY29uZCwgdmFyaWFkaWMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpICE9PSAnLicgJiYgcGFyc2VySW5wdXQuY3VycmVudENoYXIoKSAhPT0gJyMnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucGVlaygvXltee10qXFx9LykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHBhcnNlcklucHV0LiRyZSgvXihbIy5dKD86W1xcdy1dfFxcXFwoPzpbQS1GYS1mMC05XXsxLDZ9ID98W15BLUZhLWYwLTldKSkrKVxccypcXCgvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gbWF0Y2hbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdJbmZvID0gdGhpcy5hcmdzKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IGFyZ0luZm8uYXJncztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhZGljID0gYXJnSW5mby52YXJpYWRpYztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLm1peGluY2FsbChcIkB7YX1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb29rcyBhIGJpdCBsaWtlIGEgbWl4aW4gZGVmaW5pdGlvbi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAubWl4aW5jYWxsKEBhOiB7cnVsZTogc2V0O30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgaGF2ZSB0byBiZSBuaWNlIGFuZCByZXN0b3JlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKFwiTWlzc2luZyBjbG9zaW5nICcpJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmNvbW1lbnRTdG9yZS5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJHN0cihcIndoZW5cIikpIHsgLy8gR3VhcmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25kID0gZXhwZWN0KHBhcnNlcnMuY29uZGl0aW9ucywgJ2V4cGVjdGVkIGNvbmRpdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlc2V0ID0gcGFyc2Vycy5ibG9jaygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZXNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5taXhpbi5EZWZpbml0aW9uKShuYW1lLCBwYXJhbXMsIHJ1bGVzZXQsIGNvbmQsIHZhcmlhZGljKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRW50aXRpZXMgYXJlIHRoZSBzbWFsbGVzdCByZWNvZ25pemVkIHRva2VuLFxuICAgICAgICAgICAgLy8gYW5kIGNhbiBiZSBmb3VuZCBpbnNpZGUgYSBydWxlJ3MgdmFsdWUuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZW50aXR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudGl0aWVzID0gdGhpcy5lbnRpdGllcztcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbW1lbnQoKSB8fCBlbnRpdGllcy5saXRlcmFsKCkgfHwgZW50aXRpZXMudmFyaWFibGUoKSB8fCBlbnRpdGllcy51cmwoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICBlbnRpdGllcy5jYWxsKCkgICAgfHwgZW50aXRpZXMua2V5d29yZCgpICB8fCBlbnRpdGllcy5qYXZhc2NyaXB0KCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQSBSdWxlIHRlcm1pbmF0b3IuIE5vdGUgdGhhdCB3ZSB1c2UgYHBlZWsoKWAgdG8gY2hlY2sgZm9yICd9JyxcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIGBibG9ja2AgcnVsZSB3aWxsIGJlIGV4cGVjdGluZyBpdCwgYnV0IHdlIHN0aWxsIG5lZWQgdG8gbWFrZSBzdXJlXG4gICAgICAgICAgICAvLyBpdCdzIHRoZXJlLCBpZiAnOycgd2FzIG9taXR0ZWQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcklucHV0LiRjaGFyKCc7JykgfHwgcGFyc2VySW5wdXQucGVlaygnfScpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIElFJ3MgYWxwaGEgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgYWxwaGEob3BhY2l0eT04OClcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBhbHBoYTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nhc2UtaW5zZW5zaXRpdmUtcmVnZXgtdnMtc3RydG9sb3dlci10aGVuLXJlZ2V4LzE4XG4gICAgICAgICAgICAgICAgaWYgKCEgcGFyc2VySW5wdXQuJHJlKC9eb3BhY2l0eT0vaSkpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZXJJbnB1dC4kcmUoL15cXGQrLyk7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGV4cGVjdCh0aGlzLmVudGl0aWVzLnZhcmlhYmxlLCBcIkNvdWxkIG5vdCBwYXJzZSBhbHBoYVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0Q2hhcignKScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5BbHBoYSkodmFsdWUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEEgU2VsZWN0b3IgRWxlbWVudFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICBkaXZcbiAgICAgICAgICAgIC8vICAgICArIGgxXG4gICAgICAgICAgICAvLyAgICAgI3NvY2tzXG4gICAgICAgICAgICAvLyAgICAgaW5wdXRbdHlwZT1cInRleHRcIl1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBFbGVtZW50cyBhcmUgdGhlIGJ1aWxkaW5nIGJsb2NrcyBmb3IgU2VsZWN0b3JzLFxuICAgICAgICAgICAgLy8gdGhleSBhcmUgbWFkZSBvdXQgb2YgYSBgQ29tYmluYXRvcmAgKHNlZSBjb21iaW5hdG9yIHJ1bGUpLFxuICAgICAgICAgICAgLy8gYW5kIGFuIGVsZW1lbnQgbmFtZSwgc3VjaCBhcyBhIHRhZyBhIGNsYXNzLCBvciBgKmAuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlLCBjLCB2LCBpbmRleCA9IHBhcnNlcklucHV0Lmk7XG5cbiAgICAgICAgICAgICAgICBjID0gdGhpcy5jb21iaW5hdG9yKCk7XG5cbiAgICAgICAgICAgICAgICBlID0gcGFyc2VySW5wdXQuJHJlKC9eKD86XFxkK1xcLlxcZCt8XFxkKyklLykgfHxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuJHJlKC9eKD86Wy4jXT98OiopKD86W1xcdy1dfFteXFx4MDAtXFx4OWZdfFxcXFwoPzpbQS1GYS1mMC05XXsxLDZ9ID98W15BLUZhLWYwLTldKSkrLykgfHxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuJGNoYXIoJyonKSB8fCBwYXJzZXJJbnB1dC4kY2hhcignJicpIHx8IHRoaXMuYXR0cmlidXRlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuJHJlKC9eXFwoW14mKClAXStcXCkvKSB8fCAgcGFyc2VySW5wdXQuJHJlKC9eW1xcLiM6XSg/PUApLykgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnRpdGllcy52YXJpYWJsZUN1cmx5KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoISBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCcoJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodiA9IHRoaXMuc2VsZWN0b3IoKSkgJiYgcGFyc2VySW5wdXQuJGNoYXIoJyknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBuZXcodHJlZS5QYXJlbikodik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoXCJNaXNzaW5nIGNsb3NpbmcgJyknXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZSkgeyByZXR1cm4gbmV3KHRyZWUuRWxlbWVudCkoYywgZSwgaW5kZXgsIGZpbGVJbmZvKTsgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIENvbWJpbmF0b3JzIGNvbWJpbmUgZWxlbWVudHMgdG9nZXRoZXIsIGluIGEgU2VsZWN0b3IuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQmVjYXVzZSBvdXIgcGFyc2VyIGlzbid0IHdoaXRlLXNwYWNlIHNlbnNpdGl2ZSwgc3BlY2lhbCBjYXJlXG4gICAgICAgICAgICAvLyBoYXMgdG8gYmUgdGFrZW4sIHdoZW4gcGFyc2luZyB0aGUgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBgIGAsXG4gICAgICAgICAgICAvLyBhcyBpdCdzIGFuIGVtcHR5IHNwYWNlLiBXZSBoYXZlIHRvIGNoZWNrIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXJcbiAgICAgICAgICAgIC8vIGluIHRoZSBpbnB1dCwgdG8gc2VlIGlmIGl0J3MgYSBgIGAgY2hhcmFjdGVyLiBNb3JlIGluZm8gb24gaG93XG4gICAgICAgICAgICAvLyB3ZSBkZWFsIHdpdGggdGhpcyBpbiAqY29tYmluYXRvci5qcyouXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgY29tYmluYXRvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjID0gcGFyc2VySW5wdXQuY3VycmVudENoYXIoKTtcblxuICAgICAgICAgICAgICAgIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2xhc2hlZENvbWJpbmF0b3IgPSBwYXJzZXJJbnB1dC4kcmUoL15cXC9bYS16XStcXC8vaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbGFzaGVkQ29tYmluYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuQ29tYmluYXRvcikoc2xhc2hlZENvbWJpbmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJz4nIHx8IGMgPT09ICcrJyB8fCBjID09PSAnficgfHwgYyA9PT0gJ3wnIHx8IGMgPT09ICdeJykge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5pKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSAnXicgJiYgcGFyc2VySW5wdXQuY3VycmVudENoYXIoKSA9PT0gJ14nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJ15eJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocGFyc2VySW5wdXQuaXNXaGl0ZXNwYWNlKCkpIHsgcGFyc2VySW5wdXQuaSsrOyB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5Db21iaW5hdG9yKShjKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlcklucHV0LmlzV2hpdGVzcGFjZSgtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLkNvbWJpbmF0b3IpKFwiIFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuQ29tYmluYXRvcikobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBIENTUyBzZWxlY3RvciAoc2VlIHNlbGVjdG9yIGJlbG93KVxuICAgICAgICAgICAgLy8gd2l0aCBsZXNzIGV4dGVuc2lvbnMgZS5nLiB0aGUgYWJpbGl0eSB0byBleHRlbmQgYW5kIGd1YXJkXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgbGVzc1NlbGVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0b3IodHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEEgQ1NTIFNlbGVjdG9yXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgIC5jbGFzcyA+IGRpdiArIGgxXG4gICAgICAgICAgICAvLyAgICAgbGkgYTpob3ZlclxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFNlbGVjdG9ycyBhcmUgbWFkZSBvdXQgb2Ygb25lIG9yIG1vcmUgRWxlbWVudHMsIHNlZSBhYm92ZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBzZWxlY3RvcjogZnVuY3Rpb24gKGlzTGVzcykge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0LmksIGVsZW1lbnRzLCBleHRlbmRMaXN0LCBjLCBlLCBhbGxFeHRlbmRzLCB3aGVuLCBjb25kaXRpb247XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoKGlzTGVzcyAmJiAoZXh0ZW5kTGlzdCA9IHRoaXMuZXh0ZW5kKCkpKSB8fCAoaXNMZXNzICYmICh3aGVuID0gcGFyc2VySW5wdXQuJHN0cihcIndoZW5cIikpKSB8fCAoZSA9IHRoaXMuZWxlbWVudCgpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2hlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uID0gZXhwZWN0KHRoaXMuY29uZGl0aW9ucywgJ2V4cGVjdGVkIGNvbmRpdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJDU1MgZ3VhcmQgY2FuIG9ubHkgYmUgdXNlZCBhdCB0aGUgZW5kIG9mIHNlbGVjdG9yXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4dGVuZExpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGxFeHRlbmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsRXh0ZW5kcyA9IGFsbEV4dGVuZHMuY29uY2F0KGV4dGVuZExpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxFeHRlbmRzID0gZXh0ZW5kTGlzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGxFeHRlbmRzKSB7IGVycm9yKFwiRXh0ZW5kIGNhbiBvbmx5IGJlIHVzZWQgYXQgdGhlIGVuZCBvZiBzZWxlY3RvclwiKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IFsgZSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICd7JyB8fCBjID09PSAnfScgfHwgYyA9PT0gJzsnIHx8IGMgPT09ICcsJyB8fCBjID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7IHJldHVybiBuZXcodHJlZS5TZWxlY3RvcikoZWxlbWVudHMsIGFsbEV4dGVuZHMsIGNvbmRpdGlvbiwgaW5kZXgsIGZpbGVJbmZvKTsgfVxuICAgICAgICAgICAgICAgIGlmIChhbGxFeHRlbmRzKSB7IGVycm9yKFwiRXh0ZW5kIG11c3QgYmUgdXNlZCB0byBleHRlbmQgYSBzZWxlY3RvciwgaXQgY2Fubm90IGJlIHVzZWQgb24gaXRzIG93blwiKTsgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghIHBhcnNlcklucHV0LiRjaGFyKCdbJykpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZW50aXRpZXMgPSB0aGlzLmVudGl0aWVzLFxuICAgICAgICAgICAgICAgICAgICBrZXksIHZhbCwgb3A7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgPSBlbnRpdGllcy52YXJpYWJsZUN1cmx5KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGV4cGVjdCgvXig/OltfQS1aYS16MC05LVxcKl0qXFx8KT8oPzpbX0EtWmEtejAtOS1dfFxcXFwuKSsvKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvcCA9IHBhcnNlcklucHV0LiRyZSgvXlt8fiokXl0/PS8pO1xuICAgICAgICAgICAgICAgIGlmIChvcCkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBlbnRpdGllcy5xdW90ZWQoKSB8fCBwYXJzZXJJbnB1dC4kcmUoL15bMC05XSslLykgfHwgcGFyc2VySW5wdXQuJHJlKC9eW1xcdy1dKy8pIHx8IGVudGl0aWVzLnZhcmlhYmxlQ3VybHkoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBleHBlY3RDaGFyKCddJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuQXR0cmlidXRlKShrZXksIG9wLCB2YWwpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBgYmxvY2tgIHJ1bGUgaXMgdXNlZCBieSBgcnVsZXNldGAgYW5kIGBtaXhpbi5kZWZpbml0aW9uYC5cbiAgICAgICAgICAgIC8vIEl0J3MgYSB3cmFwcGVyIGFyb3VuZCB0aGUgYHByaW1hcnlgIHJ1bGUsIHdpdGggYWRkZWQgYHt9YC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBibG9jazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50O1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcigneycpICYmIChjb250ZW50ID0gdGhpcy5wcmltYXJ5KCkpICYmIHBhcnNlcklucHV0LiRjaGFyKCd9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYmxvY2tSdWxlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLmJsb2NrKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBuZXcgdHJlZS5SdWxlc2V0KG51bGwsIGJsb2NrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGV0YWNoZWRSdWxlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tSdWxlc2V0ID0gdGhpcy5ibG9ja1J1bGVzZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tSdWxlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5EZXRhY2hlZFJ1bGVzZXQoYmxvY2tSdWxlc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gZGl2LCAuY2xhc3MsIGJvZHkgPiBwIHsuLi59XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgcnVsZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvcnMsIHMsIHJ1bGVzLCBkZWJ1Z0luZm87XG5cbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5kdW1wTGluZU51bWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdJbmZvID0gZ2V0RGVidWdJbmZvKHBhcnNlcklucHV0LmkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgPSB0aGlzLmxlc3NTZWxlY3RvcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKHMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzID0gWyBzIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuY29tbWVudFN0b3JlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLmNvbmRpdGlvbiAmJiBzZWxlY3RvcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJHdWFyZHMgYXJlIG9ubHkgY3VycmVudGx5IGFsbG93ZWQgb24gYSBzaW5nbGUgc2VsZWN0b3IuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghIHBhcnNlcklucHV0LiRjaGFyKCcsJykpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHMuY29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihcIkd1YXJkcyBhcmUgb25seSBjdXJyZW50bHkgYWxsb3dlZCBvbiBhIHNpbmdsZSBzZWxlY3Rvci5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuY29tbWVudFN0b3JlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9ycyAmJiAocnVsZXMgPSB0aGlzLmJsb2NrKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnVsZXNldCA9IG5ldyh0cmVlLlJ1bGVzZXQpKHNlbGVjdG9ycywgcnVsZXMsIGNvbnRleHQuc3RyaWN0SW1wb3J0cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmR1bXBMaW5lTnVtYmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXNldC5kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGVzZXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydWxlOiBmdW5jdGlvbiAodHJ5QW5vbnltb3VzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUsIHZhbHVlLCBzdGFydE9mUnVsZSA9IHBhcnNlcklucHV0LmksIGMgPSBwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpLCBpbXBvcnRhbnQsIG1lcmdlLCBpc1ZhcmlhYmxlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGMgPT09ICcuJyB8fCBjID09PSAnIycgfHwgYyA9PT0gJyYnIHx8IGMgPT09ICc6JykgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzLnZhcmlhYmxlKCkgfHwgdGhpcy5ydWxlUHJvcGVydHkoKTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpc1ZhcmlhYmxlID0gdHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5kZXRhY2hlZFJ1bGVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmNvbW1lbnRTdG9yZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIG5hbWUgcmV0dXJuZWQgYnkgdGhpcy5ydWxlUHJvcGVydHkoKSBpcyBhbHdheXMgYW4gYXJyYXkgb2YgdGhlIGZvcm06XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBbc3RyaW5nLTEsIC4uLiwgc3RyaW5nLW4sIFwiXCJdIG9yIFtzdHJpbmctMSwgLi4uLCBzdHJpbmctbiwgXCIrXCJdXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVyZSBlYWNoIGl0ZW0gaXMgYSB0cmVlLktleXdvcmQgb3IgdHJlZS5WYXJpYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2UgPSAhaXNWYXJpYWJsZSAmJiBuYW1lLmxlbmd0aCA+IDEgJiYgbmFtZS5wb3AoKS52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlZmVyIHRvIHRyeSB0byBwYXJzZSBmaXJzdCBpZiBpdHMgYSB2YXJpYWJsZSBvciB3ZSBhcmUgY29tcHJlc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBhbHdheXMgZmFsbGJhY2sgb24gdGhlIG90aGVyIG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyeVZhbHVlRmlyc3QgPSAhdHJ5QW5vbnltb3VzICYmIChjb250ZXh0LmNvbXByZXNzIHx8IGlzVmFyaWFibGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJ5VmFsdWVGaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5hbm9ueW1vdXNWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5vbnltb3VzIHZhbHVlcyBhYnNvcmIgdGhlIGVuZCAnOycgd2hpY2ggaXMgcmVxdWlyZWQgZm9yIHRoZW0gdG8gd29ya1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLlJ1bGUpKG5hbWUsIHZhbHVlLCBmYWxzZSwgbWVyZ2UsIHN0YXJ0T2ZSdWxlLCBmaWxlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0cnlWYWx1ZUZpcnN0ICYmICF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRhbnQgPSB0aGlzLmltcG9ydGFudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMuZW5kKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5SdWxlKShuYW1lLCB2YWx1ZSwgaW1wb3J0YW50LCBtZXJnZSwgc3RhcnRPZlJ1bGUsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAhdHJ5QW5vbnltb3VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVsZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbm9ueW1vdXNWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHBhcnNlcklucHV0LiRyZSgvXihbXkArXFwvJ1wiKmAoO3t9LV0qKTsvKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLkFub255bW91cykobWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBbiBAaW1wb3J0IGRpcmVjdGl2ZVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICBAaW1wb3J0IFwibGliXCI7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIG91ciBlbnZpcm9ubWVudCwgaW1wb3J0aW5nIGlzIGRvbmUgZGlmZmVyZW50bHk6XG4gICAgICAgICAgICAvLyBJbiB0aGUgYnJvd3NlciwgaXQncyBhbiBYSFIgcmVxdWVzdCwgaW4gTm9kZSwgaXQgd291bGQgYmUgYVxuICAgICAgICAgICAgLy8gZmlsZS1zeXN0ZW0gb3BlcmF0aW9uLiBUaGUgZnVuY3Rpb24gdXNlZCBmb3IgaW1wb3J0aW5nIGlzXG4gICAgICAgICAgICAvLyBzdG9yZWQgaW4gYGltcG9ydGAsIHdoaWNoIHdlIHBhc3MgdG8gdGhlIEltcG9ydCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBcImltcG9ydFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGgsIGZlYXR1cmVzLCBpbmRleCA9IHBhcnNlcklucHV0Lmk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGlyID0gcGFyc2VySW5wdXQuJHJlKC9eQGltcG9ydD9cXHMrLyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gKGRpciA/IHRoaXMuaW1wb3J0T3B0aW9ucygpIDogbnVsbCkgfHwge307XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKChwYXRoID0gdGhpcy5lbnRpdGllcy5xdW90ZWQoKSB8fCB0aGlzLmVudGl0aWVzLnVybCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMgPSB0aGlzLm1lZGlhRmVhdHVyZXMoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignOycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuaSA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwibWlzc2luZyBzZW1pLWNvbG9uIG9yIHVucmVjb2duaXNlZCBtZWRpYSBmZWF0dXJlcyBvbiBpbXBvcnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcyA9IGZlYXR1cmVzICYmIG5ldyh0cmVlLlZhbHVlKShmZWF0dXJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHRyZWUuSW1wb3J0KShwYXRoLCBmZWF0dXJlcywgb3B0aW9ucywgaW5kZXgsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmkgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwibWFsZm9ybWVkIGltcG9ydCBzdGF0ZW1lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpbXBvcnRPcHRpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbywgb3B0aW9ucyA9IHt9LCBvcHRpb25OYW1lLCB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIC8vIGxpc3Qgb2Ygb3B0aW9ucywgc3Vycm91bmRlZCBieSBwYXJlbnNcbiAgICAgICAgICAgICAgICBpZiAoISBwYXJzZXJJbnB1dC4kY2hhcignKCcpKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvID0gdGhpcy5pbXBvcnRPcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbk5hbWUgPSBvO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKG9wdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY3NzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbk5hbWUgPSBcImxlc3NcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm9uY2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uTmFtZSA9IFwibXVsdGlwbGVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW29wdGlvbk5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISBwYXJzZXJJbnB1dC4kY2hhcignLCcpKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChvKTtcbiAgICAgICAgICAgICAgICBleHBlY3RDaGFyKCcpJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpbXBvcnRPcHRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHQgPSBwYXJzZXJJbnB1dC4kcmUoL14obGVzc3xjc3N8bXVsdGlwbGV8b25jZXxpbmxpbmV8cmVmZXJlbmNlfG9wdGlvbmFsKS8pO1xuICAgICAgICAgICAgICAgIGlmIChvcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdFsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBtZWRpYUZlYXR1cmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50aXRpZXMgPSB0aGlzLmVudGl0aWVzLCBub2RlcyA9IFtdLCBlLCBwO1xuICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBlbnRpdGllcy5rZXl3b3JkKCkgfHwgZW50aXRpZXMudmFyaWFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VySW5wdXQuJGNoYXIoJygnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMucHJvcGVydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJyknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwICYmIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXcodHJlZS5QYXJlbikobmV3KHRyZWUuUnVsZSkocCwgZSwgbnVsbCwgbnVsbCwgcGFyc2VySW5wdXQuaSwgZmlsZUluZm8sIHRydWUpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3KHRyZWUuUGFyZW4pKGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihcImJhZGx5IGZvcm1lZCBtZWRpYSBmZWF0dXJlIGRlZmluaXRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihcIk1pc3NpbmcgY2xvc2luZyAnKSdcIiwgXCJQYXJzZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGUpO1xuXG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLkV4cHJlc3Npb24pKG5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBtZWRpYUZlYXR1cmVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudGl0aWVzID0gdGhpcy5lbnRpdGllcywgZmVhdHVyZXMgPSBbXSwgZTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLm1lZGlhRmVhdHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIHBhcnNlcklucHV0LiRjaGFyKCcsJykpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBlbnRpdGllcy52YXJpYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIHBhcnNlcklucHV0LiRjaGFyKCcsJykpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGUpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmVzLmxlbmd0aCA+IDAgPyBmZWF0dXJlcyA6IG51bGw7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBtZWRpYTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlcywgcnVsZXMsIG1lZGlhLCBkZWJ1Z0luZm8sIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcblxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmR1bXBMaW5lTnVtYmVycykge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0luZm8gPSBnZXREZWJ1Z0luZm8oaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kc3RyKFwiQG1lZGlhXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzID0gdGhpcy5tZWRpYUZlYXR1cmVzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcnVsZXMgPSB0aGlzLmJsb2NrKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFydWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJtZWRpYSBkZWZpbml0aW9ucyByZXF1aXJlIGJsb2NrIHN0YXRlbWVudHMgYWZ0ZXIgYW55IGZlYXR1cmVzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWVkaWEgPSBuZXcodHJlZS5NZWRpYSkocnVsZXMsIGZlYXR1cmVzLCBpbmRleCwgZmlsZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5kdW1wTGluZU51bWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhLmRlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZWRpYTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQSBAcGx1Z2luIGRpcmVjdGl2ZSwgdXNlZCB0byBpbXBvcnQgY29tcGlsZXIgZXh0ZW5zaW9ucyBkeW5hbWljYWxseS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgQHBsdWdpbiBcImxpYlwiO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiBvdXIgZW52aXJvbm1lbnQsIGltcG9ydGluZyBpcyBkb25lIGRpZmZlcmVudGx5OlxuICAgICAgICAgICAgLy8gSW4gdGhlIGJyb3dzZXIsIGl0J3MgYW4gWEhSIHJlcXVlc3QsIGluIE5vZGUsIGl0IHdvdWxkIGJlIGFcbiAgICAgICAgICAgIC8vIGZpbGUtc3lzdGVtIG9wZXJhdGlvbi4gVGhlIGZ1bmN0aW9uIHVzZWQgZm9yIGltcG9ydGluZyBpc1xuICAgICAgICAgICAgLy8gc3RvcmVkIGluIGBpbXBvcnRgLCB3aGljaCB3ZSBwYXNzIHRvIHRoZSBJbXBvcnQgY29uc3RydWN0b3IuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgcGx1Z2luOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcGFyc2VySW5wdXQuaSxcbiAgICAgICAgICAgICAgICAgICAgZGlyICAgPSBwYXJzZXJJbnB1dC4kcmUoL15AcGx1Z2luP1xccysvKTtcblxuICAgICAgICAgICAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7IHBsdWdpbiA6IHRydWUgfTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoKHBhdGggPSB0aGlzLmVudGl0aWVzLnF1b3RlZCgpIHx8IHRoaXMuZW50aXRpZXMudXJsKCkpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJzsnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmkgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihcIm1pc3Npbmcgc2VtaS1jb2xvbiBvbiBwbHVnaW5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5JbXBvcnQpKHBhdGgsIG51bGwsIG9wdGlvbnMsIGluZGV4LCBmaWxlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5pID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihcIm1hbGZvcm1lZCBwbHVnaW4gc3RhdGVtZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEEgQ1NTIERpcmVjdGl2ZVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICBAY2hhcnNldCBcInV0Zi04XCI7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZGlyZWN0aXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VySW5wdXQuaSwgbmFtZSwgdmFsdWUsIHJ1bGVzLCBub25WZW5kb3JTcGVjaWZpY05hbWUsXG4gICAgICAgICAgICAgICAgICAgIGhhc0lkZW50aWZpZXIsIGhhc0V4cHJlc3Npb24sIGhhc1Vua25vd24sIGhhc0Jsb2NrID0gdHJ1ZSwgaXNSb290ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgIT09ICdAJykgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpc1snaW1wb3J0J10oKSB8fCB0aGlzLnBsdWdpbigpIHx8IHRoaXMubWVkaWEoKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgIG5hbWUgPSBwYXJzZXJJbnB1dC4kcmUoL15AW2Etei1dKy8pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFuYW1lKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICAgICAgbm9uVmVuZG9yU3BlY2lmaWNOYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMSkgPT0gJy0nICYmIG5hbWUuaW5kZXhPZignLScsIDIpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBub25WZW5kb3JTcGVjaWZpY05hbWUgPSBcIkBcIiArIG5hbWUuc2xpY2UobmFtZS5pbmRleE9mKCctJywgMikgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2gobm9uVmVuZG9yU3BlY2lmaWNOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJAY2hhcnNldFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzSWRlbnRpZmllciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNCbG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJAbmFtZXNwYWNlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNFeHByZXNzaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkBrZXlmcmFtZXNcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkBjb3VudGVyLXN0eWxlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNJZGVudGlmaWVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQGRvY3VtZW50XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJAc3VwcG9ydHNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1Vua25vd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNSb290ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzVW5rbm93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgICAgIGlmIChoYXNJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5lbnRpdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJleHBlY3RlZCBcIiArIG5hbWUgKyBcIiBpZGVudGlmaWVyXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5leHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwiZXhwZWN0ZWQgXCIgKyBuYW1lICsgXCIgZXhwcmVzc2lvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzVW5rbm93bikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IChwYXJzZXJJbnB1dC4kcmUoL15bXns7XSsvKSB8fCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBoYXNCbG9jayA9IChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpID09ICd7Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcodHJlZS5Bbm9ueW1vdXMpKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChoYXNCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICBydWxlcyA9IHRoaXMuYmxvY2tSdWxlc2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGVzIHx8ICghaGFzQmxvY2sgJiYgdmFsdWUgJiYgcGFyc2VySW5wdXQuJGNoYXIoJzsnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuRGlyZWN0aXZlKShuYW1lLCB2YWx1ZSwgcnVsZXMsIGluZGV4LCBmaWxlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZHVtcExpbmVOdW1iZXJzID8gZ2V0RGVidWdJbmZvKGluZGV4KSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1Jvb3RlZFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoXCJkaXJlY3RpdmUgb3B0aW9ucyBub3QgcmVjb2duaXNlZFwiKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBIFZhbHVlIGlzIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgRXhwcmVzc2lvbnNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgZm9udC1mYW1pbHk6IEJhc2tlcnZpbGxlLCBHZW9yZ2lhLCBzZXJpZjtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJbiBhIFJ1bGUsIGEgVmFsdWUgcmVwcmVzZW50cyBldmVyeXRoaW5nIGFmdGVyIHRoZSBgOmAsXG4gICAgICAgICAgICAvLyBhbmQgYmVmb3JlIHRoZSBgO2AuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSwgZXhwcmVzc2lvbnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuZXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIHBhcnNlcklucHV0LiRjaGFyKCcsJykpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh0cmVlLlZhbHVlKShleHByZXNzaW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGltcG9ydGFudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpID09PSAnIScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcklucHV0LiRyZSgvXiEgKmltcG9ydGFudC8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSwgZTtcblxuICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJygnKSkge1xuICAgICAgICAgICAgICAgICAgICBhID0gdGhpcy5hZGRpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYSAmJiBwYXJzZXJJbnB1dC4kY2hhcignKScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBuZXcodHJlZS5FeHByZXNzaW9uKShbYV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wYXJlbnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZShcIkV4cGVjdGVkICcpJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXVsdGlwbGljYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbSwgYSwgb3AsIG9wZXJhdGlvbiwgaXNTcGFjZWQ7XG4gICAgICAgICAgICAgICAgbSA9IHRoaXMub3BlcmFuZCgpO1xuICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzU3BhY2VkID0gcGFyc2VySW5wdXQuaXNXaGl0ZXNwYWNlKC0xKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5wZWVrKC9eXFwvWypcXC9dLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBvcCA9IHBhcnNlcklucHV0LiRjaGFyKCcvJykgfHwgcGFyc2VySW5wdXQuJGNoYXIoJyonKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcCkgeyBwYXJzZXJJbnB1dC5mb3JnZXQoKTsgYnJlYWs7IH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHRoaXMub3BlcmFuZCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWEpIHsgcGFyc2VySW5wdXQucmVzdG9yZSgpOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG0ucGFyZW5zSW5PcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnBhcmVuc0luT3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gbmV3KHRyZWUuT3BlcmF0aW9uKShvcCwgW29wZXJhdGlvbiB8fCBtLCBhXSwgaXNTcGFjZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTcGFjZWQgPSBwYXJzZXJJbnB1dC5pc1doaXRlc3BhY2UoLTEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24gfHwgbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbSwgYSwgb3AsIG9wZXJhdGlvbiwgaXNTcGFjZWQ7XG4gICAgICAgICAgICAgICAgbSA9IHRoaXMubXVsdGlwbGljYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICBpc1NwYWNlZCA9IHBhcnNlcklucHV0LmlzV2hpdGVzcGFjZSgtMSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcCA9IHBhcnNlcklucHV0LiRyZSgvXlstK11cXHMrLykgfHwgKCFpc1NwYWNlZCAmJiAocGFyc2VySW5wdXQuJGNoYXIoJysnKSB8fCBwYXJzZXJJbnB1dC4kY2hhcignLScpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gdGhpcy5tdWx0aXBsaWNhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG0ucGFyZW5zSW5PcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnBhcmVuc0luT3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gbmV3KHRyZWUuT3BlcmF0aW9uKShvcCwgW29wZXJhdGlvbiB8fCBtLCBhXSwgaXNTcGFjZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTcGFjZWQgPSBwYXJzZXJJbnB1dC5pc1doaXRlc3BhY2UoLTEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24gfHwgbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZGl0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhLCBiLCBpbmRleCA9IHBhcnNlcklucHV0LmksIGNvbmRpdGlvbjtcblxuICAgICAgICAgICAgICAgIGEgPSB0aGlzLmNvbmRpdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LnBlZWsoL14sXFxzKihub3RcXHMqKT9cXCgvKSB8fCAhcGFyc2VySW5wdXQuJGNoYXIoJywnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHRoaXMuY29uZGl0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbiA9IG5ldyh0cmVlLkNvbmRpdGlvbikoJ29yJywgY29uZGl0aW9uIHx8IGEsIGIsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZGl0aW9uIHx8IGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmRpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQsIGxvZ2ljYWwsIG5leHQ7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXJJbnB1dC4kc3RyKFwib3JcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jb25kaXRpb25BbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9naWNhbCA9IG9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2ljYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHRoaXMuY29uZGl0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcodHJlZS5Db25kaXRpb24pKGxvZ2ljYWwsIHJlc3VsdCwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZGl0aW9uQW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCwgbG9naWNhbCwgbmV4dDtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpbnNpZGVDb25kaXRpb24obWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lLm5lZ2F0ZWRDb25kaXRpb24oKSB8fCBtZS5wYXJlbnRoZXNpc0NvbmRpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhbmQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXJJbnB1dC4kc3RyKFwiYW5kXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGluc2lkZUNvbmRpdGlvbih0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2dpY2FsID0gYW5kKCk7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2ljYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHRoaXMuY29uZGl0aW9uQW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcodHJlZS5Db25kaXRpb24pKGxvZ2ljYWwsIHJlc3VsdCwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmVnYXRlZENvbmRpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kc3RyKFwibm90XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcmVudGhlc2lzQ29uZGl0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5uZWdhdGUgPSAhcmVzdWx0Lm5lZ2F0ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJlbnRoZXNpc0NvbmRpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRyeUNvbmRpdGlvbkZvbGxvd2VkQnlQYXJlbnRoZXNpcyhtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gbWUuY29uZGl0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBib2R5O1xuICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRzdHIoXCIoXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYm9keSA9IHRyeUNvbmRpdGlvbkZvbGxvd2VkQnlQYXJlbnRoZXNpcyh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuYXRvbWljQ29uZGl0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignKScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoXCJleHBlY3RlZCAnKScgZ290ICdcIiArIHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF0b21pY0NvbmRpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRpdGllcyA9IHRoaXMuZW50aXRpZXMsIGluZGV4ID0gcGFyc2VySW5wdXQuaSwgYSwgYiwgYywgb3A7XG5cbiAgICAgICAgICAgICAgICBhID0gdGhpcy5hZGRpdGlvbigpIHx8IGVudGl0aWVzLmtleXdvcmQoKSB8fCBlbnRpdGllcy5xdW90ZWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJz4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcCA9IFwiPj1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSAnPic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJzwnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcCA9IFwiPD1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSAnPCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJz0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCc+JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcCA9IFwiPT5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VySW5wdXQuJGNoYXIoJzwnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gJz08JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSAnPSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gdGhpcy5hZGRpdGlvbigpIHx8IGVudGl0aWVzLmtleXdvcmQoKSB8fCBlbnRpdGllcy5xdW90ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IG5ldyh0cmVlLkNvbmRpdGlvbikob3AsIGEsIGIsIGluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdleHBlY3RlZCBleHByZXNzaW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gbmV3KHRyZWUuQ29uZGl0aW9uKSgnPScsIGEsIG5ldyh0cmVlLktleXdvcmQpKCd0cnVlJyksIGluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEFuIG9wZXJhbmQgaXMgYW55dGhpbmcgdGhhdCBjYW4gYmUgcGFydCBvZiBhbiBvcGVyYXRpb24sXG4gICAgICAgICAgICAvLyBzdWNoIGFzIGEgQ29sb3IsIG9yIGEgVmFyaWFibGVcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBvcGVyYW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudGl0aWVzID0gdGhpcy5lbnRpdGllcywgbmVnYXRlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LnBlZWsoL14tW0BcXChdLykpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVnYXRlID0gcGFyc2VySW5wdXQuJGNoYXIoJy0nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbyA9IHRoaXMuc3ViKCkgfHwgZW50aXRpZXMuZGltZW5zaW9uKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLmNvbG9yKCkgfHwgZW50aXRpZXMudmFyaWFibGUoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZW50aXRpZXMuY2FsbCgpIHx8IGVudGl0aWVzLmNvbG9yS2V5d29yZCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5lZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICBvLnBhcmVuc0luT3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvID0gbmV3KHRyZWUuTmVnYXRpdmUpKG8pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEV4cHJlc3Npb25zIGVpdGhlciByZXByZXNlbnQgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbnMsXG4gICAgICAgICAgICAvLyBvciB3aGl0ZS1zcGFjZSBkZWxpbWl0ZWQgRW50aXRpZXMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgIDFweCBzb2xpZCBibGFja1xuICAgICAgICAgICAgLy8gICAgIEB2YXIgKiAyXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRpdGllcyA9IFtdLCBlLCBkZWxpbTtcblxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuY29tbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW50aXRpZXMucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLmFkZGl0aW9uKCkgfHwgdGhpcy5lbnRpdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvcGVyYXRpb25zIGRvIG5vdCBhbGxvdyBrZXl3b3JkIFwiL1wiIGRpbWVuc2lvbiAoZS5nLiBzbWFsbC8yMHB4KSBzbyB3ZSBzdXBwb3J0IHRoYXQgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC5wZWVrKC9eXFwvW1xcLypdLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxpbSA9IHBhcnNlcklucHV0LiRjaGFyKCcvJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGltKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLnB1c2gobmV3KHRyZWUuQW5vbnltb3VzKShkZWxpbSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGUpO1xuICAgICAgICAgICAgICAgIGlmIChlbnRpdGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcodHJlZS5FeHByZXNzaW9uKShlbnRpdGllcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3BlcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBwYXJzZXJJbnB1dC4kcmUoL14oXFwqPy0/W19hLXpBLVowLTktXSspXFxzKjovKTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVsZVByb3BlcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBbXSwgaW5kZXggPSBbXSwgcywgaztcblxuICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgIHZhciBzaW1wbGVQcm9wZXJ0eSA9IHBhcnNlcklucHV0LiRyZSgvXihbX2EtekEtWjAtOS1dKylcXHMqOi8pO1xuICAgICAgICAgICAgICAgIGlmIChzaW1wbGVQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gW25ldyh0cmVlLktleXdvcmQpKHNpbXBsZVByb3BlcnR5WzFdKV07XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBtYXRjaChyZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHBhcnNlcklucHV0LmksXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVuayA9IHBhcnNlcklucHV0LiRyZShyZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lLnB1c2goY2h1bmtbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWF0Y2goL14oXFwqPykvKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKC9eKCg/OltcXHctXSspfCg/OkBcXHtbXFx3LV0rXFx9KSkvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoKG5hbWUubGVuZ3RoID4gMSkgJiYgbWF0Y2goL14oKD86XFwrX3xcXCspPylcXHMqOi8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGF0IGxhc3QsIHdlIGhhdmUgdGhlIGNvbXBsZXRlIG1hdGNoIG5vdy4gbW92ZSBmb3J3YXJkLFxuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IG5hbWUgcGFydGljbGVzIHRvIHRyZWUgb2JqZWN0cyBhbmQgcmV0dXJuOlxuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZVswXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG5hbWUubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBuYW1lW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZVtrXSA9IChzLmNoYXJBdCgwKSAhPT0gJ0AnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3KHRyZWUuS2V5d29yZCkocykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyh0cmVlLlZhcmlhYmxlKSgnQCcgKyBzLnNsaWNlKDIsIC0xKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhba10sIGZpbGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG5QYXJzZXIuc2VyaWFsaXplVmFycyA9IGZ1bmN0aW9uKHZhcnMpIHtcbiAgICB2YXIgcyA9ICcnO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiB2YXJzKSB7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh2YXJzLCBuYW1lKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFyc1tuYW1lXTtcbiAgICAgICAgICAgIHMgKz0gKChuYW1lWzBdID09PSAnQCcpID8gJycgOiAnQCcpICsgbmFtZSArICc6ICcgKyB2YWx1ZSArXG4gICAgICAgICAgICAgICAgKChTdHJpbmcodmFsdWUpLnNsaWNlKC0xKSA9PT0gJzsnKSA/ICcnIDogJzsnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXI7XG5cbn0se1wiLi4vbGVzcy1lcnJvclwiOjMyLFwiLi4vdHJlZVwiOjYyLFwiLi4vdXRpbHNcIjo4MyxcIi4uL3Zpc2l0b3JzXCI6ODcsXCIuL3BhcnNlci1pbnB1dFwiOjM3fV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBQbHVnaW4gTWFuYWdlclxuICovXG52YXIgUGx1Z2luTWFuYWdlciA9IGZ1bmN0aW9uKGxlc3MpIHtcbiAgICB0aGlzLmxlc3MgPSBsZXNzO1xuICAgIHRoaXMudmlzaXRvcnMgPSBbXTtcbiAgICB0aGlzLnByZVByb2Nlc3NvcnMgPSBbXTtcbiAgICB0aGlzLnBvc3RQcm9jZXNzb3JzID0gW107XG4gICAgdGhpcy5pbnN0YWxsZWRQbHVnaW5zID0gW107XG4gICAgdGhpcy5maWxlTWFuYWdlcnMgPSBbXTtcbn07XG4vKipcbiAqIEFkZHMgYWxsIHRoZSBwbHVnaW5zIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gcGx1Z2luc1xuICovXG5QbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5hZGRQbHVnaW5zID0gZnVuY3Rpb24ocGx1Z2lucykge1xuICAgIGlmIChwbHVnaW5zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hZGRQbHVnaW4ocGx1Z2luc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKlxuICogQHBhcmFtIHBsdWdpblxuICovXG5QbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5hZGRQbHVnaW4gPSBmdW5jdGlvbihwbHVnaW4pIHtcbiAgICB0aGlzLmluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHBsdWdpbi5pbnN0YWxsKHRoaXMubGVzcywgdGhpcyk7XG59O1xuLyoqXG4gKiBBZGRzIGEgdmlzaXRvci4gVGhlIHZpc2l0b3Igb2JqZWN0IGhhcyBvcHRpb25zIG9uIGl0c2VsZiB0byBkZXRlcm1pbmVcbiAqIHdoZW4gaXQgc2hvdWxkIHJ1bi5cbiAqIEBwYXJhbSB2aXNpdG9yXG4gKi9cblBsdWdpbk1hbmFnZXIucHJvdG90eXBlLmFkZFZpc2l0b3IgPSBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgdGhpcy52aXNpdG9ycy5wdXNoKHZpc2l0b3IpO1xufTtcbi8qKlxuICogQWRkcyBhIHByZSBwcm9jZXNzb3Igb2JqZWN0XG4gKiBAcGFyYW0ge29iamVjdH0gcHJlUHJvY2Vzc29yXG4gKiBAcGFyYW0ge251bWJlcn0gcHJpb3JpdHkgLSBndWlkZWxpbmVzIDEgPSBiZWZvcmUgaW1wb3J0LCAxMDAwID0gaW1wb3J0LCAyMDAwID0gYWZ0ZXIgaW1wb3J0XG4gKi9cblBsdWdpbk1hbmFnZXIucHJvdG90eXBlLmFkZFByZVByb2Nlc3NvciA9IGZ1bmN0aW9uKHByZVByb2Nlc3NvciwgcHJpb3JpdHkpIHtcbiAgICB2YXIgaW5kZXhUb0luc2VydEF0O1xuICAgIGZvciAoaW5kZXhUb0luc2VydEF0ID0gMDsgaW5kZXhUb0luc2VydEF0IDwgdGhpcy5wcmVQcm9jZXNzb3JzLmxlbmd0aDsgaW5kZXhUb0luc2VydEF0KyspIHtcbiAgICAgICAgaWYgKHRoaXMucHJlUHJvY2Vzc29yc1tpbmRleFRvSW5zZXJ0QXRdLnByaW9yaXR5ID49IHByaW9yaXR5KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnByZVByb2Nlc3NvcnMuc3BsaWNlKGluZGV4VG9JbnNlcnRBdCwgMCwge3ByZVByb2Nlc3NvcjogcHJlUHJvY2Vzc29yLCBwcmlvcml0eTogcHJpb3JpdHl9KTtcbn07XG4vKipcbiAqIEFkZHMgYSBwb3N0IHByb2Nlc3NvciBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBwb3N0UHJvY2Vzc29yXG4gKiBAcGFyYW0ge251bWJlcn0gcHJpb3JpdHkgLSBndWlkZWxpbmVzIDEgPSBiZWZvcmUgY29tcHJlc3Npb24sIDEwMDAgPSBjb21wcmVzc2lvbiwgMjAwMCA9IGFmdGVyIGNvbXByZXNzaW9uXG4gKi9cblBsdWdpbk1hbmFnZXIucHJvdG90eXBlLmFkZFBvc3RQcm9jZXNzb3IgPSBmdW5jdGlvbihwb3N0UHJvY2Vzc29yLCBwcmlvcml0eSkge1xuICAgIHZhciBpbmRleFRvSW5zZXJ0QXQ7XG4gICAgZm9yIChpbmRleFRvSW5zZXJ0QXQgPSAwOyBpbmRleFRvSW5zZXJ0QXQgPCB0aGlzLnBvc3RQcm9jZXNzb3JzLmxlbmd0aDsgaW5kZXhUb0luc2VydEF0KyspIHtcbiAgICAgICAgaWYgKHRoaXMucG9zdFByb2Nlc3NvcnNbaW5kZXhUb0luc2VydEF0XS5wcmlvcml0eSA+PSBwcmlvcml0eSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wb3N0UHJvY2Vzc29ycy5zcGxpY2UoaW5kZXhUb0luc2VydEF0LCAwLCB7cG9zdFByb2Nlc3NvcjogcG9zdFByb2Nlc3NvciwgcHJpb3JpdHk6IHByaW9yaXR5fSk7XG59O1xuLyoqXG4gKlxuICogQHBhcmFtIG1hbmFnZXJcbiAqL1xuUGx1Z2luTWFuYWdlci5wcm90b3R5cGUuYWRkRmlsZU1hbmFnZXIgPSBmdW5jdGlvbihtYW5hZ2VyKSB7XG4gICAgdGhpcy5maWxlTWFuYWdlcnMucHVzaChtYW5hZ2VyKTtcbn07XG4vKipcbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5QbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5nZXRQcmVQcm9jZXNzb3JzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHByZVByb2Nlc3NvcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHJlUHJvY2Vzc29ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmVQcm9jZXNzb3JzLnB1c2godGhpcy5wcmVQcm9jZXNzb3JzW2ldLnByZVByb2Nlc3Nvcik7XG4gICAgfVxuICAgIHJldHVybiBwcmVQcm9jZXNzb3JzO1xufTtcbi8qKlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cblBsdWdpbk1hbmFnZXIucHJvdG90eXBlLmdldFBvc3RQcm9jZXNzb3JzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBvc3RQcm9jZXNzb3JzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvc3RQcm9jZXNzb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBvc3RQcm9jZXNzb3JzLnB1c2godGhpcy5wb3N0UHJvY2Vzc29yc1tpXS5wb3N0UHJvY2Vzc29yKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc3RQcm9jZXNzb3JzO1xufTtcbi8qKlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cblBsdWdpbk1hbmFnZXIucHJvdG90eXBlLmdldFZpc2l0b3JzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudmlzaXRvcnM7XG59O1xuLyoqXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuUGx1Z2luTWFuYWdlci5wcm90b3R5cGUuZ2V0RmlsZU1hbmFnZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZU1hbmFnZXJzO1xufTtcbm1vZHVsZS5leHBvcnRzID0gUGx1Z2luTWFuYWdlcjtcblxufSx7fV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIExlc3NFcnJvciA9IHJlcXVpcmUoJy4uL2xlc3MtZXJyb3InKSxcbiAgICB0cmVlID0gcmVxdWlyZShcIi4uL3RyZWVcIik7XG5cbnZhciBGdW5jdGlvbkltcG9ydGVyID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBGdW5jdGlvbkltcG9ydGVyKGNvbnRleHQsIGZpbGVJbmZvKSB7XG4gICAgdGhpcy5maWxlSW5mbyA9IGZpbGVJbmZvO1xufTtcblxuRnVuY3Rpb25JbXBvcnRlci5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKGNvbnRlbnRzLCBjYWxsYmFjaykge1xuICAgIHZhciBsb2FkZWQgPSB7fSxcbiAgICAgICAgbG9hZGVyLFxuICAgICAgICByZWdpc3RyeTtcblxuICAgIHJlZ2lzdHJ5ID0ge1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgICAgIGxvYWRlZFtuYW1lXSA9IGZ1bmM7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZE11bHRpcGxlOiBmdW5jdGlvbihmdW5jdGlvbnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGZ1bmN0aW9ucykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgbG9hZGVkW25hbWVdID0gZnVuY3Rpb25zW25hbWVdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgICAgbG9hZGVyID0gbmV3IEZ1bmN0aW9uKFwiZnVuY3Rpb25zXCIsIFwidHJlZVwiLCBcImZpbGVJbmZvXCIsIGNvbnRlbnRzKTtcbiAgICAgICAgbG9hZGVyKHJlZ2lzdHJ5LCB0cmVlLCB0aGlzLmZpbGVJbmZvKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgY2FsbGJhY2sobmV3IExlc3NFcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIlBsdWdpbiBldmFsdWF0aW9uIGVycm9yOiAnXCIgKyBlLm5hbWUgKyAnOiAnICsgZS5tZXNzYWdlLnJlcGxhY2UoL1tcIl0vZywgXCInXCIpICsgXCInXCIgLFxuICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZUluZm8uZmlsZW5hbWVcbiAgICAgICAgfSksIG51bGwgKTtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCB7IGZ1bmN0aW9uczogbG9hZGVkIH0pO1xufTtcblxufSx7XCIuLi9sZXNzLWVycm9yXCI6MzIsXCIuLi90cmVlXCI6NjJ9XSw0MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgUHJvbWlzZUNvbnN0cnVjdG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVudmlyb25tZW50LCBQYXJzZVRyZWUsIEltcG9ydE1hbmFnZXIpIHtcbiAgICB2YXIgcmVuZGVyID0gZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICghUHJvbWlzZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgUHJvbWlzZUNvbnN0cnVjdG9yID0gdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gcmVxdWlyZSgncHJvbWlzZScpIDogUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUNvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICByZW5kZXIuY2FsbChzZWxmLCBpbnB1dCwgb3B0aW9ucywgZnVuY3Rpb24oZXJyLCBvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXJzZShpbnB1dCwgb3B0aW9ucywgZnVuY3Rpb24oZXJyLCByb290LCBpbXBvcnRzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKTsgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VUcmVlID0gbmV3IFBhcnNlVHJlZShyb290LCBpbXBvcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VUcmVlLnRvQ1NTKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9XG5cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlbmRlcjtcbn07XG5cbn0se1wicHJvbWlzZVwiOnVuZGVmaW5lZH1dLDQyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNvdXJjZU1hcE91dHB1dCwgZW52aXJvbm1lbnQpIHtcblxuICAgIHZhciBTb3VyY2VNYXBCdWlsZGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9O1xuXG4gICAgU291cmNlTWFwQnVpbGRlci5wcm90b3R5cGUudG9DU1MgPSBmdW5jdGlvbihyb290Tm9kZSwgb3B0aW9ucywgaW1wb3J0cykge1xuICAgICAgICB2YXIgc291cmNlTWFwT3V0cHV0ID0gbmV3IFNvdXJjZU1hcE91dHB1dChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZW50c0lnbm9yZWRDaGFyc01hcDogaW1wb3J0cy5jb250ZW50c0lnbm9yZWRDaGFycyxcbiAgICAgICAgICAgICAgICByb290Tm9kZTogcm9vdE5vZGUsXG4gICAgICAgICAgICAgICAgY29udGVudHNNYXA6IGltcG9ydHMuY29udGVudHMsXG4gICAgICAgICAgICAgICAgc291cmNlTWFwRmlsZW5hbWU6IHRoaXMub3B0aW9ucy5zb3VyY2VNYXBGaWxlbmFtZSxcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXBVUkw6IHRoaXMub3B0aW9ucy5zb3VyY2VNYXBVUkwsXG4gICAgICAgICAgICAgICAgb3V0cHV0RmlsZW5hbWU6IHRoaXMub3B0aW9ucy5zb3VyY2VNYXBPdXRwdXRGaWxlbmFtZSxcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXBCYXNlcGF0aDogdGhpcy5vcHRpb25zLnNvdXJjZU1hcEJhc2VwYXRoLFxuICAgICAgICAgICAgICAgIHNvdXJjZU1hcFJvb3RwYXRoOiB0aGlzLm9wdGlvbnMuc291cmNlTWFwUm9vdHBhdGgsXG4gICAgICAgICAgICAgICAgb3V0cHV0U291cmNlRmlsZXM6IHRoaXMub3B0aW9ucy5vdXRwdXRTb3VyY2VGaWxlcyxcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXBHZW5lcmF0b3I6IHRoaXMub3B0aW9ucy5zb3VyY2VNYXBHZW5lcmF0b3IsXG4gICAgICAgICAgICAgICAgc291cmNlTWFwRmlsZUlubGluZTogdGhpcy5vcHRpb25zLnNvdXJjZU1hcEZpbGVJbmxpbmVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBjc3MgPSBzb3VyY2VNYXBPdXRwdXQudG9DU1Mob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc291cmNlTWFwID0gc291cmNlTWFwT3V0cHV0LnNvdXJjZU1hcDtcbiAgICAgICAgdGhpcy5zb3VyY2VNYXBVUkwgPSBzb3VyY2VNYXBPdXRwdXQuc291cmNlTWFwVVJMO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNvdXJjZU1hcElucHV0RmlsZW5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlTWFwSW5wdXRGaWxlbmFtZSA9IHNvdXJjZU1hcE91dHB1dC5ub3JtYWxpemVGaWxlbmFtZSh0aGlzLm9wdGlvbnMuc291cmNlTWFwSW5wdXRGaWxlbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNzcyArIHRoaXMuZ2V0Q1NTQXBwZW5kYWdlKCk7XG4gICAgfTtcblxuICAgIFNvdXJjZU1hcEJ1aWxkZXIucHJvdG90eXBlLmdldENTU0FwcGVuZGFnZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzb3VyY2VNYXBVUkwgPSB0aGlzLnNvdXJjZU1hcFVSTDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zb3VyY2VNYXBGaWxlSW5saW5lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VNYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlTWFwVVJMID0gXCJkYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgZW52aXJvbm1lbnQuZW5jb2RlQmFzZTY0KHRoaXMuc291cmNlTWFwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzb3VyY2VNYXBVUkwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VNYXBwaW5nVVJMPVwiICsgc291cmNlTWFwVVJMICsgXCIgKi9cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9O1xuXG4gICAgU291cmNlTWFwQnVpbGRlci5wcm90b3R5cGUuZ2V0RXh0ZXJuYWxTb3VyY2VNYXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlTWFwO1xuICAgIH07XG4gICAgU291cmNlTWFwQnVpbGRlci5wcm90b3R5cGUuc2V0RXh0ZXJuYWxTb3VyY2VNYXAgPSBmdW5jdGlvbihzb3VyY2VNYXApIHtcbiAgICAgICAgdGhpcy5zb3VyY2VNYXAgPSBzb3VyY2VNYXA7XG4gICAgfTtcblxuICAgIFNvdXJjZU1hcEJ1aWxkZXIucHJvdG90eXBlLmlzSW5saW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc291cmNlTWFwRmlsZUlubGluZTtcbiAgICB9O1xuICAgIFNvdXJjZU1hcEJ1aWxkZXIucHJvdG90eXBlLmdldFNvdXJjZU1hcFVSTCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VNYXBVUkw7XG4gICAgfTtcbiAgICBTb3VyY2VNYXBCdWlsZGVyLnByb3RvdHlwZS5nZXRPdXRwdXRGaWxlbmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNvdXJjZU1hcE91dHB1dEZpbGVuYW1lO1xuICAgIH07XG4gICAgU291cmNlTWFwQnVpbGRlci5wcm90b3R5cGUuZ2V0SW5wdXRGaWxlbmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VNYXBJbnB1dEZpbGVuYW1lO1xuICAgIH07XG5cbiAgICByZXR1cm4gU291cmNlTWFwQnVpbGRlcjtcbn07XG5cbn0se31dLDQzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVudmlyb25tZW50KSB7XG5cbiAgICB2YXIgU291cmNlTWFwT3V0cHV0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fY3NzID0gW107XG4gICAgICAgIHRoaXMuX3Jvb3ROb2RlID0gb3B0aW9ucy5yb290Tm9kZTtcbiAgICAgICAgdGhpcy5fY29udGVudHNNYXAgPSBvcHRpb25zLmNvbnRlbnRzTWFwO1xuICAgICAgICB0aGlzLl9jb250ZW50c0lnbm9yZWRDaGFyc01hcCA9IG9wdGlvbnMuY29udGVudHNJZ25vcmVkQ2hhcnNNYXA7XG4gICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcEZpbGVuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBGaWxlbmFtZSA9IG9wdGlvbnMuc291cmNlTWFwRmlsZW5hbWUucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX291dHB1dEZpbGVuYW1lID0gb3B0aW9ucy5vdXRwdXRGaWxlbmFtZTtcbiAgICAgICAgdGhpcy5zb3VyY2VNYXBVUkwgPSBvcHRpb25zLnNvdXJjZU1hcFVSTDtcbiAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlTWFwQmFzZXBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZU1hcEJhc2VwYXRoID0gb3B0aW9ucy5zb3VyY2VNYXBCYXNlcGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlTWFwUm9vdHBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZU1hcFJvb3RwYXRoID0gb3B0aW9ucy5zb3VyY2VNYXBSb290cGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fc291cmNlTWFwUm9vdHBhdGguY2hhckF0KHRoaXMuX3NvdXJjZU1hcFJvb3RwYXRoLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBSb290cGF0aCArPSAnLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBSb290cGF0aCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3V0cHV0U291cmNlRmlsZXMgPSBvcHRpb25zLm91dHB1dFNvdXJjZUZpbGVzO1xuICAgICAgICB0aGlzLl9zb3VyY2VNYXBHZW5lcmF0b3JDb25zdHJ1Y3RvciA9IGVudmlyb25tZW50LmdldFNvdXJjZU1hcEdlbmVyYXRvcigpO1xuXG4gICAgICAgIHRoaXMuX2xpbmVOdW1iZXIgPSAwO1xuICAgICAgICB0aGlzLl9jb2x1bW4gPSAwO1xuICAgIH07XG5cbiAgICBTb3VyY2VNYXBPdXRwdXQucHJvdG90eXBlLm5vcm1hbGl6ZUZpbGVuYW1lID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3NvdXJjZU1hcEJhc2VwYXRoICYmIGZpbGVuYW1lLmluZGV4T2YodGhpcy5fc291cmNlTWFwQmFzZXBhdGgpID09PSAwKSB7XG4gICAgICAgICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnN1YnN0cmluZyh0aGlzLl9zb3VyY2VNYXBCYXNlcGF0aC5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGZpbGVuYW1lLmNoYXJBdCgwKSA9PT0gJ1xcXFwnIHx8IGZpbGVuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLl9zb3VyY2VNYXBSb290cGF0aCB8fCBcIlwiKSArIGZpbGVuYW1lO1xuICAgIH07XG5cbiAgICBTb3VyY2VNYXBPdXRwdXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGNodW5rLCBmaWxlSW5mbywgaW5kZXgsIG1hcExpbmVzKSB7XG5cbiAgICAgICAgLy9pZ25vcmUgYWRkaW5nIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgaWYgKCFjaHVuaykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpbmVzLFxuICAgICAgICAgICAgc291cmNlTGluZXMsXG4gICAgICAgICAgICBjb2x1bW5zLFxuICAgICAgICAgICAgc291cmNlQ29sdW1ucyxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgaWYgKGZpbGVJbmZvKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTb3VyY2UgPSB0aGlzLl9jb250ZW50c01hcFtmaWxlSW5mby5maWxlbmFtZV07XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB2YXJzL2Jhbm5lciBhZGRlZCB0byB0aGUgdG9wIG9mIHRoZSBmaWxlXG4gICAgICAgICAgICBpZiAodGhpcy5fY29udGVudHNJZ25vcmVkQ2hhcnNNYXBbZmlsZUluZm8uZmlsZW5hbWVdKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRqdXN0IHRoZSBpbmRleFxuICAgICAgICAgICAgICAgIGluZGV4IC09IHRoaXMuX2NvbnRlbnRzSWdub3JlZENoYXJzTWFwW2ZpbGVJbmZvLmZpbGVuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7IGluZGV4ID0gMDsgfVxuICAgICAgICAgICAgICAgIC8vIGFkanVzdCB0aGUgc291cmNlXG4gICAgICAgICAgICAgICAgaW5wdXRTb3VyY2UgPSBpbnB1dFNvdXJjZS5zbGljZSh0aGlzLl9jb250ZW50c0lnbm9yZWRDaGFyc01hcFtmaWxlSW5mby5maWxlbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRTb3VyY2UgPSBpbnB1dFNvdXJjZS5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICAgICAgc291cmNlTGluZXMgPSBpbnB1dFNvdXJjZS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgIHNvdXJjZUNvbHVtbnMgPSBzb3VyY2VMaW5lc1tzb3VyY2VMaW5lcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmVzID0gY2h1bmsuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIGNvbHVtbnMgPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoZmlsZUluZm8pIHtcbiAgICAgICAgICAgIGlmICghbWFwTGluZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBHZW5lcmF0b3IuYWRkTWFwcGluZyh7IGdlbmVyYXRlZDogeyBsaW5lOiB0aGlzLl9saW5lTnVtYmVyICsgMSwgY29sdW1uOiB0aGlzLl9jb2x1bW59LFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbDogeyBsaW5lOiBzb3VyY2VMaW5lcy5sZW5ndGgsIGNvbHVtbjogc291cmNlQ29sdW1ucy5sZW5ndGh9LFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMubm9ybWFsaXplRmlsZW5hbWUoZmlsZUluZm8uZmlsZW5hbWUpfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBHZW5lcmF0b3IuYWRkTWFwcGluZyh7IGdlbmVyYXRlZDogeyBsaW5lOiB0aGlzLl9saW5lTnVtYmVyICsgaSArIDEsIGNvbHVtbjogaSA9PT0gMCA/IHRoaXMuX2NvbHVtbiA6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWw6IHsgbGluZTogc291cmNlTGluZXMubGVuZ3RoICsgaSwgY29sdW1uOiBpID09PSAwID8gc291cmNlQ29sdW1ucy5sZW5ndGggOiAwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5ub3JtYWxpemVGaWxlbmFtZShmaWxlSW5mby5maWxlbmFtZSl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGluZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9jb2x1bW4gKz0gY29sdW1ucy5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lTnVtYmVyICs9IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB0aGlzLl9jb2x1bW4gPSBjb2x1bW5zLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Nzcy5wdXNoKGNodW5rKTtcbiAgICB9O1xuXG4gICAgU291cmNlTWFwT3V0cHV0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jc3MubGVuZ3RoID09PSAwO1xuICAgIH07XG5cbiAgICBTb3VyY2VNYXBPdXRwdXQucHJvdG90eXBlLnRvQ1NTID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICB0aGlzLl9zb3VyY2VNYXBHZW5lcmF0b3IgPSBuZXcgdGhpcy5fc291cmNlTWFwR2VuZXJhdG9yQ29uc3RydWN0b3IoeyBmaWxlOiB0aGlzLl9vdXRwdXRGaWxlbmFtZSwgc291cmNlUm9vdDogbnVsbCB9KTtcblxuICAgICAgICBpZiAodGhpcy5fb3V0cHV0U291cmNlRmlsZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGZpbGVuYW1lIGluIHRoaXMuX2NvbnRlbnRzTWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnRzTWFwLmhhc093blByb3BlcnR5KGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5fY29udGVudHNNYXBbZmlsZW5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29udGVudHNJZ25vcmVkQ2hhcnNNYXBbZmlsZW5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc2xpY2UodGhpcy5fY29udGVudHNJZ25vcmVkQ2hhcnNNYXBbZmlsZW5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBHZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudCh0aGlzLm5vcm1hbGl6ZUZpbGVuYW1lKGZpbGVuYW1lKSwgc291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yb290Tm9kZS5nZW5DU1MoY29udGV4dCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2Nzcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlTWFwVVJMLFxuICAgICAgICAgICAgICAgIHNvdXJjZU1hcENvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLl9zb3VyY2VNYXBHZW5lcmF0b3IudG9KU09OKCkpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VNYXBVUkwpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXBVUkwgPSB0aGlzLnNvdXJjZU1hcFVSTDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fc291cmNlTWFwRmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXBVUkwgPSB0aGlzLl9zb3VyY2VNYXBGaWxlbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc291cmNlTWFwVVJMID0gc291cmNlTWFwVVJMO1xuXG4gICAgICAgICAgICB0aGlzLnNvdXJjZU1hcCA9IHNvdXJjZU1hcENvbnRlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fY3NzLmpvaW4oJycpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU291cmNlTWFwT3V0cHV0O1xufTtcblxufSx7fV0sNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGNvbnRleHRzID0gcmVxdWlyZShcIi4vY29udGV4dHNcIiksXG4gICAgdmlzaXRvciA9IHJlcXVpcmUoXCIuL3Zpc2l0b3JzXCIpLFxuICAgIHRyZWUgPSByZXF1aXJlKFwiLi90cmVlXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHJvb3QsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgZXZhbGRSb290LFxuICAgICAgICB2YXJpYWJsZXMgPSBvcHRpb25zLnZhcmlhYmxlcyxcbiAgICAgICAgZXZhbEVudiA9IG5ldyBjb250ZXh0cy5FdmFsKG9wdGlvbnMpO1xuXG4gICAgLy9cbiAgICAvLyBBbGxvd3Mgc2V0dGluZyB2YXJpYWJsZXMgd2l0aCBhIGhhc2gsIHNvOlxuICAgIC8vXG4gICAgLy8gICBgeyBjb2xvcjogbmV3IHRyZWUuQ29sb3IoJyNmMDEnKSB9YCB3aWxsIGJlY29tZTpcbiAgICAvL1xuICAgIC8vICAgbmV3IHRyZWUuUnVsZSgnQGNvbG9yJyxcbiAgICAvLyAgICAgbmV3IHRyZWUuVmFsdWUoW1xuICAgIC8vICAgICAgIG5ldyB0cmVlLkV4cHJlc3Npb24oW1xuICAgIC8vICAgICAgICAgbmV3IHRyZWUuQ29sb3IoJyNmMDEnKVxuICAgIC8vICAgICAgIF0pXG4gICAgLy8gICAgIF0pXG4gICAgLy8gICApXG4gICAgLy9cbiAgICBpZiAodHlwZW9mIHZhcmlhYmxlcyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFyaWFibGVzKSkge1xuICAgICAgICB2YXJpYWJsZXMgPSBPYmplY3Qua2V5cyh2YXJpYWJsZXMpLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFyaWFibGVzW2tdO1xuXG4gICAgICAgICAgICBpZiAoISAodmFsdWUgaW5zdGFuY2VvZiB0cmVlLlZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICghICh2YWx1ZSBpbnN0YW5jZW9mIHRyZWUuRXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgdHJlZS5FeHByZXNzaW9uKFt2YWx1ZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyB0cmVlLlZhbHVlKFt2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlJ1bGUoJ0AnICsgaywgdmFsdWUsIGZhbHNlLCBudWxsLCAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV2YWxFbnYuZnJhbWVzID0gW25ldyB0cmVlLlJ1bGVzZXQobnVsbCwgdmFyaWFibGVzKV07XG4gICAgfVxuXG4gICAgdmFyIHByZUV2YWxWaXNpdG9ycyA9IFtdLFxuICAgICAgICB2aXNpdG9ycyA9IFtcbiAgICAgICAgICAgIG5ldyB2aXNpdG9yLkpvaW5TZWxlY3RvclZpc2l0b3IoKSxcbiAgICAgICAgICAgIG5ldyB2aXNpdG9yLk1hcmtWaXNpYmxlU2VsZWN0b3JzVmlzaXRvcih0cnVlKSxcbiAgICAgICAgICAgIG5ldyB2aXNpdG9yLkV4dGVuZFZpc2l0b3IoKSxcbiAgICAgICAgICAgIG5ldyB2aXNpdG9yLlRvQ1NTVmlzaXRvcih7Y29tcHJlc3M6IEJvb2xlYW4ob3B0aW9ucy5jb21wcmVzcyl9KVxuICAgICAgICBdLCBpO1xuXG4gICAgaWYgKG9wdGlvbnMucGx1Z2luTWFuYWdlcikge1xuICAgICAgICB2YXIgcGx1Z2luVmlzaXRvcnMgPSBvcHRpb25zLnBsdWdpbk1hbmFnZXIuZ2V0VmlzaXRvcnMoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBsdWdpblZpc2l0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGx1Z2luVmlzaXRvciA9IHBsdWdpblZpc2l0b3JzW2ldO1xuICAgICAgICAgICAgaWYgKHBsdWdpblZpc2l0b3IuaXNQcmVFdmFsVmlzaXRvcikge1xuICAgICAgICAgICAgICAgIHByZUV2YWxWaXNpdG9ycy5wdXNoKHBsdWdpblZpc2l0b3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luVmlzaXRvci5pc1ByZVZpc2l0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRvcnMuc3BsaWNlKDAsIDAsIHBsdWdpblZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0b3JzLnB1c2gocGx1Z2luVmlzaXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHByZUV2YWxWaXNpdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmVFdmFsVmlzaXRvcnNbaV0ucnVuKHJvb3QpO1xuICAgIH1cblxuICAgIGV2YWxkUm9vdCA9IHJvb3QuZXZhbChldmFsRW52KTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB2aXNpdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2aXNpdG9yc1tpXS5ydW4oZXZhbGRSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZhbGRSb290O1xufTtcblxufSx7XCIuL2NvbnRleHRzXCI6MTEsXCIuL3RyZWVcIjo2MixcIi4vdmlzaXRvcnNcIjo4N31dLDQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKTtcblxudmFyIEFscGhhID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMudmFsdWUgPSB2YWw7XG59O1xuQWxwaGEucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcbkFscGhhLnByb3RvdHlwZS50eXBlID0gXCJBbHBoYVwiO1xuXG5BbHBoYS5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICB0aGlzLnZhbHVlID0gdmlzaXRvci52aXNpdCh0aGlzLnZhbHVlKTtcbn07XG5BbHBoYS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMudmFsdWUuZXZhbCkgeyByZXR1cm4gbmV3IEFscGhhKHRoaXMudmFsdWUuZXZhbChjb250ZXh0KSk7IH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5BbHBoYS5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIG91dHB1dC5hZGQoXCJhbHBoYShvcGFjaXR5PVwiKTtcblxuICAgIGlmICh0aGlzLnZhbHVlLmdlbkNTUykge1xuICAgICAgICB0aGlzLnZhbHVlLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5hZGQodGhpcy52YWx1ZSk7XG4gICAgfVxuXG4gICAgb3V0cHV0LmFkZChcIilcIik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFscGhhO1xuXG59LHtcIi4vbm9kZVwiOjcwfV0sNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpO1xuXG52YXIgQW5vbnltb3VzID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgY3VycmVudEZpbGVJbmZvLCBtYXBMaW5lcywgcnVsZXNldExpa2UsIHZpc2liaWxpdHlJbmZvKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLm1hcExpbmVzID0gbWFwTGluZXM7XG4gICAgdGhpcy5jdXJyZW50RmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XG4gICAgdGhpcy5ydWxlc2V0TGlrZSA9ICh0eXBlb2YgcnVsZXNldExpa2UgPT09ICd1bmRlZmluZWQnKSA/IGZhbHNlIDogcnVsZXNldExpa2U7XG4gICAgdGhpcy5hbGxvd1Jvb3QgPSB0cnVlO1xuICAgIHRoaXMuY29weVZpc2liaWxpdHlJbmZvKHZpc2liaWxpdHlJbmZvKTtcbn07XG5Bbm9ueW1vdXMucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcbkFub255bW91cy5wcm90b3R5cGUudHlwZSA9IFwiQW5vbnltb3VzXCI7XG5Bbm9ueW1vdXMucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXModGhpcy52YWx1ZSwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8sIHRoaXMubWFwTGluZXMsIHRoaXMucnVsZXNldExpa2UsIHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XG59O1xuQW5vbnltb3VzLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLnRvQ1NTICYmIHRoaXMudG9DU1MoKSA9PT0gb3RoZXIudG9DU1MoKSA/IDAgOiB1bmRlZmluZWQ7XG59O1xuQW5vbnltb3VzLnByb3RvdHlwZS5pc1J1bGVzZXRMaWtlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXNldExpa2U7XG59O1xuQW5vbnltb3VzLnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgb3V0cHV0LmFkZCh0aGlzLnZhbHVlLCB0aGlzLmN1cnJlbnRGaWxlSW5mbywgdGhpcy5pbmRleCwgdGhpcy5tYXBMaW5lcyk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBBbm9ueW1vdXM7XG5cbn0se1wiLi9ub2RlXCI6NzB9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIik7XG5cbnZhciBBc3NpZ25tZW50ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbDtcbn07XG5cbkFzc2lnbm1lbnQucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcbkFzc2lnbm1lbnQucHJvdG90eXBlLnR5cGUgPSBcIkFzc2lnbm1lbnRcIjtcbkFzc2lnbm1lbnQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZpc2l0b3IudmlzaXQodGhpcy52YWx1ZSk7XG59O1xuQXNzaWdubWVudC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMudmFsdWUuZXZhbCkge1xuICAgICAgICByZXR1cm4gbmV3IEFzc2lnbm1lbnQodGhpcy5rZXksIHRoaXMudmFsdWUuZXZhbChjb250ZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcbkFzc2lnbm1lbnQucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICBvdXRwdXQuYWRkKHRoaXMua2V5ICsgJz0nKTtcbiAgICBpZiAodGhpcy52YWx1ZS5nZW5DU1MpIHtcbiAgICAgICAgdGhpcy52YWx1ZS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQuYWRkKHRoaXMudmFsdWUpO1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IEFzc2lnbm1lbnQ7XG5cbn0se1wiLi9ub2RlXCI6NzB9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIik7XG5cbnZhciBBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoa2V5LCBvcCwgdmFsdWUpIHtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wID0gb3A7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufTtcbkF0dHJpYnV0ZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuQXR0cmlidXRlLnByb3RvdHlwZS50eXBlID0gXCJBdHRyaWJ1dGVcIjtcbkF0dHJpYnV0ZS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGUodGhpcy5rZXkuZXZhbCA/IHRoaXMua2V5LmV2YWwoY29udGV4dCkgOiB0aGlzLmtleSxcbiAgICAgICAgdGhpcy5vcCwgKHRoaXMudmFsdWUgJiYgdGhpcy52YWx1ZS5ldmFsKSA/IHRoaXMudmFsdWUuZXZhbChjb250ZXh0KSA6IHRoaXMudmFsdWUpO1xufTtcbkF0dHJpYnV0ZS5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIG91dHB1dC5hZGQodGhpcy50b0NTUyhjb250ZXh0KSk7XG59O1xuQXR0cmlidXRlLnByb3RvdHlwZS50b0NTUyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5rZXkudG9DU1MgPyB0aGlzLmtleS50b0NTUyhjb250ZXh0KSA6IHRoaXMua2V5O1xuXG4gICAgaWYgKHRoaXMub3ApIHtcbiAgICAgICAgdmFsdWUgKz0gdGhpcy5vcDtcbiAgICAgICAgdmFsdWUgKz0gKHRoaXMudmFsdWUudG9DU1MgPyB0aGlzLnZhbHVlLnRvQ1NTKGNvbnRleHQpIDogdGhpcy52YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICdbJyArIHZhbHVlICsgJ10nO1xufTtcbm1vZHVsZS5leHBvcnRzID0gQXR0cmlidXRlO1xuXG59LHtcIi4vbm9kZVwiOjcwfV0sNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpLFxuICAgIEZ1bmN0aW9uQ2FsbGVyID0gcmVxdWlyZShcIi4uL2Z1bmN0aW9ucy9mdW5jdGlvbi1jYWxsZXJcIik7XG4vL1xuLy8gQSBmdW5jdGlvbiBjYWxsIG5vZGUuXG4vL1xudmFyIENhbGwgPSBmdW5jdGlvbiAobmFtZSwgYXJncywgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5jdXJyZW50RmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XG59O1xuQ2FsbC5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuQ2FsbC5wcm90b3R5cGUudHlwZSA9IFwiQ2FsbFwiO1xuQ2FsbC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICBpZiAodGhpcy5hcmdzKSB7XG4gICAgICAgIHRoaXMuYXJncyA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLmFyZ3MpO1xuICAgIH1cbn07XG4vL1xuLy8gV2hlbiBldmFsdWF0aW5nIGEgZnVuY3Rpb24gY2FsbCxcbi8vIHdlIGVpdGhlciBmaW5kIHRoZSBmdW5jdGlvbiBpbiB0aGUgZnVuY3Rpb25SZWdpc3RyeSxcbi8vIGluIHdoaWNoIGNhc2Ugd2UgY2FsbCBpdCwgcGFzc2luZyB0aGUgIGV2YWx1YXRlZCBhcmd1bWVudHMsXG4vLyBpZiB0aGlzIHJldHVybnMgbnVsbCBvciB3ZSBjYW5ub3QgZmluZCB0aGUgZnVuY3Rpb24sIHdlXG4vLyBzaW1wbHkgcHJpbnQgaXQgb3V0IGFzIGl0IGFwcGVhcmVkIG9yaWdpbmFsbHkgWzJdLlxuLy9cbi8vIFRoZSByZWFzb24gd2h5IHdlIGV2YWx1YXRlIHRoZSBhcmd1bWVudHMsIGlzIGluIHRoZSBjYXNlIHdoZXJlXG4vLyB3ZSB0cnkgdG8gcGFzcyBhIHZhcmlhYmxlIHRvIGEgZnVuY3Rpb24sIGxpa2U6IGBzYXR1cmF0ZShAY29sb3IpYC5cbi8vIFRoZSBmdW5jdGlvbiBzaG91bGQgcmVjZWl2ZSB0aGUgdmFsdWUsIG5vdCB0aGUgdmFyaWFibGUuXG4vL1xuQ2FsbC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIGFyZ3MgPSB0aGlzLmFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLmV2YWwoY29udGV4dCk7IH0pLFxuICAgICAgICByZXN1bHQsIGZ1bmNDYWxsZXIgPSBuZXcgRnVuY3Rpb25DYWxsZXIodGhpcy5uYW1lLCBjb250ZXh0LCB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbyk7XG5cbiAgICBpZiAoZnVuY0NhbGxlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNDYWxsZXIuY2FsbChhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiBlLnR5cGUgfHwgXCJSdW50aW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiZXJyb3IgZXZhbHVhdGluZyBmdW5jdGlvbiBgXCIgKyB0aGlzLm5hbWUgKyBcImBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLm1lc3NhZ2UgPyAnOiAnICsgZS5tZXNzYWdlIDogJycpLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCwgZmlsZW5hbWU6IHRoaXMuY3VycmVudEZpbGVJbmZvLmZpbGVuYW1lIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5pbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICByZXN1bHQuY3VycmVudEZpbGVJbmZvID0gdGhpcy5jdXJyZW50RmlsZUluZm87XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDYWxsKHRoaXMubmFtZSwgYXJncywgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8pO1xufTtcbkNhbGwucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICBvdXRwdXQuYWRkKHRoaXMubmFtZSArIFwiKFwiLCB0aGlzLmN1cnJlbnRGaWxlSW5mbywgdGhpcy5pbmRleCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFyZ3NbaV0uZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgICAgIGlmIChpICsgMSA8IHRoaXMuYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG91dHB1dC5hZGQoXCIsIFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG91dHB1dC5hZGQoXCIpXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ2FsbDtcblxufSx7XCIuLi9mdW5jdGlvbnMvZnVuY3Rpb24tY2FsbGVyXCI6MjEsXCIuL25vZGVcIjo3MH1dLDUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKSxcbiAgICBjb2xvcnMgPSByZXF1aXJlKFwiLi4vZGF0YS9jb2xvcnNcIik7XG5cbi8vXG4vLyBSR0IgQ29sb3JzIC0gI2ZmMDAxNCwgI2VlZVxuLy9cbnZhciBDb2xvciA9IGZ1bmN0aW9uIChyZ2IsIGEsIG9yaWdpbmFsRm9ybSkge1xuICAgIC8vXG4gICAgLy8gVGhlIGVuZCBnb2FsIGhlcmUsIGlzIHRvIHBhcnNlIHRoZSBhcmd1bWVudHNcbiAgICAvLyBpbnRvIGFuIGludGVnZXIgdHJpcGxldCwgc3VjaCBhcyBgMTI4LCAyNTUsIDBgXG4gICAgLy9cbiAgICAvLyBUaGlzIGZhY2lsaXRhdGVzIG9wZXJhdGlvbnMgYW5kIGNvbnZlcnNpb25zLlxuICAgIC8vXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmdiKSkge1xuICAgICAgICB0aGlzLnJnYiA9IHJnYjtcbiAgICB9IGVsc2UgaWYgKHJnYi5sZW5ndGggPT0gNikge1xuICAgICAgICB0aGlzLnJnYiA9IHJnYi5tYXRjaCgvLnsyfS9nKS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChjLCAxNik7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmdiID0gcmdiLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChjICsgYywgMTYpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5hbHBoYSA9IHR5cGVvZiBhID09PSAnbnVtYmVyJyA/IGEgOiAxO1xuICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxGb3JtICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnZhbHVlID0gb3JpZ2luYWxGb3JtO1xuICAgIH1cbn07XG5cbkNvbG9yLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5Db2xvci5wcm90b3R5cGUudHlwZSA9IFwiQ29sb3JcIjtcblxuZnVuY3Rpb24gY2xhbXAodiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHYsIDApLCBtYXgpO1xufVxuXG5mdW5jdGlvbiB0b0hleCh2KSB7XG4gICAgcmV0dXJuICcjJyArIHYubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGMgPSBjbGFtcChNYXRoLnJvdW5kKGMpLCAyNTUpO1xuICAgICAgICByZXR1cm4gKGMgPCAxNiA/ICcwJyA6ICcnKSArIGMudG9TdHJpbmcoMTYpO1xuICAgIH0pLmpvaW4oJycpO1xufVxuXG5Db2xvci5wcm90b3R5cGUubHVtYSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgciA9IHRoaXMucmdiWzBdIC8gMjU1LFxuICAgICAgICBnID0gdGhpcy5yZ2JbMV0gLyAyNTUsXG4gICAgICAgIGIgPSB0aGlzLnJnYlsyXSAvIDI1NTtcblxuICAgIHIgPSAociA8PSAwLjAzOTI4KSA/IHIgLyAxMi45MiA6IE1hdGgucG93KCgociArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTtcbiAgICBnID0gKGcgPD0gMC4wMzkyOCkgPyBnIC8gMTIuOTIgOiBNYXRoLnBvdygoKGcgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCk7XG4gICAgYiA9IChiIDw9IDAuMDM5MjgpID8gYiAvIDEyLjkyIDogTWF0aC5wb3coKChiICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO1xuXG4gICAgcmV0dXJuIDAuMjEyNiAqIHIgKyAwLjcxNTIgKiBnICsgMC4wNzIyICogYjtcbn07XG5Db2xvci5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIG91dHB1dC5hZGQodGhpcy50b0NTUyhjb250ZXh0KSk7XG59O1xuQ29sb3IucHJvdG90eXBlLnRvQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIGRvTm90Q29tcHJlc3MpIHtcbiAgICB2YXIgY29tcHJlc3MgPSBjb250ZXh0ICYmIGNvbnRleHQuY29tcHJlc3MgJiYgIWRvTm90Q29tcHJlc3MsIGNvbG9yLCBhbHBoYTtcblxuICAgIC8vIGB2YWx1ZWAgaXMgc2V0IGlmIHRoaXMgY29sb3Igd2FzIG9yaWdpbmFsbHlcbiAgICAvLyBjb252ZXJ0ZWQgZnJvbSBhIG5hbWVkIGNvbG9yIHN0cmluZyBzbyB3ZSBuZWVkXG4gICAgLy8gdG8gcmVzcGVjdCB0aGlzIGFuZCB0cnkgdG8gb3V0cHV0IG5hbWVkIGNvbG9yIHRvby5cbiAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlIHNvbWUgdHJhbnNwYXJlbmN5LCB0aGUgb25seSB3YXkgdG8gcmVwcmVzZW50IGl0XG4gICAgLy8gaXMgdmlhIGByZ2JhYC4gT3RoZXJ3aXNlLCB3ZSB1c2UgdGhlIGhleCByZXByZXNlbnRhdGlvbixcbiAgICAvLyB3aGljaCBoYXMgYmV0dGVyIGNvbXBhdGliaWxpdHkgd2l0aCBvbGRlciBicm93c2Vycy5cbiAgICAvLyBWYWx1ZXMgYXJlIGNhcHBlZCBiZXR3ZWVuIGAwYCBhbmQgYDI1NWAsIHJvdW5kZWQgYW5kIHplcm8tcGFkZGVkLlxuICAgIGFscGhhID0gdGhpcy5mcm91bmQoY29udGV4dCwgdGhpcy5hbHBoYSk7XG4gICAgaWYgKGFscGhhIDwgMSkge1xuICAgICAgICByZXR1cm4gXCJyZ2JhKFwiICsgdGhpcy5yZ2IubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhbXAoTWF0aC5yb3VuZChjKSwgMjU1KTtcbiAgICAgICAgfSkuY29uY2F0KGNsYW1wKGFscGhhLCAxKSlcbiAgICAgICAgICAgIC5qb2luKCcsJyArIChjb21wcmVzcyA/ICcnIDogJyAnKSkgKyBcIilcIjtcbiAgICB9XG5cbiAgICBjb2xvciA9IHRoaXMudG9SR0IoKTtcblxuICAgIGlmIChjb21wcmVzcykge1xuICAgICAgICB2YXIgc3BsaXRjb2xvciA9IGNvbG9yLnNwbGl0KCcnKTtcblxuICAgICAgICAvLyBDb252ZXJ0IGNvbG9yIHRvIHNob3J0IGZvcm1hdFxuICAgICAgICBpZiAoc3BsaXRjb2xvclsxXSA9PT0gc3BsaXRjb2xvclsyXSAmJiBzcGxpdGNvbG9yWzNdID09PSBzcGxpdGNvbG9yWzRdICYmIHNwbGl0Y29sb3JbNV0gPT09IHNwbGl0Y29sb3JbNl0pIHtcbiAgICAgICAgICAgIGNvbG9yID0gJyMnICsgc3BsaXRjb2xvclsxXSArIHNwbGl0Y29sb3JbM10gKyBzcGxpdGNvbG9yWzVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbG9yO1xufTtcblxuLy9cbi8vIE9wZXJhdGlvbnMgaGF2ZSB0byBiZSBkb25lIHBlci1jaGFubmVsLCBpZiBub3QsXG4vLyBjaGFubmVscyB3aWxsIHNwaWxsIG9udG8gZWFjaCBvdGhlci4gT25jZSB3ZSBoYXZlXG4vLyBvdXIgcmVzdWx0LCBpbiB0aGUgZm9ybSBvZiBhbiBpbnRlZ2VyIHRyaXBsZXQsXG4vLyB3ZSBjcmVhdGUgYSBuZXcgQ29sb3Igbm9kZSB0byBob2xkIHRoZSByZXN1bHQuXG4vL1xuQ29sb3IucHJvdG90eXBlLm9wZXJhdGUgPSBmdW5jdGlvbiAoY29udGV4dCwgb3AsIG90aGVyKSB7XG4gICAgdmFyIHJnYiA9IFtdO1xuICAgIHZhciBhbHBoYSA9IHRoaXMuYWxwaGEgKiAoMSAtIG90aGVyLmFscGhhKSArIG90aGVyLmFscGhhO1xuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgMzsgYysrKSB7XG4gICAgICAgIHJnYltjXSA9IHRoaXMuX29wZXJhdGUoY29udGV4dCwgb3AsIHRoaXMucmdiW2NdLCBvdGhlci5yZ2JbY10pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENvbG9yKHJnYiwgYWxwaGEpO1xufTtcbkNvbG9yLnByb3RvdHlwZS50b1JHQiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdG9IZXgodGhpcy5yZ2IpO1xufTtcbkNvbG9yLnByb3RvdHlwZS50b0hTTCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgciA9IHRoaXMucmdiWzBdIC8gMjU1LFxuICAgICAgICBnID0gdGhpcy5yZ2JbMV0gLyAyNTUsXG4gICAgICAgIGIgPSB0aGlzLnJnYlsyXSAvIDI1NSxcbiAgICAgICAgYSA9IHRoaXMuYWxwaGE7XG5cbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYiksIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIHZhciBoLCBzLCBsID0gKG1heCArIG1pbikgLyAyLCBkID0gbWF4IC0gbWluO1xuXG4gICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgIGggPSBzID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG5cbiAgICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgICAgIGNhc2UgcjogaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZzogaCA9IChiIC0gcikgLyBkICsgMjsgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYjogaCA9IChyIC0gZykgLyBkICsgNDsgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBoIC89IDY7XG4gICAgfVxuICAgIHJldHVybiB7IGg6IGggKiAzNjAsIHM6IHMsIGw6IGwsIGE6IGEgfTtcbn07XG4vL0FkYXB0ZWQgZnJvbSBodHRwOi8vbWppamFja3Nvbi5jb20vMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0XG5Db2xvci5wcm90b3R5cGUudG9IU1YgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHIgPSB0aGlzLnJnYlswXSAvIDI1NSxcbiAgICAgICAgZyA9IHRoaXMucmdiWzFdIC8gMjU1LFxuICAgICAgICBiID0gdGhpcy5yZ2JbMl0gLyAyNTUsXG4gICAgICAgIGEgPSB0aGlzLmFscGhhO1xuXG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICB2YXIgaCwgcywgdiA9IG1heDtcblxuICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgIGlmIChtYXggPT09IDApIHtcbiAgICAgICAgcyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcyA9IGQgLyBtYXg7XG4gICAgfVxuXG4gICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgIGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaChtYXgpIHtcbiAgICAgICAgICAgIGNhc2UgcjogaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZzogaCA9IChiIC0gcikgLyBkICsgMjsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGI6IGggPSAociAtIGcpIC8gZCArIDQ7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGggLz0gNjtcbiAgICB9XG4gICAgcmV0dXJuIHsgaDogaCAqIDM2MCwgczogcywgdjogdiwgYTogYSB9O1xufTtcbkNvbG9yLnByb3RvdHlwZS50b0FSR0IgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRvSGV4KFt0aGlzLmFscGhhICogMjU1XS5jb25jYXQodGhpcy5yZ2IpKTtcbn07XG5Db2xvci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuICh4LnJnYiAmJlxuICAgICAgICB4LnJnYlswXSA9PT0gdGhpcy5yZ2JbMF0gJiZcbiAgICAgICAgeC5yZ2JbMV0gPT09IHRoaXMucmdiWzFdICYmXG4gICAgICAgIHgucmdiWzJdID09PSB0aGlzLnJnYlsyXSAmJlxuICAgICAgICB4LmFscGhhICA9PT0gdGhpcy5hbHBoYSkgPyAwIDogdW5kZWZpbmVkO1xufTtcblxuQ29sb3IuZnJvbUtleXdvcmQgPSBmdW5jdGlvbihrZXl3b3JkKSB7XG4gICAgdmFyIGMsIGtleSA9IGtleXdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoY29sb3JzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgYyA9IG5ldyBDb2xvcihjb2xvcnNba2V5XS5zbGljZSgxKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtleSA9PT0gXCJ0cmFuc3BhcmVudFwiKSB7XG4gICAgICAgIGMgPSBuZXcgQ29sb3IoWzAsIDAsIDBdLCAwKTtcbiAgICB9XG5cbiAgICBpZiAoYykge1xuICAgICAgICBjLnZhbHVlID0ga2V5d29yZDtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gQ29sb3I7XG5cbn0se1wiLi4vZGF0YS9jb2xvcnNcIjoxMixcIi4vbm9kZVwiOjcwfV0sNTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpO1xuXG52YXIgQ29tYmluYXRvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gJyAnKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSAnICc7XG4gICAgICAgIHRoaXMuZW1wdHlPcldoaXRlc3BhY2UgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZSA/IHZhbHVlLnRyaW0oKSA6IFwiXCI7XG4gICAgICAgIHRoaXMuZW1wdHlPcldoaXRlc3BhY2UgPSB0aGlzLnZhbHVlID09PSBcIlwiO1xuICAgIH1cbn07XG5Db21iaW5hdG9yLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5Db21iaW5hdG9yLnByb3RvdHlwZS50eXBlID0gXCJDb21iaW5hdG9yXCI7XG52YXIgX25vU3BhY2VDb21iaW5hdG9ycyA9IHtcbiAgICAnJzogdHJ1ZSxcbiAgICAnICc6IHRydWUsXG4gICAgJ3wnOiB0cnVlXG59O1xuQ29tYmluYXRvci5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIHZhciBzcGFjZU9yRW1wdHkgPSAoY29udGV4dC5jb21wcmVzcyB8fCBfbm9TcGFjZUNvbWJpbmF0b3JzW3RoaXMudmFsdWVdKSA/ICcnIDogJyAnO1xuICAgIG91dHB1dC5hZGQoc3BhY2VPckVtcHR5ICsgdGhpcy52YWx1ZSArIHNwYWNlT3JFbXB0eSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDb21iaW5hdG9yO1xuXG59LHtcIi4vbm9kZVwiOjcwfV0sNTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpLFxuICAgIGdldERlYnVnSW5mbyA9IHJlcXVpcmUoXCIuL2RlYnVnLWluZm9cIik7XG5cbnZhciBDb21tZW50ID0gZnVuY3Rpb24gKHZhbHVlLCBpc0xpbmVDb21tZW50LCBpbmRleCwgY3VycmVudEZpbGVJbmZvKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuaXNMaW5lQ29tbWVudCA9IGlzTGluZUNvbW1lbnQ7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuY3VycmVudEZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xuICAgIHRoaXMuYWxsb3dSb290ID0gdHJ1ZTtcbn07XG5Db21tZW50LnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5Db21tZW50LnByb3RvdHlwZS50eXBlID0gXCJDb21tZW50XCI7XG5Db21tZW50LnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgaWYgKHRoaXMuZGVidWdJbmZvKSB7XG4gICAgICAgIG91dHB1dC5hZGQoZ2V0RGVidWdJbmZvKGNvbnRleHQsIHRoaXMpLCB0aGlzLmN1cnJlbnRGaWxlSW5mbywgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIG91dHB1dC5hZGQodGhpcy52YWx1ZSk7XG59O1xuQ29tbWVudC5wcm90b3R5cGUuaXNTaWxlbnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIGlzQ29tcHJlc3NlZCA9IGNvbnRleHQuY29tcHJlc3MgJiYgdGhpcy52YWx1ZVsyXSAhPT0gXCIhXCI7XG4gICAgcmV0dXJuIHRoaXMuaXNMaW5lQ29tbWVudCB8fCBpc0NvbXByZXNzZWQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDb21tZW50O1xuXG59LHtcIi4vZGVidWctaW5mb1wiOjU0LFwiLi9ub2RlXCI6NzB9XSw1MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIik7XG5cbnZhciBDb25kaXRpb24gPSBmdW5jdGlvbiAob3AsIGwsIHIsIGksIG5lZ2F0ZSkge1xuICAgIHRoaXMub3AgPSBvcC50cmltKCk7XG4gICAgdGhpcy5sdmFsdWUgPSBsO1xuICAgIHRoaXMucnZhbHVlID0gcjtcbiAgICB0aGlzLmluZGV4ID0gaTtcbiAgICB0aGlzLm5lZ2F0ZSA9IG5lZ2F0ZTtcbn07XG5Db25kaXRpb24ucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcbkNvbmRpdGlvbi5wcm90b3R5cGUudHlwZSA9IFwiQ29uZGl0aW9uXCI7XG5Db25kaXRpb24ucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgdGhpcy5sdmFsdWUgPSB2aXNpdG9yLnZpc2l0KHRoaXMubHZhbHVlKTtcbiAgICB0aGlzLnJ2YWx1ZSA9IHZpc2l0b3IudmlzaXQodGhpcy5ydmFsdWUpO1xufTtcbkNvbmRpdGlvbi5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IChmdW5jdGlvbiAob3AsIGEsIGIpIHtcbiAgICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICAgICAgY2FzZSAnYW5kJzogcmV0dXJuIGEgJiYgYjtcbiAgICAgICAgICAgIGNhc2UgJ29yJzogIHJldHVybiBhIHx8IGI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoTm9kZS5jb21wYXJlKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3AgPT09ICc8JyB8fCBvcCA9PT0gJz08JyB8fCBvcCA9PT0gJzw9JztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wID09PSAnPScgfHwgb3AgPT09ICc+PScgfHwgb3AgPT09ICc9PCcgfHwgb3AgPT09ICc8PSc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcCA9PT0gJz4nIHx8IG9wID09PSAnPj0nO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pKHRoaXMub3AsIHRoaXMubHZhbHVlLmV2YWwoY29udGV4dCksIHRoaXMucnZhbHVlLmV2YWwoY29udGV4dCkpO1xuXG4gICAgcmV0dXJuIHRoaXMubmVnYXRlID8gIXJlc3VsdCA6IHJlc3VsdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IENvbmRpdGlvbjtcblxufSx7XCIuL25vZGVcIjo3MH1dLDU0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBkZWJ1Z0luZm8gPSBmdW5jdGlvbihjb250ZXh0LCBjdHgsIGxpbmVTZXBhcmF0b3IpIHtcbiAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICBpZiAoY29udGV4dC5kdW1wTGluZU51bWJlcnMgJiYgIWNvbnRleHQuY29tcHJlc3MpIHtcbiAgICAgICAgc3dpdGNoKGNvbnRleHQuZHVtcExpbmVOdW1iZXJzKSB7XG4gICAgICAgICAgICBjYXNlICdjb21tZW50cyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVidWdJbmZvLmFzQ29tbWVudChjdHgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWVkaWFxdWVyeSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVidWdJbmZvLmFzTWVkaWFRdWVyeShjdHgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWxsJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBkZWJ1Z0luZm8uYXNDb21tZW50KGN0eCkgKyAobGluZVNlcGFyYXRvciB8fCBcIlwiKSArIGRlYnVnSW5mby5hc01lZGlhUXVlcnkoY3R4KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuZGVidWdJbmZvLmFzQ29tbWVudCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIHJldHVybiAnLyogbGluZSAnICsgY3R4LmRlYnVnSW5mby5saW5lTnVtYmVyICsgJywgJyArIGN0eC5kZWJ1Z0luZm8uZmlsZU5hbWUgKyAnICovXFxuJztcbn07XG5cbmRlYnVnSW5mby5hc01lZGlhUXVlcnkgPSBmdW5jdGlvbihjdHgpIHtcbiAgICB2YXIgZmlsZW5hbWVXaXRoUHJvdG9jb2wgPSBjdHguZGVidWdJbmZvLmZpbGVOYW1lO1xuICAgIGlmICghL15bYS16XSs6XFwvXFwvL2kudGVzdChmaWxlbmFtZVdpdGhQcm90b2NvbCkpIHtcbiAgICAgICAgZmlsZW5hbWVXaXRoUHJvdG9jb2wgPSAnZmlsZTovLycgKyBmaWxlbmFtZVdpdGhQcm90b2NvbDtcbiAgICB9XG4gICAgcmV0dXJuICdAbWVkaWEgLXNhc3MtZGVidWctaW5mb3tmaWxlbmFtZXtmb250LWZhbWlseTonICtcbiAgICAgICAgZmlsZW5hbWVXaXRoUHJvdG9jb2wucmVwbGFjZSgvKFsuOlxcL1xcXFxdKS9nLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgaWYgKGEgPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgYSA9ICdcXC8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdcXFxcJyArIGE7XG4gICAgICAgIH0pICtcbiAgICAgICAgJ31saW5le2ZvbnQtZmFtaWx5OlxcXFwwMDAwMycgKyBjdHguZGVidWdJbmZvLmxpbmVOdW1iZXIgKyAnfX1cXG4nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWJ1Z0luZm87XG5cbn0se31dLDU1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKSxcbiAgICBjb250ZXh0cyA9IHJlcXVpcmUoXCIuLi9jb250ZXh0c1wiKTtcblxudmFyIERldGFjaGVkUnVsZXNldCA9IGZ1bmN0aW9uIChydWxlc2V0LCBmcmFtZXMpIHtcbiAgICB0aGlzLnJ1bGVzZXQgPSBydWxlc2V0O1xuICAgIHRoaXMuZnJhbWVzID0gZnJhbWVzO1xufTtcbkRldGFjaGVkUnVsZXNldC5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuRGV0YWNoZWRSdWxlc2V0LnByb3RvdHlwZS50eXBlID0gXCJEZXRhY2hlZFJ1bGVzZXRcIjtcbkRldGFjaGVkUnVsZXNldC5wcm90b3R5cGUuZXZhbEZpcnN0ID0gdHJ1ZTtcbkRldGFjaGVkUnVsZXNldC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICB0aGlzLnJ1bGVzZXQgPSB2aXNpdG9yLnZpc2l0KHRoaXMucnVsZXNldCk7XG59O1xuRGV0YWNoZWRSdWxlc2V0LnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXMgfHwgY29udGV4dC5mcmFtZXMuc2xpY2UoMCk7XG4gICAgcmV0dXJuIG5ldyBEZXRhY2hlZFJ1bGVzZXQodGhpcy5ydWxlc2V0LCBmcmFtZXMpO1xufTtcbkRldGFjaGVkUnVsZXNldC5wcm90b3R5cGUuY2FsbEV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzZXQuZXZhbCh0aGlzLmZyYW1lcyA/IG5ldyBjb250ZXh0cy5FdmFsKGNvbnRleHQsIHRoaXMuZnJhbWVzLmNvbmNhdChjb250ZXh0LmZyYW1lcykpIDogY29udGV4dCk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBEZXRhY2hlZFJ1bGVzZXQ7XG5cbn0se1wiLi4vY29udGV4dHNcIjoxMSxcIi4vbm9kZVwiOjcwfV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpLFxuICAgIHVuaXRDb252ZXJzaW9ucyA9IHJlcXVpcmUoXCIuLi9kYXRhL3VuaXQtY29udmVyc2lvbnNcIiksXG4gICAgVW5pdCA9IHJlcXVpcmUoXCIuL3VuaXRcIiksXG4gICAgQ29sb3IgPSByZXF1aXJlKFwiLi9jb2xvclwiKTtcblxuLy9cbi8vIEEgbnVtYmVyIHdpdGggYSB1bml0XG4vL1xudmFyIERpbWVuc2lvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgdW5pdCkge1xuICAgIHRoaXMudmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICB0aGlzLnVuaXQgPSAodW5pdCAmJiB1bml0IGluc3RhbmNlb2YgVW5pdCkgPyB1bml0IDpcbiAgICAgIG5ldyBVbml0KHVuaXQgPyBbdW5pdF0gOiB1bmRlZmluZWQpO1xufTtcblxuRGltZW5zaW9uLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5EaW1lbnNpb24ucHJvdG90eXBlLnR5cGUgPSBcIkRpbWVuc2lvblwiO1xuRGltZW5zaW9uLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgIHRoaXMudW5pdCA9IHZpc2l0b3IudmlzaXQodGhpcy51bml0KTtcbn07XG5EaW1lbnNpb24ucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzO1xufTtcbkRpbWVuc2lvbi5wcm90b3R5cGUudG9Db2xvciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IENvbG9yKFt0aGlzLnZhbHVlLCB0aGlzLnZhbHVlLCB0aGlzLnZhbHVlXSk7XG59O1xuRGltZW5zaW9uLnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgaWYgKChjb250ZXh0ICYmIGNvbnRleHQuc3RyaWN0VW5pdHMpICYmICF0aGlzLnVuaXQuaXNTaW5ndWxhcigpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpcGxlIHVuaXRzIGluIGRpbWVuc2lvbi4gQ29ycmVjdCB0aGUgdW5pdHMgb3IgdXNlIHRoZSB1bml0IGZ1bmN0aW9uLiBCYWQgdW5pdDogXCIgKyB0aGlzLnVuaXQudG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gdGhpcy5mcm91bmQoY29udGV4dCwgdGhpcy52YWx1ZSksXG4gICAgICAgIHN0clZhbHVlID0gU3RyaW5nKHZhbHVlKTtcblxuICAgIGlmICh2YWx1ZSAhPT0gMCAmJiB2YWx1ZSA8IDAuMDAwMDAxICYmIHZhbHVlID4gLTAuMDAwMDAxKSB7XG4gICAgICAgIC8vIHdvdWxkIGJlIG91dHB1dCAxZS02IGV0Yy5cbiAgICAgICAgc3RyVmFsdWUgPSB2YWx1ZS50b0ZpeGVkKDIwKS5yZXBsYWNlKC8wKyQvLCBcIlwiKTtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmNvbXByZXNzKSB7XG4gICAgICAgIC8vIFplcm8gdmFsdWVzIGRvZXNuJ3QgbmVlZCBhIHVuaXRcbiAgICAgICAgaWYgKHZhbHVlID09PSAwICYmIHRoaXMudW5pdC5pc0xlbmd0aCgpKSB7XG4gICAgICAgICAgICBvdXRwdXQuYWRkKHN0clZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZsb2F0IHZhbHVlcyBkb2Vzbid0IG5lZWQgYSBsZWFkaW5nIHplcm9cbiAgICAgICAgaWYgKHZhbHVlID4gMCAmJiB2YWx1ZSA8IDEpIHtcbiAgICAgICAgICAgIHN0clZhbHVlID0gKHN0clZhbHVlKS5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvdXRwdXQuYWRkKHN0clZhbHVlKTtcbiAgICB0aGlzLnVuaXQuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG59O1xuXG4vLyBJbiBhbiBvcGVyYXRpb24gYmV0d2VlbiB0d28gRGltZW5zaW9ucyxcbi8vIHdlIGRlZmF1bHQgdG8gdGhlIGZpcnN0IERpbWVuc2lvbidzIHVuaXQsXG4vLyBzbyBgMXB4ICsgMmAgd2lsbCB5aWVsZCBgM3B4YC5cbkRpbWVuc2lvbi5wcm90b3R5cGUub3BlcmF0ZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBvcCwgb3RoZXIpIHtcbiAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlICovXG4gICAgdmFyIHZhbHVlID0gdGhpcy5fb3BlcmF0ZShjb250ZXh0LCBvcCwgdGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpLFxuICAgICAgICB1bml0ID0gdGhpcy51bml0LmNsb25lKCk7XG5cbiAgICBpZiAob3AgPT09ICcrJyB8fCBvcCA9PT0gJy0nKSB7XG4gICAgICAgIGlmICh1bml0Lm51bWVyYXRvci5sZW5ndGggPT09IDAgJiYgdW5pdC5kZW5vbWluYXRvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHVuaXQgPSBvdGhlci51bml0LmNsb25lKCk7XG4gICAgICAgICAgICBpZiAodGhpcy51bml0LmJhY2t1cFVuaXQpIHtcbiAgICAgICAgICAgICAgICB1bml0LmJhY2t1cFVuaXQgPSB0aGlzLnVuaXQuYmFja3VwVW5pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvdGhlci51bml0Lm51bWVyYXRvci5sZW5ndGggPT09IDAgJiYgdW5pdC5kZW5vbWluYXRvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG90aGVyID0gb3RoZXIuY29udmVydFRvKHRoaXMudW5pdC51c2VkVW5pdHMoKSk7XG5cbiAgICAgICAgICAgIGlmIChjb250ZXh0LnN0cmljdFVuaXRzICYmIG90aGVyLnVuaXQudG9TdHJpbmcoKSAhPT0gdW5pdC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jb21wYXRpYmxlIHVuaXRzLiBDaGFuZ2UgdGhlIHVuaXRzIG9yIHVzZSB0aGUgdW5pdCBmdW5jdGlvbi4gQmFkIHVuaXRzOiAnXCIgKyB1bml0LnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICBcIicgYW5kICdcIiArIG90aGVyLnVuaXQudG9TdHJpbmcoKSArIFwiJy5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fb3BlcmF0ZShjb250ZXh0LCBvcCwgdGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJyonKSB7XG4gICAgICAgIHVuaXQubnVtZXJhdG9yID0gdW5pdC5udW1lcmF0b3IuY29uY2F0KG90aGVyLnVuaXQubnVtZXJhdG9yKS5zb3J0KCk7XG4gICAgICAgIHVuaXQuZGVub21pbmF0b3IgPSB1bml0LmRlbm9taW5hdG9yLmNvbmNhdChvdGhlci51bml0LmRlbm9taW5hdG9yKS5zb3J0KCk7XG4gICAgICAgIHVuaXQuY2FuY2VsKCk7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJy8nKSB7XG4gICAgICAgIHVuaXQubnVtZXJhdG9yID0gdW5pdC5udW1lcmF0b3IuY29uY2F0KG90aGVyLnVuaXQuZGVub21pbmF0b3IpLnNvcnQoKTtcbiAgICAgICAgdW5pdC5kZW5vbWluYXRvciA9IHVuaXQuZGVub21pbmF0b3IuY29uY2F0KG90aGVyLnVuaXQubnVtZXJhdG9yKS5zb3J0KCk7XG4gICAgICAgIHVuaXQuY2FuY2VsKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGltZW5zaW9uKHZhbHVlLCB1bml0KTtcbn07XG5EaW1lbnNpb24ucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICB2YXIgYSwgYjtcblxuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgRGltZW5zaW9uKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnVuaXQuaXNFbXB0eSgpIHx8IG90aGVyLnVuaXQuaXNFbXB0eSgpKSB7XG4gICAgICAgIGEgPSB0aGlzO1xuICAgICAgICBiID0gb3RoZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYSA9IHRoaXMudW5pZnkoKTtcbiAgICAgICAgYiA9IG90aGVyLnVuaWZ5KCk7XG4gICAgICAgIGlmIChhLnVuaXQuY29tcGFyZShiLnVuaXQpICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE5vZGUubnVtZXJpY0NvbXBhcmUoYS52YWx1ZSwgYi52YWx1ZSk7XG59O1xuRGltZW5zaW9uLnByb3RvdHlwZS51bmlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb252ZXJ0VG8oeyBsZW5ndGg6ICdweCcsIGR1cmF0aW9uOiAncycsIGFuZ2xlOiAncmFkJyB9KTtcbn07XG5EaW1lbnNpb24ucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIChjb252ZXJzaW9ucykge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUsIHVuaXQgPSB0aGlzLnVuaXQuY2xvbmUoKSxcbiAgICAgICAgaSwgZ3JvdXBOYW1lLCBncm91cCwgdGFyZ2V0VW5pdCwgZGVyaXZlZENvbnZlcnNpb25zID0ge30sIGFwcGx5VW5pdDtcblxuICAgIGlmICh0eXBlb2YgY29udmVyc2lvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZvciAoaSBpbiB1bml0Q29udmVyc2lvbnMpIHtcbiAgICAgICAgICAgIGlmICh1bml0Q29udmVyc2lvbnNbaV0uaGFzT3duUHJvcGVydHkoY29udmVyc2lvbnMpKSB7XG4gICAgICAgICAgICAgICAgZGVyaXZlZENvbnZlcnNpb25zID0ge307XG4gICAgICAgICAgICAgICAgZGVyaXZlZENvbnZlcnNpb25zW2ldID0gY29udmVyc2lvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udmVyc2lvbnMgPSBkZXJpdmVkQ29udmVyc2lvbnM7XG4gICAgfVxuICAgIGFwcGx5VW5pdCA9IGZ1bmN0aW9uIChhdG9taWNVbml0LCBkZW5vbWluYXRvcikge1xuICAgICAgICAvKiBqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSAqL1xuICAgICAgICBpZiAoZ3JvdXAuaGFzT3duUHJvcGVydHkoYXRvbWljVW5pdCkpIHtcbiAgICAgICAgICAgIGlmIChkZW5vbWluYXRvcikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyAoZ3JvdXBbYXRvbWljVW5pdF0gLyBncm91cFt0YXJnZXRVbml0XSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiAoZ3JvdXBbYXRvbWljVW5pdF0gLyBncm91cFt0YXJnZXRVbml0XSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRVbml0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF0b21pY1VuaXQ7XG4gICAgfTtcblxuICAgIGZvciAoZ3JvdXBOYW1lIGluIGNvbnZlcnNpb25zKSB7XG4gICAgICAgIGlmIChjb252ZXJzaW9ucy5oYXNPd25Qcm9wZXJ0eShncm91cE5hbWUpKSB7XG4gICAgICAgICAgICB0YXJnZXRVbml0ID0gY29udmVyc2lvbnNbZ3JvdXBOYW1lXTtcbiAgICAgICAgICAgIGdyb3VwID0gdW5pdENvbnZlcnNpb25zW2dyb3VwTmFtZV07XG5cbiAgICAgICAgICAgIHVuaXQubWFwKGFwcGx5VW5pdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1bml0LmNhbmNlbCgpO1xuXG4gICAgcmV0dXJuIG5ldyBEaW1lbnNpb24odmFsdWUsIHVuaXQpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gRGltZW5zaW9uO1xuXG59LHtcIi4uL2RhdGEvdW5pdC1jb252ZXJzaW9uc1wiOjE0LFwiLi9jb2xvclwiOjUwLFwiLi9ub2RlXCI6NzAsXCIuL3VuaXRcIjo3OX1dLDU3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKSxcbiAgICBTZWxlY3RvciA9IHJlcXVpcmUoXCIuL3NlbGVjdG9yXCIpLFxuICAgIFJ1bGVzZXQgPSByZXF1aXJlKFwiLi9ydWxlc2V0XCIpO1xuXG52YXIgRGlyZWN0aXZlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBydWxlcywgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgZGVidWdJbmZvLCBpc1Jvb3RlZCwgdmlzaWJpbGl0eUluZm8pIHtcbiAgICB2YXIgaTtcblxuICAgIHRoaXMubmFtZSAgPSBuYW1lO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAocnVsZXMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocnVsZXMpKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJ1bGVzID0gW3J1bGVzXTtcbiAgICAgICAgICAgIHRoaXMucnVsZXNbMF0uc2VsZWN0b3JzID0gKG5ldyBTZWxlY3RvcihbXSwgbnVsbCwgbnVsbCwgdGhpcy5pbmRleCwgY3VycmVudEZpbGVJbmZvKSkuY3JlYXRlRW1wdHlTZWxlY3RvcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5ydWxlc1tpXS5hbGxvd0ltcG9ydHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmN1cnJlbnRGaWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcbiAgICB0aGlzLmRlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICB0aGlzLmlzUm9vdGVkID0gaXNSb290ZWQgfHwgZmFsc2U7XG4gICAgdGhpcy5jb3B5VmlzaWJpbGl0eUluZm8odmlzaWJpbGl0eUluZm8pO1xuICAgIHRoaXMuYWxsb3dSb290ID0gdHJ1ZTtcbn07XG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuRGlyZWN0aXZlLnByb3RvdHlwZS50eXBlID0gXCJEaXJlY3RpdmVcIjtcbkRpcmVjdGl2ZS5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLCBydWxlcyA9IHRoaXMucnVsZXM7XG4gICAgaWYgKHJ1bGVzKSB7XG4gICAgICAgIHRoaXMucnVsZXMgPSB2aXNpdG9yLnZpc2l0QXJyYXkocnVsZXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZpc2l0b3IudmlzaXQodmFsdWUpO1xuICAgIH1cbn07XG5EaXJlY3RpdmUucHJvdG90eXBlLmlzUnVsZXNldExpa2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcyB8fCAhdGhpcy5pc0NoYXJzZXQoKTtcbn07XG5EaXJlY3RpdmUucHJvdG90eXBlLmlzQ2hhcnNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIkBjaGFyc2V0XCIgPT09IHRoaXMubmFtZTtcbn07XG5EaXJlY3RpdmUucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLCBydWxlcyA9IHRoaXMucnVsZXM7XG4gICAgb3V0cHV0LmFkZCh0aGlzLm5hbWUsIHRoaXMuY3VycmVudEZpbGVJbmZvLCB0aGlzLmluZGV4KTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgb3V0cHV0LmFkZCgnICcpO1xuICAgICAgICB2YWx1ZS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbiAgICB9XG4gICAgaWYgKHJ1bGVzKSB7XG4gICAgICAgIHRoaXMub3V0cHV0UnVsZXNldChjb250ZXh0LCBvdXRwdXQsIHJ1bGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQuYWRkKCc7Jyk7XG4gICAgfVxufTtcbkRpcmVjdGl2ZS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIG1lZGlhUGF0aEJhY2t1cCwgbWVkaWFCbG9ja3NCYWNrdXAsIHZhbHVlID0gdGhpcy52YWx1ZSwgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuXG4gICAgLy9tZWRpYSBzdG9yZWQgaW5zaWRlIG90aGVyIGRpcmVjdGl2ZSBzaG91bGQgbm90IGJ1YmJsZSBvdmVyIGl0XG4gICAgLy9iYWNrcHVwIG1lZGlhIGJ1YmJsaW5nIGluZm9ybWF0aW9uXG4gICAgbWVkaWFQYXRoQmFja3VwID0gY29udGV4dC5tZWRpYVBhdGg7XG4gICAgbWVkaWFCbG9ja3NCYWNrdXAgPSBjb250ZXh0Lm1lZGlhQmxvY2tzO1xuICAgIC8vZGVsZXRlZCBtZWRpYSBidWJibGluZyBpbmZvcm1hdGlvblxuICAgIGNvbnRleHQubWVkaWFQYXRoID0gW107XG4gICAgY29udGV4dC5tZWRpYUJsb2NrcyA9IFtdO1xuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuZXZhbChjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKHJ1bGVzKSB7XG4gICAgICAgIC8vIGFzc3VtaW5nIHRoYXQgdGhlcmUgaXMgb25seSBvbmUgcnVsZSBhdCB0aGlzIHBvaW50IC0gdGhhdCBpcyBob3cgcGFyc2VyIGNvbnN0cnVjdHMgdGhlIHJ1bGVcbiAgICAgICAgcnVsZXMgPSBbcnVsZXNbMF0uZXZhbChjb250ZXh0KV07XG4gICAgICAgIHJ1bGVzWzBdLnJvb3QgPSB0cnVlO1xuICAgIH1cbiAgICAvL3Jlc3RvcmUgbWVkaWEgYnViYmxpbmcgaW5mb3JtYXRpb25cbiAgICBjb250ZXh0Lm1lZGlhUGF0aCA9IG1lZGlhUGF0aEJhY2t1cDtcbiAgICBjb250ZXh0Lm1lZGlhQmxvY2tzID0gbWVkaWFCbG9ja3NCYWNrdXA7XG5cbiAgICByZXR1cm4gbmV3IERpcmVjdGl2ZSh0aGlzLm5hbWUsIHZhbHVlLCBydWxlcyxcbiAgICAgICAgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8sIHRoaXMuZGVidWdJbmZvLCB0aGlzLmlzUm9vdGVkLCB0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xufTtcbkRpcmVjdGl2ZS5wcm90b3R5cGUudmFyaWFibGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh0aGlzLnJ1bGVzKSB7XG4gICAgICAgIC8vIGFzc3VtaW5nIHRoYXQgdGhlcmUgaXMgb25seSBvbmUgcnVsZSBhdCB0aGlzIHBvaW50IC0gdGhhdCBpcyBob3cgcGFyc2VyIGNvbnN0cnVjdHMgdGhlIHJ1bGVcbiAgICAgICAgcmV0dXJuIFJ1bGVzZXQucHJvdG90eXBlLnZhcmlhYmxlLmNhbGwodGhpcy5ydWxlc1swXSwgbmFtZSk7XG4gICAgfVxufTtcbkRpcmVjdGl2ZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5ydWxlcykge1xuICAgICAgICAvLyBhc3N1bWluZyB0aGF0IHRoZXJlIGlzIG9ubHkgb25lIHJ1bGUgYXQgdGhpcyBwb2ludCAtIHRoYXQgaXMgaG93IHBhcnNlciBjb25zdHJ1Y3RzIHRoZSBydWxlXG4gICAgICAgIHJldHVybiBSdWxlc2V0LnByb3RvdHlwZS5maW5kLmFwcGx5KHRoaXMucnVsZXNbMF0sIGFyZ3VtZW50cyk7XG4gICAgfVxufTtcbkRpcmVjdGl2ZS5wcm90b3R5cGUucnVsZXNldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucnVsZXMpIHtcbiAgICAgICAgLy8gYXNzdW1pbmcgdGhhdCB0aGVyZSBpcyBvbmx5IG9uZSBydWxlIGF0IHRoaXMgcG9pbnQgLSB0aGF0IGlzIGhvdyBwYXJzZXIgY29uc3RydWN0cyB0aGUgcnVsZVxuICAgICAgICByZXR1cm4gUnVsZXNldC5wcm90b3R5cGUucnVsZXNldHMuYXBwbHkodGhpcy5ydWxlc1swXSk7XG4gICAgfVxufTtcbkRpcmVjdGl2ZS5wcm90b3R5cGUub3V0cHV0UnVsZXNldCA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQsIHJ1bGVzKSB7XG4gICAgdmFyIHJ1bGVDbnQgPSBydWxlcy5sZW5ndGgsIGk7XG4gICAgY29udGV4dC50YWJMZXZlbCA9IChjb250ZXh0LnRhYkxldmVsIHwgMCkgKyAxO1xuXG4gICAgLy8gQ29tcHJlc3NlZFxuICAgIGlmIChjb250ZXh0LmNvbXByZXNzKSB7XG4gICAgICAgIG91dHB1dC5hZGQoJ3snKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJ1bGVDbnQ7IGkrKykge1xuICAgICAgICAgICAgcnVsZXNbaV0uZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LmFkZCgnfScpO1xuICAgICAgICBjb250ZXh0LnRhYkxldmVsLS07XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOb24tY29tcHJlc3NlZFxuICAgIHZhciB0YWJTZXRTdHIgPSAnXFxuJyArIEFycmF5KGNvbnRleHQudGFiTGV2ZWwpLmpvaW4oXCIgIFwiKSwgdGFiUnVsZVN0ciA9IHRhYlNldFN0ciArIFwiICBcIjtcbiAgICBpZiAoIXJ1bGVDbnQpIHtcbiAgICAgICAgb3V0cHV0LmFkZChcIiB7XCIgKyB0YWJTZXRTdHIgKyAnfScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5hZGQoXCIge1wiICsgdGFiUnVsZVN0cik7XG4gICAgICAgIHJ1bGVzWzBdLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcnVsZUNudDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQuYWRkKHRhYlJ1bGVTdHIpO1xuICAgICAgICAgICAgcnVsZXNbaV0uZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LmFkZCh0YWJTZXRTdHIgKyAnfScpO1xuICAgIH1cblxuICAgIGNvbnRleHQudGFiTGV2ZWwtLTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERpcmVjdGl2ZTtcblxufSx7XCIuL25vZGVcIjo3MCxcIi4vcnVsZXNldFwiOjc2LFwiLi9zZWxlY3RvclwiOjc3fV0sNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpLFxuICAgIFBhcmVuID0gcmVxdWlyZShcIi4vcGFyZW5cIiksXG4gICAgQ29tYmluYXRvciA9IHJlcXVpcmUoXCIuL2NvbWJpbmF0b3JcIik7XG5cbnZhciBFbGVtZW50ID0gZnVuY3Rpb24gKGNvbWJpbmF0b3IsIHZhbHVlLCBpbmRleCwgY3VycmVudEZpbGVJbmZvLCBpbmZvKSB7XG4gICAgdGhpcy5jb21iaW5hdG9yID0gY29tYmluYXRvciBpbnN0YW5jZW9mIENvbWJpbmF0b3IgP1xuICAgICAgICAgICAgICAgICAgICAgIGNvbWJpbmF0b3IgOiBuZXcgQ29tYmluYXRvcihjb21iaW5hdG9yKTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgfVxuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmN1cnJlbnRGaWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcbiAgICB0aGlzLmNvcHlWaXNpYmlsaXR5SW5mbyhpbmZvKTtcbn07XG5FbGVtZW50LnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5FbGVtZW50LnByb3RvdHlwZS50eXBlID0gXCJFbGVtZW50XCI7XG5FbGVtZW50LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgdGhpcy5jb21iaW5hdG9yID0gdmlzaXRvci52aXNpdCh0aGlzLmNvbWJpbmF0b3IpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZpc2l0b3IudmlzaXQodmFsdWUpO1xuICAgIH1cbn07XG5FbGVtZW50LnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IEVsZW1lbnQodGhpcy5jb21iaW5hdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmV2YWwgPyB0aGlzLnZhbHVlLmV2YWwoY29udGV4dCkgOiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGaWxlSW5mbywgdGhpcy52aXNpYmlsaXR5SW5mbygpKTtcbn07XG5FbGVtZW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEVsZW1lbnQodGhpcy5jb21iaW5hdG9yLFxuICAgICAgICB0aGlzLnZhbHVlLFxuICAgICAgICB0aGlzLmluZGV4LFxuICAgICAgICB0aGlzLmN1cnJlbnRGaWxlSW5mbywgdGhpcy52aXNpYmlsaXR5SW5mbygpKTtcbn07XG5FbGVtZW50LnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgb3V0cHV0LmFkZCh0aGlzLnRvQ1NTKGNvbnRleHQpLCB0aGlzLmN1cnJlbnRGaWxlSW5mbywgdGhpcy5pbmRleCk7XG59O1xuRWxlbWVudC5wcm90b3R5cGUudG9DU1MgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHt9O1xuICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUsIGZpcnN0U2VsZWN0b3IgPSBjb250ZXh0LmZpcnN0U2VsZWN0b3I7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUGFyZW4pIHtcbiAgICAgICAgLy8gc2VsZWN0b3IgaW4gcGFyZW5zIHNob3VsZCBub3QgYmUgYWZmZWN0ZWQgYnkgb3V0ZXIgc2VsZWN0b3JcbiAgICAgICAgLy8gZmxhZ3MgKGJyZWFrcyBvbmx5IGludGVycG9sYXRlZCBzZWxlY3RvcnMgLSBzZWUgIzE5NzMpXG4gICAgICAgIGNvbnRleHQuZmlyc3RTZWxlY3RvciA9IHRydWU7XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWUudG9DU1MgPyB2YWx1ZS50b0NTUyhjb250ZXh0KSA6IHZhbHVlO1xuICAgIGNvbnRleHQuZmlyc3RTZWxlY3RvciA9IGZpcnN0U2VsZWN0b3I7XG4gICAgaWYgKHZhbHVlID09PSAnJyAmJiB0aGlzLmNvbWJpbmF0b3IudmFsdWUuY2hhckF0KDApID09PSAnJicpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbWJpbmF0b3IudG9DU1MoY29udGV4dCkgKyB2YWx1ZTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50O1xuXG59LHtcIi4vY29tYmluYXRvclwiOjUxLFwiLi9ub2RlXCI6NzAsXCIuL3BhcmVuXCI6NzJ9XSw1OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIiksXG4gICAgUGFyZW4gPSByZXF1aXJlKFwiLi9wYXJlblwiKSxcbiAgICBDb21tZW50ID0gcmVxdWlyZShcIi4vY29tbWVudFwiKTtcblxudmFyIEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHByZXNzaW9uIHJlcXVpcmVzIGFuIGFycmF5IHBhcmFtZXRlclwiKTtcbiAgICB9XG59O1xuRXhwcmVzc2lvbi5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuRXhwcmVzc2lvbi5wcm90b3R5cGUudHlwZSA9IFwiRXhwcmVzc2lvblwiO1xuRXhwcmVzc2lvbi5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICB0aGlzLnZhbHVlID0gdmlzaXRvci52aXNpdEFycmF5KHRoaXMudmFsdWUpO1xufTtcbkV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciByZXR1cm5WYWx1ZSxcbiAgICAgICAgaW5QYXJlbnRoZXNpcyA9IHRoaXMucGFyZW5zICYmICF0aGlzLnBhcmVuc0luT3AsXG4gICAgICAgIGRvdWJsZVBhcmVuID0gZmFsc2U7XG4gICAgaWYgKGluUGFyZW50aGVzaXMpIHtcbiAgICAgICAgY29udGV4dC5pblBhcmVudGhlc2lzKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBuZXcgRXhwcmVzc2lvbih0aGlzLnZhbHVlLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuZXZhbChjb250ZXh0KTtcbiAgICAgICAgfSkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy52YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVbMF0ucGFyZW5zICYmICF0aGlzLnZhbHVlWzBdLnBhcmVuc0luT3ApIHtcbiAgICAgICAgICAgIGRvdWJsZVBhcmVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5WYWx1ZSA9IHRoaXMudmFsdWVbMF0uZXZhbChjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm5WYWx1ZSA9IHRoaXM7XG4gICAgfVxuICAgIGlmIChpblBhcmVudGhlc2lzKSB7XG4gICAgICAgIGNvbnRleHQub3V0T2ZQYXJlbnRoZXNpcygpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnMgJiYgdGhpcy5wYXJlbnNJbk9wICYmICEoY29udGV4dC5pc01hdGhPbigpKSAmJiAhZG91YmxlUGFyZW4pIHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBuZXcgUGFyZW4ocmV0dXJuVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG59O1xuRXhwcmVzc2lvbi5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnZhbHVlW2ldLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuICAgICAgICBpZiAoaSArIDEgPCB0aGlzLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgb3V0cHV0LmFkZChcIiBcIik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuRXhwcmVzc2lvbi5wcm90b3R5cGUudGhyb3dBd2F5Q29tbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuZmlsdGVyKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuICEodiBpbnN0YW5jZW9mIENvbW1lbnQpO1xuICAgIH0pO1xufTtcbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbjtcblxufSx7XCIuL2NvbW1lbnRcIjo1MixcIi4vbm9kZVwiOjcwLFwiLi9wYXJlblwiOjcyfV0sNjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpLFxuICAgIFNlbGVjdG9yID0gcmVxdWlyZShcIi4vc2VsZWN0b3JcIik7XG5cbnZhciBFeHRlbmQgPSBmdW5jdGlvbiBFeHRlbmQoc2VsZWN0b3IsIG9wdGlvbiwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgdmlzaWJpbGl0eUluZm8pIHtcbiAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgdGhpcy5vcHRpb24gPSBvcHRpb247XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMub2JqZWN0X2lkID0gRXh0ZW5kLm5leHRfaWQrKztcbiAgICB0aGlzLnBhcmVudF9pZHMgPSBbdGhpcy5vYmplY3RfaWRdO1xuICAgIHRoaXMuY3VycmVudEZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvIHx8IHt9O1xuICAgIHRoaXMuY29weVZpc2liaWxpdHlJbmZvKHZpc2liaWxpdHlJbmZvKTtcbiAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XG5cbiAgICBzd2l0Y2gob3B0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJhbGxcIjpcbiAgICAgICAgICAgIHRoaXMuYWxsb3dCZWZvcmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hbGxvd0FmdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5hbGxvd0JlZm9yZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hbGxvd0FmdGVyID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuRXh0ZW5kLm5leHRfaWQgPSAwO1xuXG5FeHRlbmQucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcbkV4dGVuZC5wcm90b3R5cGUudHlwZSA9IFwiRXh0ZW5kXCI7XG5FeHRlbmQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgdGhpcy5zZWxlY3RvciA9IHZpc2l0b3IudmlzaXQodGhpcy5zZWxlY3Rvcik7XG59O1xuRXh0ZW5kLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IEV4dGVuZCh0aGlzLnNlbGVjdG9yLmV2YWwoY29udGV4dCksIHRoaXMub3B0aW9uLCB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbywgdGhpcy52aXNpYmlsaXR5SW5mbygpKTtcbn07XG5FeHRlbmQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IEV4dGVuZCh0aGlzLnNlbGVjdG9yLCB0aGlzLm9wdGlvbiwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8sIHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XG59O1xuLy9pdCBjb25jYXRlbmF0ZXMgKGpvaW5zKSBhbGwgc2VsZWN0b3JzIGluIHNlbGVjdG9yIGFycmF5XG5FeHRlbmQucHJvdG90eXBlLmZpbmRTZWxmU2VsZWN0b3JzID0gZnVuY3Rpb24gKHNlbGVjdG9ycykge1xuICAgIHZhciBzZWxmRWxlbWVudHMgPSBbXSxcbiAgICAgICAgaSxcbiAgICAgICAgc2VsZWN0b3JFbGVtZW50cztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZWN0b3JFbGVtZW50cyA9IHNlbGVjdG9yc1tpXS5lbGVtZW50cztcbiAgICAgICAgLy8gZHVwbGljYXRlIHRoZSBsb2dpYyBpbiBnZW5DU1MgZnVuY3Rpb24gaW5zaWRlIHRoZSBzZWxlY3RvciBub2RlLlxuICAgICAgICAvLyBmdXR1cmUgVE9ETyAtIG1vdmUgYm90aCBsb2dpY3MgaW50byB0aGUgc2VsZWN0b3Igam9pbmVyIHZpc2l0b3JcbiAgICAgICAgaWYgKGkgPiAwICYmIHNlbGVjdG9yRWxlbWVudHMubGVuZ3RoICYmIHNlbGVjdG9yRWxlbWVudHNbMF0uY29tYmluYXRvci52YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgc2VsZWN0b3JFbGVtZW50c1swXS5jb21iaW5hdG9yLnZhbHVlID0gJyAnO1xuICAgICAgICB9XG4gICAgICAgIHNlbGZFbGVtZW50cyA9IHNlbGZFbGVtZW50cy5jb25jYXQoc2VsZWN0b3JzW2ldLmVsZW1lbnRzKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlbGZTZWxlY3RvcnMgPSBbbmV3IFNlbGVjdG9yKHNlbGZFbGVtZW50cyldO1xuICAgIHRoaXMuc2VsZlNlbGVjdG9yc1swXS5jb3B5VmlzaWJpbGl0eUluZm8odGhpcy52aXNpYmlsaXR5SW5mbygpKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IEV4dGVuZDtcblxufSx7XCIuL25vZGVcIjo3MCxcIi4vc2VsZWN0b3JcIjo3N31dLDYxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKSxcbiAgICBNZWRpYSA9IHJlcXVpcmUoXCIuL21lZGlhXCIpLFxuICAgIFVSTCA9IHJlcXVpcmUoXCIuL3VybFwiKSxcbiAgICBRdW90ZWQgPSByZXF1aXJlKFwiLi9xdW90ZWRcIiksXG4gICAgUnVsZXNldCA9IHJlcXVpcmUoXCIuL3J1bGVzZXRcIiksXG4gICAgQW5vbnltb3VzID0gcmVxdWlyZShcIi4vYW5vbnltb3VzXCIpO1xuXG4vL1xuLy8gQ1NTIEBpbXBvcnQgbm9kZVxuLy9cbi8vIFRoZSBnZW5lcmFsIHN0cmF0ZWd5IGhlcmUgaXMgdGhhdCB3ZSBkb24ndCB3YW50IHRvIHdhaXRcbi8vIGZvciB0aGUgcGFyc2luZyB0byBiZSBjb21wbGV0ZWQsIGJlZm9yZSB3ZSBzdGFydCBpbXBvcnRpbmdcbi8vIHRoZSBmaWxlLiBUaGF0J3MgYmVjYXVzZSBpbiB0aGUgY29udGV4dCBvZiBhIGJyb3dzZXIsXG4vLyBtb3N0IG9mIHRoZSB0aW1lIHdpbGwgYmUgc3BlbnQgd2FpdGluZyBmb3IgdGhlIHNlcnZlciB0byByZXNwb25kLlxuLy9cbi8vIE9uIGNyZWF0aW9uLCB3ZSBwdXNoIHRoZSBpbXBvcnQgcGF0aCB0byBvdXIgaW1wb3J0IHF1ZXVlLCB0aG91Z2hcbi8vIGBpbXBvcnQscHVzaGAsIHdlIGFsc28gcGFzcyBpdCBhIGNhbGxiYWNrLCB3aGljaCBpdCdsbCBjYWxsIG9uY2Vcbi8vIHRoZSBmaWxlIGhhcyBiZWVuIGZldGNoZWQsIGFuZCBwYXJzZWQuXG4vL1xudmFyIEltcG9ydCA9IGZ1bmN0aW9uIChwYXRoLCBmZWF0dXJlcywgb3B0aW9ucywgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgdmlzaWJpbGl0eUluZm8pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlcztcbiAgICB0aGlzLmN1cnJlbnRGaWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcbiAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxlc3MgIT09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMuaW5saW5lKSB7XG4gICAgICAgIHRoaXMuY3NzID0gIXRoaXMub3B0aW9ucy5sZXNzIHx8IHRoaXMub3B0aW9ucy5pbmxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBhdGhWYWx1ZSA9IHRoaXMuZ2V0UGF0aCgpO1xuICAgICAgICBpZiAocGF0aFZhbHVlICYmIC9bI1xcLlxcJlxcP1xcL11jc3MoW1xcPztdLiopPyQvLnRlc3QocGF0aFZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5jc3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29weVZpc2liaWxpdHlJbmZvKHZpc2liaWxpdHlJbmZvKTtcbn07XG5cbi8vXG4vLyBUaGUgYWN0dWFsIGltcG9ydCBub2RlIGRvZXNuJ3QgcmV0dXJuIGFueXRoaW5nLCB3aGVuIGNvbnZlcnRlZCB0byBDU1MuXG4vLyBUaGUgcmVhc29uIGlzIHRoYXQgaXQncyB1c2VkIGF0IHRoZSBldmFsdWF0aW9uIHN0YWdlLCBzbyB0aGF0IHRoZSBydWxlc1xuLy8gaXQgaW1wb3J0cyBjYW4gYmUgdHJlYXRlZCBsaWtlIGFueSBvdGhlciBydWxlcy5cbi8vXG4vLyBJbiBgZXZhbGAsIHdlIG1ha2Ugc3VyZSBhbGwgSW1wb3J0IG5vZGVzIGdldCBldmFsdWF0ZWQsIHJlY3Vyc2l2ZWx5LCBzb1xuLy8gd2UgZW5kIHVwIHdpdGggYSBmbGF0IHN0cnVjdHVyZSwgd2hpY2ggY2FuIGVhc2lseSBiZSBpbXBvcnRlZCBpbiB0aGUgcGFyZW50XG4vLyBydWxlc2V0LlxuLy9cbkltcG9ydC5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuSW1wb3J0LnByb3RvdHlwZS50eXBlID0gXCJJbXBvcnRcIjtcbkltcG9ydC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICBpZiAodGhpcy5mZWF0dXJlcykge1xuICAgICAgICB0aGlzLmZlYXR1cmVzID0gdmlzaXRvci52aXNpdCh0aGlzLmZlYXR1cmVzKTtcbiAgICB9XG4gICAgdGhpcy5wYXRoID0gdmlzaXRvci52aXNpdCh0aGlzLnBhdGgpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnBsdWdpbiAmJiAhdGhpcy5vcHRpb25zLmlubGluZSAmJiB0aGlzLnJvb3QpIHtcbiAgICAgICAgdGhpcy5yb290ID0gdmlzaXRvci52aXNpdCh0aGlzLnJvb3QpO1xuICAgIH1cbn07XG5JbXBvcnQucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICBpZiAodGhpcy5jc3MgJiYgdGhpcy5wYXRoLmN1cnJlbnRGaWxlSW5mby5yZWZlcmVuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXRwdXQuYWRkKFwiQGltcG9ydCBcIiwgdGhpcy5jdXJyZW50RmlsZUluZm8sIHRoaXMuaW5kZXgpO1xuICAgICAgICB0aGlzLnBhdGguZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVzKSB7XG4gICAgICAgICAgICBvdXRwdXQuYWRkKFwiIFwiKTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXMuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LmFkZCgnOycpO1xuICAgIH1cbn07XG5JbXBvcnQucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnBhdGggaW5zdGFuY2VvZiBVUkwpID9cbiAgICAgICAgdGhpcy5wYXRoLnZhbHVlLnZhbHVlIDogdGhpcy5wYXRoLnZhbHVlO1xufTtcbkltcG9ydC5wcm90b3R5cGUuaXNWYXJpYWJsZUltcG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICBwYXRoID0gcGF0aC52YWx1ZTtcbiAgICB9XG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBRdW90ZWQpIHtcbiAgICAgICAgcmV0dXJuIHBhdGguY29udGFpbnNWYXJpYWJsZXMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5JbXBvcnQucHJvdG90eXBlLmV2YWxGb3JJbXBvcnQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuXG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgcGF0aCA9IHBhdGgudmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBJbXBvcnQocGF0aC5ldmFsKGNvbnRleHQpLCB0aGlzLmZlYXR1cmVzLCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvLCB0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xufTtcbkltcG9ydC5wcm90b3R5cGUuZXZhbFBhdGggPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoLmV2YWwoY29udGV4dCk7XG4gICAgdmFyIHJvb3RwYXRoID0gdGhpcy5jdXJyZW50RmlsZUluZm8gJiYgdGhpcy5jdXJyZW50RmlsZUluZm8ucm9vdHBhdGg7XG5cbiAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICBpZiAocm9vdHBhdGgpIHtcbiAgICAgICAgICAgIHZhciBwYXRoVmFsdWUgPSBwYXRoLnZhbHVlO1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBiYXNlIHBhdGggaWYgdGhlIGltcG9ydCBpcyByZWxhdGl2ZVxuICAgICAgICAgICAgaWYgKHBhdGhWYWx1ZSAmJiBjb250ZXh0LmlzUGF0aFJlbGF0aXZlKHBhdGhWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnZhbHVlID0gcm9vdHBhdGggKyBwYXRoVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGF0aC52YWx1ZSA9IGNvbnRleHQubm9ybWFsaXplUGF0aChwYXRoLnZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbn07XG5JbXBvcnQucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmRvRXZhbChjb250ZXh0KTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlZmVyZW5jZSB8fCB0aGlzLmJsb2Nrc1Zpc2liaWxpdHkoKSkge1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCB8fCByZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmFkZFZpc2liaWxpdHlCbG9jaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkVmlzaWJpbGl0eUJsb2NrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5JbXBvcnQucHJvdG90eXBlLmRvRXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIHJ1bGVzZXQsIHJlZ2lzdHJ5LFxuICAgICAgICBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXMgJiYgdGhpcy5mZWF0dXJlcy5ldmFsKGNvbnRleHQpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wbHVnaW4pIHtcbiAgICAgICAgcmVnaXN0cnkgPSBjb250ZXh0LmZyYW1lc1swXSAmJiBjb250ZXh0LmZyYW1lc1swXS5mdW5jdGlvblJlZ2lzdHJ5O1xuICAgICAgICBpZiAoIHJlZ2lzdHJ5ICYmIHRoaXMucm9vdCAmJiB0aGlzLnJvb3QuZnVuY3Rpb25zICkge1xuICAgICAgICAgICAgcmVnaXN0cnkuYWRkTXVsdGlwbGUoIHRoaXMucm9vdC5mdW5jdGlvbnMgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2tpcCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2tpcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLnNraXAgPSB0aGlzLnNraXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5za2lwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pbmxpbmUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnRzID0gbmV3IEFub255bW91cyh0aGlzLnJvb3QsIDAsXG4gICAgICAgICAge1xuICAgICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5pbXBvcnRlZEZpbGVuYW1lLFxuICAgICAgICAgICAgICByZWZlcmVuY2U6IHRoaXMucGF0aC5jdXJyZW50RmlsZUluZm8gJiYgdGhpcy5wYXRoLmN1cnJlbnRGaWxlSW5mby5yZWZlcmVuY2VcbiAgICAgICAgICB9LCB0cnVlLCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlcyA/IG5ldyBNZWRpYShbY29udGVudHNdLCB0aGlzLmZlYXR1cmVzLnZhbHVlKSA6IFtjb250ZW50c107XG4gICAgfSBlbHNlIGlmICh0aGlzLmNzcykge1xuICAgICAgICB2YXIgbmV3SW1wb3J0ID0gbmV3IEltcG9ydCh0aGlzLmV2YWxQYXRoKGNvbnRleHQpLCBmZWF0dXJlcywgdGhpcy5vcHRpb25zLCB0aGlzLmluZGV4KTtcbiAgICAgICAgaWYgKCFuZXdJbXBvcnQuY3NzICYmIHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0ltcG9ydDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBydWxlc2V0ID0gbmV3IFJ1bGVzZXQobnVsbCwgdGhpcy5yb290LnJ1bGVzLnNsaWNlKDApKTtcbiAgICAgICAgcnVsZXNldC5ldmFsSW1wb3J0cyhjb250ZXh0KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlcyA/IG5ldyBNZWRpYShydWxlc2V0LnJ1bGVzLCB0aGlzLmZlYXR1cmVzLnZhbHVlKSA6IHJ1bGVzZXQucnVsZXM7XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gSW1wb3J0O1xuXG59LHtcIi4vYW5vbnltb3VzXCI6NDYsXCIuL21lZGlhXCI6NjYsXCIuL25vZGVcIjo3MCxcIi4vcXVvdGVkXCI6NzMsXCIuL3J1bGVzZXRcIjo3NixcIi4vdXJsXCI6ODB9XSw2MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdHJlZSA9IHt9O1xuXG50cmVlLk5vZGUgPSByZXF1aXJlKCcuL25vZGUnKTtcbnRyZWUuQWxwaGEgPSByZXF1aXJlKCcuL2FscGhhJyk7XG50cmVlLkNvbG9yID0gcmVxdWlyZSgnLi9jb2xvcicpO1xudHJlZS5EaXJlY3RpdmUgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZScpO1xudHJlZS5EZXRhY2hlZFJ1bGVzZXQgPSByZXF1aXJlKCcuL2RldGFjaGVkLXJ1bGVzZXQnKTtcbnRyZWUuT3BlcmF0aW9uID0gcmVxdWlyZSgnLi9vcGVyYXRpb24nKTtcbnRyZWUuRGltZW5zaW9uID0gcmVxdWlyZSgnLi9kaW1lbnNpb24nKTtcbnRyZWUuVW5pdCA9IHJlcXVpcmUoJy4vdW5pdCcpO1xudHJlZS5LZXl3b3JkID0gcmVxdWlyZSgnLi9rZXl3b3JkJyk7XG50cmVlLlZhcmlhYmxlID0gcmVxdWlyZSgnLi92YXJpYWJsZScpO1xudHJlZS5SdWxlc2V0ID0gcmVxdWlyZSgnLi9ydWxlc2V0Jyk7XG50cmVlLkVsZW1lbnQgPSByZXF1aXJlKCcuL2VsZW1lbnQnKTtcbnRyZWUuQXR0cmlidXRlID0gcmVxdWlyZSgnLi9hdHRyaWJ1dGUnKTtcbnRyZWUuQ29tYmluYXRvciA9IHJlcXVpcmUoJy4vY29tYmluYXRvcicpO1xudHJlZS5TZWxlY3RvciA9IHJlcXVpcmUoJy4vc2VsZWN0b3InKTtcbnRyZWUuUXVvdGVkID0gcmVxdWlyZSgnLi9xdW90ZWQnKTtcbnRyZWUuRXhwcmVzc2lvbiA9IHJlcXVpcmUoJy4vZXhwcmVzc2lvbicpO1xudHJlZS5SdWxlID0gcmVxdWlyZSgnLi9ydWxlJyk7XG50cmVlLkNhbGwgPSByZXF1aXJlKCcuL2NhbGwnKTtcbnRyZWUuVVJMID0gcmVxdWlyZSgnLi91cmwnKTtcbnRyZWUuSW1wb3J0ID0gcmVxdWlyZSgnLi9pbXBvcnQnKTtcbnRyZWUubWl4aW4gPSB7XG4gICAgQ2FsbDogcmVxdWlyZSgnLi9taXhpbi1jYWxsJyksXG4gICAgRGVmaW5pdGlvbjogcmVxdWlyZSgnLi9taXhpbi1kZWZpbml0aW9uJylcbn07XG50cmVlLkNvbW1lbnQgPSByZXF1aXJlKCcuL2NvbW1lbnQnKTtcbnRyZWUuQW5vbnltb3VzID0gcmVxdWlyZSgnLi9hbm9ueW1vdXMnKTtcbnRyZWUuVmFsdWUgPSByZXF1aXJlKCcuL3ZhbHVlJyk7XG50cmVlLkphdmFTY3JpcHQgPSByZXF1aXJlKCcuL2phdmFzY3JpcHQnKTtcbnRyZWUuQXNzaWdubWVudCA9IHJlcXVpcmUoJy4vYXNzaWdubWVudCcpO1xudHJlZS5Db25kaXRpb24gPSByZXF1aXJlKCcuL2NvbmRpdGlvbicpO1xudHJlZS5QYXJlbiA9IHJlcXVpcmUoJy4vcGFyZW4nKTtcbnRyZWUuTWVkaWEgPSByZXF1aXJlKCcuL21lZGlhJyk7XG50cmVlLlVuaWNvZGVEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi91bmljb2RlLWRlc2NyaXB0b3InKTtcbnRyZWUuTmVnYXRpdmUgPSByZXF1aXJlKCcuL25lZ2F0aXZlJyk7XG50cmVlLkV4dGVuZCA9IHJlcXVpcmUoJy4vZXh0ZW5kJyk7XG50cmVlLlJ1bGVzZXRDYWxsID0gcmVxdWlyZSgnLi9ydWxlc2V0LWNhbGwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0cmVlO1xuXG59LHtcIi4vYWxwaGFcIjo0NSxcIi4vYW5vbnltb3VzXCI6NDYsXCIuL2Fzc2lnbm1lbnRcIjo0NyxcIi4vYXR0cmlidXRlXCI6NDgsXCIuL2NhbGxcIjo0OSxcIi4vY29sb3JcIjo1MCxcIi4vY29tYmluYXRvclwiOjUxLFwiLi9jb21tZW50XCI6NTIsXCIuL2NvbmRpdGlvblwiOjUzLFwiLi9kZXRhY2hlZC1ydWxlc2V0XCI6NTUsXCIuL2RpbWVuc2lvblwiOjU2LFwiLi9kaXJlY3RpdmVcIjo1NyxcIi4vZWxlbWVudFwiOjU4LFwiLi9leHByZXNzaW9uXCI6NTksXCIuL2V4dGVuZFwiOjYwLFwiLi9pbXBvcnRcIjo2MSxcIi4vamF2YXNjcmlwdFwiOjYzLFwiLi9rZXl3b3JkXCI6NjUsXCIuL21lZGlhXCI6NjYsXCIuL21peGluLWNhbGxcIjo2NyxcIi4vbWl4aW4tZGVmaW5pdGlvblwiOjY4LFwiLi9uZWdhdGl2ZVwiOjY5LFwiLi9ub2RlXCI6NzAsXCIuL29wZXJhdGlvblwiOjcxLFwiLi9wYXJlblwiOjcyLFwiLi9xdW90ZWRcIjo3MyxcIi4vcnVsZVwiOjc0LFwiLi9ydWxlc2V0XCI6NzYsXCIuL3J1bGVzZXQtY2FsbFwiOjc1LFwiLi9zZWxlY3RvclwiOjc3LFwiLi91bmljb2RlLWRlc2NyaXB0b3JcIjo3OCxcIi4vdW5pdFwiOjc5LFwiLi91cmxcIjo4MCxcIi4vdmFsdWVcIjo4MSxcIi4vdmFyaWFibGVcIjo4Mn1dLDYzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBKc0V2YWxOb2RlID0gcmVxdWlyZShcIi4vanMtZXZhbC1ub2RlXCIpLFxuICAgIERpbWVuc2lvbiA9IHJlcXVpcmUoXCIuL2RpbWVuc2lvblwiKSxcbiAgICBRdW90ZWQgPSByZXF1aXJlKFwiLi9xdW90ZWRcIiksXG4gICAgQW5vbnltb3VzID0gcmVxdWlyZShcIi4vYW5vbnltb3VzXCIpO1xuXG52YXIgSmF2YVNjcmlwdCA9IGZ1bmN0aW9uIChzdHJpbmcsIGVzY2FwZWQsIGluZGV4LCBjdXJyZW50RmlsZUluZm8pIHtcbiAgICB0aGlzLmVzY2FwZWQgPSBlc2NhcGVkO1xuICAgIHRoaXMuZXhwcmVzc2lvbiA9IHN0cmluZztcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5jdXJyZW50RmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XG59O1xuSmF2YVNjcmlwdC5wcm90b3R5cGUgPSBuZXcgSnNFdmFsTm9kZSgpO1xuSmF2YVNjcmlwdC5wcm90b3R5cGUudHlwZSA9IFwiSmF2YVNjcmlwdFwiO1xuSmF2YVNjcmlwdC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5ldmFsdWF0ZUphdmFTY3JpcHQodGhpcy5leHByZXNzaW9uLCBjb250ZXh0KTtcblxuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihyZXN1bHQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdW90ZWQoJ1wiJyArIHJlc3VsdCArICdcIicsIHJlc3VsdCwgdGhpcy5lc2NhcGVkLCB0aGlzLmluZGV4KTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gbmV3IEFub255bW91cyhyZXN1bHQuam9pbignLCAnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXMocmVzdWx0KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEphdmFTY3JpcHQ7XG5cbn0se1wiLi9hbm9ueW1vdXNcIjo0NixcIi4vZGltZW5zaW9uXCI6NTYsXCIuL2pzLWV2YWwtbm9kZVwiOjY0LFwiLi9xdW90ZWRcIjo3M31dLDY0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKSxcbiAgICBWYXJpYWJsZSA9IHJlcXVpcmUoXCIuL3ZhcmlhYmxlXCIpO1xuXG52YXIgSnNFdmFsTm9kZSA9IGZ1bmN0aW9uKCkge1xufTtcbkpzRXZhbE5vZGUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblxuSnNFdmFsTm9kZS5wcm90b3R5cGUuZXZhbHVhdGVKYXZhU2NyaXB0ID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0LFxuICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgZXZhbENvbnRleHQgPSB7fTtcblxuICAgIGlmIChjb250ZXh0LmphdmFzY3JpcHRFbmFibGVkICE9PSB1bmRlZmluZWQgJiYgIWNvbnRleHQuamF2YXNjcmlwdEVuYWJsZWQpIHtcbiAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiBcIllvdSBhcmUgdXNpbmcgSmF2YVNjcmlwdCwgd2hpY2ggaGFzIGJlZW4gZGlzYWJsZWQuXCIsXG4gICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5jdXJyZW50RmlsZUluZm8uZmlsZW5hbWUsXG4gICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCB9O1xuICAgIH1cblxuICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnJlcGxhY2UoL0BcXHsoW1xcdy1dKylcXH0vZywgZnVuY3Rpb24gKF8sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoYXQuanNpZnkobmV3IFZhcmlhYmxlKCdAJyArIG5hbWUsIHRoYXQuaW5kZXgsIHRoYXQuY3VycmVudEZpbGVJbmZvKS5ldmFsKGNvbnRleHQpKTtcbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICAgIGV4cHJlc3Npb24gPSBuZXcgRnVuY3Rpb24oJ3JldHVybiAoJyArIGV4cHJlc3Npb24gKyAnKScpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiBcIkphdmFTY3JpcHQgZXZhbHVhdGlvbiBlcnJvcjogXCIgKyBlLm1lc3NhZ2UgKyBcIiBmcm9tIGBcIiArIGV4cHJlc3Npb24gKyBcImBcIiAsXG4gICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5jdXJyZW50RmlsZUluZm8uZmlsZW5hbWUsXG4gICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCB9O1xuICAgIH1cblxuICAgIHZhciB2YXJpYWJsZXMgPSBjb250ZXh0LmZyYW1lc1swXS52YXJpYWJsZXMoKTtcbiAgICBmb3IgKHZhciBrIGluIHZhcmlhYmxlcykge1xuICAgICAgICBpZiAodmFyaWFibGVzLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAvKmpzaGludCBsb29wZnVuYzp0cnVlICovXG4gICAgICAgICAgICBldmFsQ29udGV4dFtrLnNsaWNlKDEpXSA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFyaWFibGVzW2tdLnZhbHVlLFxuICAgICAgICAgICAgICAgIHRvSlM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuZXZhbChjb250ZXh0KS50b0NTUygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBleHByZXNzaW9uLmNhbGwoZXZhbENvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiBcIkphdmFTY3JpcHQgZXZhbHVhdGlvbiBlcnJvcjogJ1wiICsgZS5uYW1lICsgJzogJyArIGUubWVzc2FnZS5yZXBsYWNlKC9bXCJdL2csIFwiJ1wiKSArIFwiJ1wiICxcbiAgICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmN1cnJlbnRGaWxlSW5mby5maWxlbmFtZSxcbiAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4IH07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuSnNFdmFsTm9kZS5wcm90b3R5cGUuanNpZnkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLnZhbHVlKSAmJiAob2JqLnZhbHVlLmxlbmd0aCA+IDEpKSB7XG4gICAgICAgIHJldHVybiAnWycgKyBvYmoudmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LnRvQ1NTKCk7IH0pLmpvaW4oJywgJykgKyAnXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9iai50b0NTUygpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSnNFdmFsTm9kZTtcblxufSx7XCIuL25vZGVcIjo3MCxcIi4vdmFyaWFibGVcIjo4Mn1dLDY1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKTtcblxudmFyIEtleXdvcmQgPSBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy52YWx1ZSA9IHZhbHVlOyB9O1xuS2V5d29yZC5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuS2V5d29yZC5wcm90b3R5cGUudHlwZSA9IFwiS2V5d29yZFwiO1xuS2V5d29yZC5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIGlmICh0aGlzLnZhbHVlID09PSAnJScpIHsgdGhyb3cgeyB0eXBlOiBcIlN5bnRheFwiLCBtZXNzYWdlOiBcIkludmFsaWQgJSB3aXRob3V0IG51bWJlclwiIH07IH1cbiAgICBvdXRwdXQuYWRkKHRoaXMudmFsdWUpO1xufTtcblxuS2V5d29yZC5UcnVlID0gbmV3IEtleXdvcmQoJ3RydWUnKTtcbktleXdvcmQuRmFsc2UgPSBuZXcgS2V5d29yZCgnZmFsc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXl3b3JkO1xuXG59LHtcIi4vbm9kZVwiOjcwfV0sNjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIFJ1bGVzZXQgPSByZXF1aXJlKFwiLi9ydWxlc2V0XCIpLFxuICAgIFZhbHVlID0gcmVxdWlyZShcIi4vdmFsdWVcIiksXG4gICAgU2VsZWN0b3IgPSByZXF1aXJlKFwiLi9zZWxlY3RvclwiKSxcbiAgICBBbm9ueW1vdXMgPSByZXF1aXJlKFwiLi9hbm9ueW1vdXNcIiksXG4gICAgRXhwcmVzc2lvbiA9IHJlcXVpcmUoXCIuL2V4cHJlc3Npb25cIiksXG4gICAgRGlyZWN0aXZlID0gcmVxdWlyZShcIi4vZGlyZWN0aXZlXCIpO1xuXG52YXIgTWVkaWEgPSBmdW5jdGlvbiAodmFsdWUsIGZlYXR1cmVzLCBpbmRleCwgY3VycmVudEZpbGVJbmZvLCB2aXNpYmlsaXR5SW5mbykge1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmN1cnJlbnRGaWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcblxuICAgIHZhciBzZWxlY3RvcnMgPSAobmV3IFNlbGVjdG9yKFtdLCBudWxsLCBudWxsLCB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbykpLmNyZWF0ZUVtcHR5U2VsZWN0b3JzKCk7XG5cbiAgICB0aGlzLmZlYXR1cmVzID0gbmV3IFZhbHVlKGZlYXR1cmVzKTtcbiAgICB0aGlzLnJ1bGVzID0gW25ldyBSdWxlc2V0KHNlbGVjdG9ycywgdmFsdWUpXTtcbiAgICB0aGlzLnJ1bGVzWzBdLmFsbG93SW1wb3J0cyA9IHRydWU7XG4gICAgdGhpcy5jb3B5VmlzaWJpbGl0eUluZm8odmlzaWJpbGl0eUluZm8pO1xuICAgIHRoaXMuYWxsb3dSb290ID0gdHJ1ZTtcbn07XG5NZWRpYS5wcm90b3R5cGUgPSBuZXcgRGlyZWN0aXZlKCk7XG5NZWRpYS5wcm90b3R5cGUudHlwZSA9IFwiTWVkaWFcIjtcbk1lZGlhLnByb3RvdHlwZS5pc1J1bGVzZXRMaWtlID0gdHJ1ZTtcbk1lZGlhLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgIGlmICh0aGlzLmZlYXR1cmVzKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSB2aXNpdG9yLnZpc2l0KHRoaXMuZmVhdHVyZXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5ydWxlcykge1xuICAgICAgICB0aGlzLnJ1bGVzID0gdmlzaXRvci52aXNpdEFycmF5KHRoaXMucnVsZXMpO1xuICAgIH1cbn07XG5NZWRpYS5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIG91dHB1dC5hZGQoJ0BtZWRpYSAnLCB0aGlzLmN1cnJlbnRGaWxlSW5mbywgdGhpcy5pbmRleCk7XG4gICAgdGhpcy5mZWF0dXJlcy5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbiAgICB0aGlzLm91dHB1dFJ1bGVzZXQoY29udGV4dCwgb3V0cHV0LCB0aGlzLnJ1bGVzKTtcbn07XG5NZWRpYS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKCFjb250ZXh0Lm1lZGlhQmxvY2tzKSB7XG4gICAgICAgIGNvbnRleHQubWVkaWFCbG9ja3MgPSBbXTtcbiAgICAgICAgY29udGV4dC5tZWRpYVBhdGggPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgbWVkaWEgPSBuZXcgTWVkaWEobnVsbCwgW10sIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvLCB0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xuICAgIGlmICh0aGlzLmRlYnVnSW5mbykge1xuICAgICAgICB0aGlzLnJ1bGVzWzBdLmRlYnVnSW5mbyA9IHRoaXMuZGVidWdJbmZvO1xuICAgICAgICBtZWRpYS5kZWJ1Z0luZm8gPSB0aGlzLmRlYnVnSW5mbztcbiAgICB9XG4gICAgdmFyIHN0cmljdE1hdGhCeXBhc3MgPSBmYWxzZTtcbiAgICBpZiAoIWNvbnRleHQuc3RyaWN0TWF0aCkge1xuICAgICAgICBzdHJpY3RNYXRoQnlwYXNzID0gdHJ1ZTtcbiAgICAgICAgY29udGV4dC5zdHJpY3RNYXRoID0gdHJ1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgbWVkaWEuZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzLmV2YWwoY29udGV4dCk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBpZiAoc3RyaWN0TWF0aEJ5cGFzcykge1xuICAgICAgICAgICAgY29udGV4dC5zdHJpY3RNYXRoID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb250ZXh0Lm1lZGlhUGF0aC5wdXNoKG1lZGlhKTtcbiAgICBjb250ZXh0Lm1lZGlhQmxvY2tzLnB1c2gobWVkaWEpO1xuXG4gICAgdGhpcy5ydWxlc1swXS5mdW5jdGlvblJlZ2lzdHJ5ID0gY29udGV4dC5mcmFtZXNbMF0uZnVuY3Rpb25SZWdpc3RyeS5pbmhlcml0KCk7XG4gICAgY29udGV4dC5mcmFtZXMudW5zaGlmdCh0aGlzLnJ1bGVzWzBdKTtcbiAgICBtZWRpYS5ydWxlcyA9IFt0aGlzLnJ1bGVzWzBdLmV2YWwoY29udGV4dCldO1xuICAgIGNvbnRleHQuZnJhbWVzLnNoaWZ0KCk7XG5cbiAgICBjb250ZXh0Lm1lZGlhUGF0aC5wb3AoKTtcblxuICAgIHJldHVybiBjb250ZXh0Lm1lZGlhUGF0aC5sZW5ndGggPT09IDAgPyBtZWRpYS5ldmFsVG9wKGNvbnRleHQpIDpcbiAgICAgICAgICAgICAgICBtZWRpYS5ldmFsTmVzdGVkKGNvbnRleHQpO1xufTtcbk1lZGlhLnByb3RvdHlwZS5ldmFsVG9wID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcztcblxuICAgIC8vIFJlbmRlciBhbGwgZGVwZW5kZW50IE1lZGlhIGJsb2Nrcy5cbiAgICBpZiAoY29udGV4dC5tZWRpYUJsb2Nrcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBzZWxlY3RvcnMgPSAobmV3IFNlbGVjdG9yKFtdLCBudWxsLCBudWxsLCB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbykpLmNyZWF0ZUVtcHR5U2VsZWN0b3JzKCk7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBSdWxlc2V0KHNlbGVjdG9ycywgY29udGV4dC5tZWRpYUJsb2Nrcyk7XG4gICAgICAgIHJlc3VsdC5tdWx0aU1lZGlhID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0LmNvcHlWaXNpYmlsaXR5SW5mbyh0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBjb250ZXh0Lm1lZGlhQmxvY2tzO1xuICAgIGRlbGV0ZSBjb250ZXh0Lm1lZGlhUGF0aDtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuTWVkaWEucHJvdG90eXBlLmV2YWxOZXN0ZWQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBpLCB2YWx1ZSxcbiAgICAgICAgcGF0aCA9IGNvbnRleHQubWVkaWFQYXRoLmNvbmNhdChbdGhpc10pO1xuXG4gICAgLy8gRXh0cmFjdCB0aGUgbWVkaWEtcXVlcnkgY29uZGl0aW9ucyBzZXBhcmF0ZWQgd2l0aCBgLGAgKE9SKS5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IHBhdGhbaV0uZmVhdHVyZXMgaW5zdGFuY2VvZiBWYWx1ZSA/XG4gICAgICAgICAgICAgICAgICAgIHBhdGhbaV0uZmVhdHVyZXMudmFsdWUgOiBwYXRoW2ldLmZlYXR1cmVzO1xuICAgICAgICBwYXRoW2ldID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgfVxuXG4gICAgLy8gVHJhY2UgYWxsIHBlcm11dGF0aW9ucyB0byBnZW5lcmF0ZSB0aGUgcmVzdWx0aW5nIG1lZGlhLXF1ZXJ5LlxuICAgIC8vXG4gICAgLy8gKGEsIGIgYW5kIGMpIHdpdGggbmVzdGVkIChkLCBlKSAtPlxuICAgIC8vICAgIGEgYW5kIGRcbiAgICAvLyAgICBhIGFuZCBlXG4gICAgLy8gICAgYiBhbmQgYyBhbmQgZFxuICAgIC8vICAgIGIgYW5kIGMgYW5kIGVcbiAgICB0aGlzLmZlYXR1cmVzID0gbmV3IFZhbHVlKHRoaXMucGVybXV0ZShwYXRoKS5tYXAoZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcGF0aCA9IHBhdGgubWFwKGZ1bmN0aW9uIChmcmFnbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50LnRvQ1NTID8gZnJhZ21lbnQgOiBuZXcgQW5vbnltb3VzKGZyYWdtZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBwYXRoLnNwbGljZShpLCAwLCBuZXcgQW5vbnltb3VzKFwiYW5kXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbihwYXRoKTtcbiAgICB9KSk7XG5cbiAgICAvLyBGYWtlIGEgdHJlZS1ub2RlIHRoYXQgZG9lc24ndCBvdXRwdXQgYW55dGhpbmcuXG4gICAgcmV0dXJuIG5ldyBSdWxlc2V0KFtdLCBbXSk7XG59O1xuTWVkaWEucHJvdG90eXBlLnBlcm11dGUgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSBpZiAoYXJyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYXJyWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnBlcm11dGUoYXJyLnNsaWNlKDEpKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFyclswXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFthcnJbMF1bal1dLmNvbmNhdChyZXN0W2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuTWVkaWEucHJvdG90eXBlLmJ1YmJsZVNlbGVjdG9ycyA9IGZ1bmN0aW9uIChzZWxlY3RvcnMpIHtcbiAgICBpZiAoIXNlbGVjdG9ycykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucnVsZXMgPSBbbmV3IFJ1bGVzZXQoc2VsZWN0b3JzLnNsaWNlKDApLCBbdGhpcy5ydWxlc1swXV0pXTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IE1lZGlhO1xuXG59LHtcIi4vYW5vbnltb3VzXCI6NDYsXCIuL2RpcmVjdGl2ZVwiOjU3LFwiLi9leHByZXNzaW9uXCI6NTksXCIuL3J1bGVzZXRcIjo3NixcIi4vc2VsZWN0b3JcIjo3NyxcIi4vdmFsdWVcIjo4MX1dLDY3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKSxcbiAgICBTZWxlY3RvciA9IHJlcXVpcmUoXCIuL3NlbGVjdG9yXCIpLFxuICAgIE1peGluRGVmaW5pdGlvbiA9IHJlcXVpcmUoXCIuL21peGluLWRlZmluaXRpb25cIiksXG4gICAgZGVmYXVsdEZ1bmMgPSByZXF1aXJlKFwiLi4vZnVuY3Rpb25zL2RlZmF1bHRcIik7XG5cbnZhciBNaXhpbkNhbGwgPSBmdW5jdGlvbiAoZWxlbWVudHMsIGFyZ3MsIGluZGV4LCBjdXJyZW50RmlsZUluZm8sIGltcG9ydGFudCkge1xuICAgIHRoaXMuc2VsZWN0b3IgPSBuZXcgU2VsZWN0b3IoZWxlbWVudHMpO1xuICAgIHRoaXMuYXJndW1lbnRzID0gYXJncyB8fCBbXTtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5jdXJyZW50RmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XG4gICAgdGhpcy5pbXBvcnRhbnQgPSBpbXBvcnRhbnQ7XG4gICAgdGhpcy5hbGxvd1Jvb3QgPSB0cnVlO1xufTtcbk1peGluQ2FsbC5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuTWl4aW5DYWxsLnByb3RvdHlwZS50eXBlID0gXCJNaXhpbkNhbGxcIjtcbk1peGluQ2FsbC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rvcikge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gdmlzaXRvci52aXNpdCh0aGlzLnNlbGVjdG9yKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLmFyZ3VtZW50cyk7XG4gICAgfVxufTtcbk1peGluQ2FsbC5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIG1peGlucywgbWl4aW4sIG1peGluUGF0aCwgYXJncyA9IFtdLCBhcmcsIGFyZ1ZhbHVlLFxuICAgICAgICBydWxlcyA9IFtdLCBtYXRjaCA9IGZhbHNlLCBpLCBtLCBmLCBpc1JlY3Vyc2l2ZSwgaXNPbmVGb3VuZCxcbiAgICAgICAgY2FuZGlkYXRlcyA9IFtdLCBjYW5kaWRhdGUsIGNvbmRpdGlvblJlc3VsdCA9IFtdLCBkZWZhdWx0UmVzdWx0LCBkZWZGYWxzZUVpdGhlckNhc2UgPSAtMSxcbiAgICAgICAgZGVmTm9uZSA9IDAsIGRlZlRydWUgPSAxLCBkZWZGYWxzZSA9IDIsIGNvdW50LCBvcmlnaW5hbFJ1bGVzZXQsIG5vQXJndW1lbnRzRmlsdGVyO1xuXG4gICAgZnVuY3Rpb24gY2FsY0RlZkdyb3VwKG1peGluLCBtaXhpblBhdGgpIHtcbiAgICAgICAgdmFyIGYsIHAsIG5hbWVzcGFjZTtcblxuICAgICAgICBmb3IgKGYgPSAwOyBmIDwgMjsgZisrKSB7XG4gICAgICAgICAgICBjb25kaXRpb25SZXN1bHRbZl0gPSB0cnVlO1xuICAgICAgICAgICAgZGVmYXVsdEZ1bmMudmFsdWUoZik7XG4gICAgICAgICAgICBmb3IgKHAgPSAwOyBwIDwgbWl4aW5QYXRoLmxlbmd0aCAmJiBjb25kaXRpb25SZXN1bHRbZl07IHArKykge1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZSA9IG1peGluUGF0aFtwXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZXNwYWNlLm1hdGNoQ29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvblJlc3VsdFtmXSA9IGNvbmRpdGlvblJlc3VsdFtmXSAmJiBuYW1lc3BhY2UubWF0Y2hDb25kaXRpb24obnVsbCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1peGluLm1hdGNoQ29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0W2ZdID0gY29uZGl0aW9uUmVzdWx0W2ZdICYmIG1peGluLm1hdGNoQ29uZGl0aW9uKGFyZ3MsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25kaXRpb25SZXN1bHRbMF0gfHwgY29uZGl0aW9uUmVzdWx0WzFdKSB7XG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uUmVzdWx0WzBdICE9IGNvbmRpdGlvblJlc3VsdFsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25kaXRpb25SZXN1bHRbMV0gP1xuICAgICAgICAgICAgICAgICAgICBkZWZUcnVlIDogZGVmRmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkZWZOb25lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZGYWxzZUVpdGhlckNhc2U7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZyA9IHRoaXMuYXJndW1lbnRzW2ldO1xuICAgICAgICBhcmdWYWx1ZSA9IGFyZy52YWx1ZS5ldmFsKGNvbnRleHQpO1xuICAgICAgICBpZiAoYXJnLmV4cGFuZCAmJiBBcnJheS5pc0FycmF5KGFyZ1ZhbHVlLnZhbHVlKSkge1xuICAgICAgICAgICAgYXJnVmFsdWUgPSBhcmdWYWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIGZvciAobSA9IDA7IG0gPCBhcmdWYWx1ZS5sZW5ndGg7IG0rKykge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh7dmFsdWU6IGFyZ1ZhbHVlW21dfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goe25hbWU6IGFyZy5uYW1lLCB2YWx1ZTogYXJnVmFsdWV9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5vQXJndW1lbnRzRmlsdGVyID0gZnVuY3Rpb24ocnVsZSkge3JldHVybiBydWxlLm1hdGNoQXJncyhudWxsLCBjb250ZXh0KTt9O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvbnRleHQuZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgobWl4aW5zID0gY29udGV4dC5mcmFtZXNbaV0uZmluZCh0aGlzLnNlbGVjdG9yLCBudWxsLCBub0FyZ3VtZW50c0ZpbHRlcikpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlzT25lRm91bmQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBUbyBtYWtlIGBkZWZhdWx0KClgIGZ1bmN0aW9uIGluZGVwZW5kZW50IG9mIGRlZmluaXRpb24gb3JkZXIgd2UgaGF2ZSB0d28gXCJzdWJwYXNzZXNcIiBoZXJlLlxuICAgICAgICAgICAgLy8gQXQgZmlyc3Qgd2UgZXZhbHVhdGUgZWFjaCBndWFyZCAqdHdpY2UqICh3aXRoIGBkZWZhdWx0KCkgPT0gdHJ1ZWAgYW5kIGBkZWZhdWx0KCkgPT0gZmFsc2VgKSxcbiAgICAgICAgICAgIC8vIGFuZCBidWlsZCBjYW5kaWRhdGUgbGlzdCB3aXRoIGNvcnJlc3BvbmRpbmcgZmxhZ3MuIFRoZW4sIHdoZW4gd2Uga25vdyBhbGwgcG9zc2libGUgbWF0Y2hlcyxcbiAgICAgICAgICAgIC8vIHdlIG1ha2UgYSBmaW5hbCBkZWNpc2lvbi5cblxuICAgICAgICAgICAgZm9yIChtID0gMDsgbSA8IG1peGlucy5sZW5ndGg7IG0rKykge1xuICAgICAgICAgICAgICAgIG1peGluID0gbWl4aW5zW21dLnJ1bGU7XG4gICAgICAgICAgICAgICAgbWl4aW5QYXRoID0gbWl4aW5zW21dLnBhdGg7XG4gICAgICAgICAgICAgICAgaXNSZWN1cnNpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGYgPSAwOyBmIDwgY29udGV4dC5mcmFtZXMubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCghKG1peGluIGluc3RhbmNlb2YgTWl4aW5EZWZpbml0aW9uKSkgJiYgbWl4aW4gPT09IChjb250ZXh0LmZyYW1lc1tmXS5vcmlnaW5hbFJ1bGVzZXQgfHwgY29udGV4dC5mcmFtZXNbZl0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1JlY3Vyc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNSZWN1cnNpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1peGluLm1hdGNoQXJncyhhcmdzLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGUgPSB7bWl4aW46IG1peGluLCBncm91cDogY2FsY0RlZkdyb3VwKG1peGluLCBtaXhpblBhdGgpfTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlLmdyb3VwICE9PSBkZWZGYWxzZUVpdGhlckNhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaChjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmYXVsdEZ1bmMucmVzZXQoKTtcblxuICAgICAgICAgICAgY291bnQgPSBbMCwgMCwgMF07XG4gICAgICAgICAgICBmb3IgKG0gPSAwOyBtIDwgY2FuZGlkYXRlcy5sZW5ndGg7IG0rKykge1xuICAgICAgICAgICAgICAgIGNvdW50W2NhbmRpZGF0ZXNbbV0uZ3JvdXBdKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb3VudFtkZWZOb25lXSA+IDApIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0UmVzdWx0ID0gZGVmRmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRSZXN1bHQgPSBkZWZUcnVlO1xuICAgICAgICAgICAgICAgIGlmICgoY291bnRbZGVmVHJ1ZV0gKyBjb3VudFtkZWZGYWxzZV0pID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7IHR5cGU6ICdSdW50aW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdBbWJpZ3VvdXMgdXNlIG9mIGBkZWZhdWx0KClgIGZvdW5kIHdoZW4gbWF0Y2hpbmcgZm9yIGAnICsgdGhpcy5mb3JtYXQoYXJncykgKyAnYCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCwgZmlsZW5hbWU6IHRoaXMuY3VycmVudEZpbGVJbmZvLmZpbGVuYW1lIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKG0gPSAwOyBtIDwgY2FuZGlkYXRlcy5sZW5ndGg7IG0rKykge1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbbV0uZ3JvdXA7XG4gICAgICAgICAgICAgICAgaWYgKChjYW5kaWRhdGUgPT09IGRlZk5vbmUpIHx8IChjYW5kaWRhdGUgPT09IGRlZmF1bHRSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaXhpbiA9IGNhbmRpZGF0ZXNbbV0ubWl4aW47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtaXhpbiBpbnN0YW5jZW9mIE1peGluRGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFJ1bGVzZXQgPSBtaXhpbi5vcmlnaW5hbFJ1bGVzZXQgfHwgbWl4aW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWl4aW4gPSBuZXcgTWl4aW5EZWZpbml0aW9uKFwiXCIsIFtdLCBtaXhpbi5ydWxlcywgbnVsbCwgZmFsc2UsIG51bGwsIG9yaWdpbmFsUnVsZXNldC52aXNpYmlsaXR5SW5mbygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXhpbi5vcmlnaW5hbFJ1bGVzZXQgPSBvcmlnaW5hbFJ1bGVzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UnVsZXMgPSBtaXhpbi5ldmFsQ2FsbChjb250ZXh0LCBhcmdzLCB0aGlzLmltcG9ydGFudCkucnVsZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRWaXNpYmlsaXR5VG9SZXBsYWNlbWVudChuZXdSdWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShydWxlcywgbmV3UnVsZXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7IG1lc3NhZ2U6IGUubWVzc2FnZSwgaW5kZXg6IHRoaXMuaW5kZXgsIGZpbGVuYW1lOiB0aGlzLmN1cnJlbnRGaWxlSW5mby5maWxlbmFtZSwgc3RhY2s6IGUuc3RhY2sgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc09uZUZvdW5kKSB7XG4gICAgICAgIHRocm93IHsgdHlwZTogICAgJ1J1bnRpbWUnLFxuICAgICAgICAgICAgbWVzc2FnZTogJ05vIG1hdGNoaW5nIGRlZmluaXRpb24gd2FzIGZvdW5kIGZvciBgJyArIHRoaXMuZm9ybWF0KGFyZ3MpICsgJ2AnLFxuICAgICAgICAgICAgaW5kZXg6ICAgdGhpcy5pbmRleCwgZmlsZW5hbWU6IHRoaXMuY3VycmVudEZpbGVJbmZvLmZpbGVuYW1lIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgeyB0eXBlOiAgICAnTmFtZScsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLnNlbGVjdG9yLnRvQ1NTKCkudHJpbSgpICsgXCIgaXMgdW5kZWZpbmVkXCIsXG4gICAgICAgICAgICBpbmRleDogICB0aGlzLmluZGV4LCBmaWxlbmFtZTogdGhpcy5jdXJyZW50RmlsZUluZm8uZmlsZW5hbWUgfTtcbiAgICB9XG59O1xuXG5NaXhpbkNhbGwucHJvdG90eXBlLl9zZXRWaXNpYmlsaXR5VG9SZXBsYWNlbWVudCA9IGZ1bmN0aW9uIChyZXBsYWNlbWVudCkge1xuICAgIHZhciBpLCBydWxlO1xuICAgIGlmICh0aGlzLmJsb2Nrc1Zpc2liaWxpdHkoKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVwbGFjZW1lbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJ1bGUgPSByZXBsYWNlbWVudFtpXTtcbiAgICAgICAgICAgIHJ1bGUuYWRkVmlzaWJpbGl0eUJsb2NrKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuTWl4aW5DYWxsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdG9yLnRvQ1NTKCkudHJpbSgpICsgJygnICtcbiAgICAgICAgKGFyZ3MgPyBhcmdzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgdmFyIGFyZ1ZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChhLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBhcmdWYWx1ZSArPSBhLm5hbWUgKyBcIjpcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhLnZhbHVlLnRvQ1NTKSB7XG4gICAgICAgICAgICAgICAgYXJnVmFsdWUgKz0gYS52YWx1ZS50b0NTUygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdWYWx1ZSArPSBcIj8/P1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZ1ZhbHVlO1xuICAgICAgICB9KS5qb2luKCcsICcpIDogXCJcIikgKyBcIilcIjtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IE1peGluQ2FsbDtcblxufSx7XCIuLi9mdW5jdGlvbnMvZGVmYXVsdFwiOjIwLFwiLi9taXhpbi1kZWZpbml0aW9uXCI6NjgsXCIuL25vZGVcIjo3MCxcIi4vc2VsZWN0b3JcIjo3N31dLDY4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBTZWxlY3RvciA9IHJlcXVpcmUoXCIuL3NlbGVjdG9yXCIpLFxuICAgIEVsZW1lbnQgPSByZXF1aXJlKFwiLi9lbGVtZW50XCIpLFxuICAgIFJ1bGVzZXQgPSByZXF1aXJlKFwiLi9ydWxlc2V0XCIpLFxuICAgIFJ1bGUgPSByZXF1aXJlKFwiLi9ydWxlXCIpLFxuICAgIEV4cHJlc3Npb24gPSByZXF1aXJlKFwiLi9leHByZXNzaW9uXCIpLFxuICAgIGNvbnRleHRzID0gcmVxdWlyZShcIi4uL2NvbnRleHRzXCIpO1xuXG52YXIgRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCBwYXJhbXMsIHJ1bGVzLCBjb25kaXRpb24sIHZhcmlhZGljLCBmcmFtZXMsIHZpc2liaWxpdHlJbmZvKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnNlbGVjdG9ycyA9IFtuZXcgU2VsZWN0b3IoW25ldyBFbGVtZW50KG51bGwsIG5hbWUsIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvKV0pXTtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICB0aGlzLnZhcmlhZGljID0gdmFyaWFkaWM7XG4gICAgdGhpcy5hcml0eSA9IHBhcmFtcy5sZW5ndGg7XG4gICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgIHRoaXMuX2xvb2t1cHMgPSB7fTtcbiAgICB2YXIgb3B0aW9uYWxQYXJhbWV0ZXJzID0gW107XG4gICAgdGhpcy5yZXF1aXJlZCA9IHBhcmFtcy5yZWR1Y2UoZnVuY3Rpb24gKGNvdW50LCBwKSB7XG4gICAgICAgIGlmICghcC5uYW1lIHx8IChwLm5hbWUgJiYgIXAudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gY291bnQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9uYWxQYXJhbWV0ZXJzLnB1c2gocC5uYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgfVxuICAgIH0sIDApO1xuICAgIHRoaXMub3B0aW9uYWxQYXJhbWV0ZXJzID0gb3B0aW9uYWxQYXJhbWV0ZXJzO1xuICAgIHRoaXMuZnJhbWVzID0gZnJhbWVzO1xuICAgIHRoaXMuY29weVZpc2liaWxpdHlJbmZvKHZpc2liaWxpdHlJbmZvKTtcbiAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XG59O1xuRGVmaW5pdGlvbi5wcm90b3R5cGUgPSBuZXcgUnVsZXNldCgpO1xuRGVmaW5pdGlvbi5wcm90b3R5cGUudHlwZSA9IFwiTWl4aW5EZWZpbml0aW9uXCI7XG5EZWZpbml0aW9uLnByb3RvdHlwZS5ldmFsRmlyc3QgPSB0cnVlO1xuRGVmaW5pdGlvbi5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICBpZiAodGhpcy5wYXJhbXMgJiYgdGhpcy5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucGFyYW1zID0gdmlzaXRvci52aXNpdEFycmF5KHRoaXMucGFyYW1zKTtcbiAgICB9XG4gICAgdGhpcy5ydWxlcyA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLnJ1bGVzKTtcbiAgICBpZiAodGhpcy5jb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSB2aXNpdG9yLnZpc2l0KHRoaXMuY29uZGl0aW9uKTtcbiAgICB9XG59O1xuRGVmaW5pdGlvbi5wcm90b3R5cGUuZXZhbFBhcmFtcyA9IGZ1bmN0aW9uIChjb250ZXh0LCBtaXhpbkVudiwgYXJncywgZXZhbGRBcmd1bWVudHMpIHtcbiAgICAvKmpzaGludCBib3NzOnRydWUgKi9cbiAgICB2YXIgZnJhbWUgPSBuZXcgUnVsZXNldChudWxsLCBudWxsKSxcbiAgICAgICAgdmFyYXJncywgYXJnLFxuICAgICAgICBwYXJhbXMgPSB0aGlzLnBhcmFtcy5zbGljZSgwKSxcbiAgICAgICAgaSwgaiwgdmFsLCBuYW1lLCBpc05hbWVkRm91bmQsIGFyZ0luZGV4LCBhcmdzTGVuZ3RoID0gMDtcblxuICAgIGlmIChtaXhpbkVudi5mcmFtZXMgJiYgbWl4aW5FbnYuZnJhbWVzWzBdICYmIG1peGluRW52LmZyYW1lc1swXS5mdW5jdGlvblJlZ2lzdHJ5KSB7XG4gICAgICAgIGZyYW1lLmZ1bmN0aW9uUmVnaXN0cnkgPSBtaXhpbkVudi5mcmFtZXNbMF0uZnVuY3Rpb25SZWdpc3RyeS5pbmhlcml0KCk7XG4gICAgfVxuICAgIG1peGluRW52ID0gbmV3IGNvbnRleHRzLkV2YWwobWl4aW5FbnYsIFtmcmFtZV0uY29uY2F0KG1peGluRW52LmZyYW1lcykpO1xuXG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgYXJncyA9IGFyZ3Muc2xpY2UoMCk7XG4gICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmcgPSBhcmdzW2ldO1xuICAgICAgICAgICAgaWYgKG5hbWUgPSAoYXJnICYmIGFyZy5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGlzTmFtZWRGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwYXJhbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmFsZEFyZ3VtZW50c1tqXSAmJiBuYW1lID09PSBwYXJhbXNbal0ubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZhbGRBcmd1bWVudHNbal0gPSBhcmcudmFsdWUuZXZhbChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLnByZXBlbmRSdWxlKG5ldyBSdWxlKG5hbWUsIGFyZy52YWx1ZS5ldmFsKGNvbnRleHQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc05hbWVkRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFtZWRGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7IHR5cGU6ICdSdW50aW1lJywgbWVzc2FnZTogXCJOYW1lZCBhcmd1bWVudCBmb3IgXCIgKyB0aGlzLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAnICsgYXJnc1tpXS5uYW1lICsgJyBub3QgZm91bmQnIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFyZ0luZGV4ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChldmFsZEFyZ3VtZW50c1tpXSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgIGFyZyA9IGFyZ3MgJiYgYXJnc1thcmdJbmRleF07XG5cbiAgICAgICAgaWYgKG5hbWUgPSBwYXJhbXNbaV0ubmFtZSkge1xuICAgICAgICAgICAgaWYgKHBhcmFtc1tpXS52YXJpYWRpYykge1xuICAgICAgICAgICAgICAgIHZhcmFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBhcmdJbmRleDsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXJhcmdzLnB1c2goYXJnc1tqXS52YWx1ZS5ldmFsKGNvbnRleHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnJhbWUucHJlcGVuZFJ1bGUobmV3IFJ1bGUobmFtZSwgbmV3IEV4cHJlc3Npb24odmFyYXJncykuZXZhbChjb250ZXh0KSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBhcmcgJiYgYXJnLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsLmV2YWwoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbXNbaV0udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyYW1zW2ldLnZhbHVlLmV2YWwobWl4aW5FbnYpO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZS5yZXNldENhY2hlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnUnVudGltZScsIG1lc3NhZ2U6IFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgXCIgKyB0aGlzLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAoJyArIGFyZ3NMZW5ndGggKyAnIGZvciAnICsgdGhpcy5hcml0eSArICcpJyB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZyYW1lLnByZXBlbmRSdWxlKG5ldyBSdWxlKG5hbWUsIHZhbCkpO1xuICAgICAgICAgICAgICAgIGV2YWxkQXJndW1lbnRzW2ldID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtc1tpXS52YXJpYWRpYyAmJiBhcmdzKSB7XG4gICAgICAgICAgICBmb3IgKGogPSBhcmdJbmRleDsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGV2YWxkQXJndW1lbnRzW2pdID0gYXJnc1tqXS52YWx1ZS5ldmFsKGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFyZ0luZGV4Kys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYW1lO1xufTtcbkRlZmluaXRpb24ucHJvdG90eXBlLm1ha2VJbXBvcnRhbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcnVsZXMgPSAhdGhpcy5ydWxlcyA/IHRoaXMucnVsZXMgOiB0aGlzLnJ1bGVzLm1hcChmdW5jdGlvbiAocikge1xuICAgICAgICBpZiAoci5tYWtlSW1wb3J0YW50KSB7XG4gICAgICAgICAgICByZXR1cm4gci5tYWtlSW1wb3J0YW50KHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IERlZmluaXRpb24odGhpcy5uYW1lLCB0aGlzLnBhcmFtcywgcnVsZXMsIHRoaXMuY29uZGl0aW9uLCB0aGlzLnZhcmlhZGljLCB0aGlzLmZyYW1lcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5EZWZpbml0aW9uLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IERlZmluaXRpb24odGhpcy5uYW1lLCB0aGlzLnBhcmFtcywgdGhpcy5ydWxlcywgdGhpcy5jb25kaXRpb24sIHRoaXMudmFyaWFkaWMsIHRoaXMuZnJhbWVzIHx8IGNvbnRleHQuZnJhbWVzLnNsaWNlKDApKTtcbn07XG5EZWZpbml0aW9uLnByb3RvdHlwZS5ldmFsQ2FsbCA9IGZ1bmN0aW9uIChjb250ZXh0LCBhcmdzLCBpbXBvcnRhbnQpIHtcbiAgICB2YXIgX2FyZ3VtZW50cyA9IFtdLFxuICAgICAgICBtaXhpbkZyYW1lcyA9IHRoaXMuZnJhbWVzID8gdGhpcy5mcmFtZXMuY29uY2F0KGNvbnRleHQuZnJhbWVzKSA6IGNvbnRleHQuZnJhbWVzLFxuICAgICAgICBmcmFtZSA9IHRoaXMuZXZhbFBhcmFtcyhjb250ZXh0LCBuZXcgY29udGV4dHMuRXZhbChjb250ZXh0LCBtaXhpbkZyYW1lcyksIGFyZ3MsIF9hcmd1bWVudHMpLFxuICAgICAgICBydWxlcywgcnVsZXNldDtcblxuICAgIGZyYW1lLnByZXBlbmRSdWxlKG5ldyBSdWxlKCdAYXJndW1lbnRzJywgbmV3IEV4cHJlc3Npb24oX2FyZ3VtZW50cykuZXZhbChjb250ZXh0KSkpO1xuXG4gICAgcnVsZXMgPSB0aGlzLnJ1bGVzLnNsaWNlKDApO1xuXG4gICAgcnVsZXNldCA9IG5ldyBSdWxlc2V0KG51bGwsIHJ1bGVzKTtcbiAgICBydWxlc2V0Lm9yaWdpbmFsUnVsZXNldCA9IHRoaXM7XG4gICAgcnVsZXNldCA9IHJ1bGVzZXQuZXZhbChuZXcgY29udGV4dHMuRXZhbChjb250ZXh0LCBbdGhpcywgZnJhbWVdLmNvbmNhdChtaXhpbkZyYW1lcykpKTtcbiAgICBpZiAoaW1wb3J0YW50KSB7XG4gICAgICAgIHJ1bGVzZXQgPSBydWxlc2V0Lm1ha2VJbXBvcnRhbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bGVzZXQ7XG59O1xuRGVmaW5pdGlvbi5wcm90b3R5cGUubWF0Y2hDb25kaXRpb24gPSBmdW5jdGlvbiAoYXJncywgY29udGV4dCkge1xuICAgIGlmICh0aGlzLmNvbmRpdGlvbiAmJiAhdGhpcy5jb25kaXRpb24uZXZhbChcbiAgICAgICAgbmV3IGNvbnRleHRzLkV2YWwoY29udGV4dCxcbiAgICAgICAgICAgIFt0aGlzLmV2YWxQYXJhbXMoY29udGV4dCwgLyogdGhlIHBhcmFtZXRlciB2YXJpYWJsZXMqL1xuICAgICAgICAgICAgICAgIG5ldyBjb250ZXh0cy5FdmFsKGNvbnRleHQsIHRoaXMuZnJhbWVzID8gdGhpcy5mcmFtZXMuY29uY2F0KGNvbnRleHQuZnJhbWVzKSA6IGNvbnRleHQuZnJhbWVzKSwgYXJncywgW10pXVxuICAgICAgICAgICAgLmNvbmNhdCh0aGlzLmZyYW1lcyB8fCBbXSkgLy8gdGhlIHBhcmVudCBuYW1lc3BhY2UvbWl4aW4gZnJhbWVzXG4gICAgICAgICAgICAuY29uY2F0KGNvbnRleHQuZnJhbWVzKSkpKSB7IC8vIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGZyYW1lc1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbkRlZmluaXRpb24ucHJvdG90eXBlLm1hdGNoQXJncyA9IGZ1bmN0aW9uIChhcmdzLCBjb250ZXh0KSB7XG4gICAgdmFyIGFsbEFyZ3NDbnQgPSAoYXJncyAmJiBhcmdzLmxlbmd0aCkgfHwgMCwgbGVuLCBvcHRpb25hbFBhcmFtZXRlcnMgPSB0aGlzLm9wdGlvbmFsUGFyYW1ldGVycztcbiAgICB2YXIgcmVxdWlyZWRBcmdzQ250ID0gIWFyZ3MgPyAwIDogYXJncy5yZWR1Y2UoZnVuY3Rpb24gKGNvdW50LCBwKSB7XG4gICAgICAgIGlmIChvcHRpb25hbFBhcmFtZXRlcnMuaW5kZXhPZihwLm5hbWUpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50ICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgfVxuICAgIH0sIDApO1xuXG4gICAgaWYgKCEgdGhpcy52YXJpYWRpYykge1xuICAgICAgICBpZiAocmVxdWlyZWRBcmdzQ250IDwgdGhpcy5yZXF1aXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxBcmdzQ250ID4gdGhpcy5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVxdWlyZWRBcmdzQ250IDwgKHRoaXMucmVxdWlyZWQgLSAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgcGF0dGVybnNcbiAgICBsZW4gPSBNYXRoLm1pbihyZXF1aXJlZEFyZ3NDbnQsIHRoaXMuYXJpdHkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMucGFyYW1zW2ldLm5hbWUgJiYgIXRoaXMucGFyYW1zW2ldLnZhcmlhZGljKSB7XG4gICAgICAgICAgICBpZiAoYXJnc1tpXS52YWx1ZS5ldmFsKGNvbnRleHQpLnRvQ1NTKCkgIT0gdGhpcy5wYXJhbXNbaV0udmFsdWUuZXZhbChjb250ZXh0KS50b0NTUygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbm1vZHVsZS5leHBvcnRzID0gRGVmaW5pdGlvbjtcblxufSx7XCIuLi9jb250ZXh0c1wiOjExLFwiLi9lbGVtZW50XCI6NTgsXCIuL2V4cHJlc3Npb25cIjo1OSxcIi4vcnVsZVwiOjc0LFwiLi9ydWxlc2V0XCI6NzYsXCIuL3NlbGVjdG9yXCI6Nzd9XSw2OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIiksXG4gICAgT3BlcmF0aW9uID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpLFxuICAgIERpbWVuc2lvbiA9IHJlcXVpcmUoXCIuL2RpbWVuc2lvblwiKTtcblxudmFyIE5lZ2F0aXZlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB0aGlzLnZhbHVlID0gbm9kZTtcbn07XG5OZWdhdGl2ZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuTmVnYXRpdmUucHJvdG90eXBlLnR5cGUgPSBcIk5lZ2F0aXZlXCI7XG5OZWdhdGl2ZS5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIG91dHB1dC5hZGQoJy0nKTtcbiAgICB0aGlzLnZhbHVlLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xufTtcbk5lZ2F0aXZlLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC5pc01hdGhPbigpKSB7XG4gICAgICAgIHJldHVybiAobmV3IE9wZXJhdGlvbignKicsIFtuZXcgRGltZW5zaW9uKC0xKSwgdGhpcy52YWx1ZV0pKS5ldmFsKGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE5lZ2F0aXZlKHRoaXMudmFsdWUuZXZhbChjb250ZXh0KSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBOZWdhdGl2ZTtcblxufSx7XCIuL2RpbWVuc2lvblwiOjU2LFwiLi9ub2RlXCI6NzAsXCIuL29wZXJhdGlvblwiOjcxfV0sNzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSBmdW5jdGlvbigpIHtcbn07XG5Ob2RlLnByb3RvdHlwZS50b0NTUyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIHN0cnMgPSBbXTtcbiAgICB0aGlzLmdlbkNTUyhjb250ZXh0LCB7XG4gICAgICAgIGFkZDogZnVuY3Rpb24oY2h1bmssIGZpbGVJbmZvLCBpbmRleCkge1xuICAgICAgICAgICAgc3Rycy5wdXNoKGNodW5rKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cnMubGVuZ3RoID09PSAwO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cnMuam9pbignJyk7XG59O1xuTm9kZS5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIG91dHB1dC5hZGQodGhpcy52YWx1ZSk7XG59O1xuTm9kZS5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICB0aGlzLnZhbHVlID0gdmlzaXRvci52aXNpdCh0aGlzLnZhbHVlKTtcbn07XG5Ob2RlLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbk5vZGUucHJvdG90eXBlLl9vcGVyYXRlID0gZnVuY3Rpb24gKGNvbnRleHQsIG9wLCBhLCBiKSB7XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlICcrJzogcmV0dXJuIGEgKyBiO1xuICAgICAgICBjYXNlICctJzogcmV0dXJuIGEgLSBiO1xuICAgICAgICBjYXNlICcqJzogcmV0dXJuIGEgKiBiO1xuICAgICAgICBjYXNlICcvJzogcmV0dXJuIGEgLyBiO1xuICAgIH1cbn07XG5Ob2RlLnByb3RvdHlwZS5mcm91bmQgPSBmdW5jdGlvbihjb250ZXh0LCB2YWx1ZSkge1xuICAgIHZhciBwcmVjaXNpb24gPSBjb250ZXh0ICYmIGNvbnRleHQubnVtUHJlY2lzaW9uO1xuICAgIC8vYWRkIFwiZXBzaWxvblwiIHRvIGVuc3VyZSBudW1iZXJzIGxpa2UgMS4wMDAwMDAwMDUgKHJlcHJlc2VudGVkIGFzIDEuMDAwMDAwMDA0OTk5Li4uLikgYXJlIHByb3Blcmx5IHJvdW5kZWQuLi5cbiAgICByZXR1cm4gKHByZWNpc2lvbiA9PSBudWxsKSA/IHZhbHVlIDogTnVtYmVyKCh2YWx1ZSArIDJlLTE2KS50b0ZpeGVkKHByZWNpc2lvbikpO1xufTtcbk5vZGUuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgLyogcmV0dXJuczpcbiAgICAgLTE6IGEgPCBiXG4gICAgIDA6IGEgPSBiXG4gICAgIDE6IGEgPiBiXG4gICAgIGFuZCAqYW55KiBvdGhlciB2YWx1ZSBmb3IgYSAhPSBiIChlLmcuIHVuZGVmaW5lZCwgTmFOLCAtMiBldGMuKSAqL1xuXG4gICAgaWYgKChhLmNvbXBhcmUpICYmXG4gICAgICAgIC8vIGZvciBcInN5bW1ldHJpYyByZXN1bHRzXCIgZm9yY2UgdG9DU1MtYmFzZWQgY29tcGFyaXNvblxuICAgICAgICAvLyBvZiBRdW90ZWQgb3IgQW5vbnltb3VzIGlmIGVpdGhlciB2YWx1ZSBpcyBvbmUgb2YgdGhvc2VcbiAgICAgICAgIShiLnR5cGUgPT09IFwiUXVvdGVkXCIgfHwgYi50eXBlID09PSBcIkFub255bW91c1wiKSkge1xuICAgICAgICByZXR1cm4gYS5jb21wYXJlKGIpO1xuICAgIH0gZWxzZSBpZiAoYi5jb21wYXJlKSB7XG4gICAgICAgIHJldHVybiAtYi5jb21wYXJlKGEpO1xuICAgIH0gZWxzZSBpZiAoYS50eXBlICE9PSBiLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBhID0gYS52YWx1ZTtcbiAgICBiID0gYi52YWx1ZTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGIgPyAwIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoTm9kZS5jb21wYXJlKGFbaV0sIGJbaV0pICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcblxuTm9kZS5udW1lcmljQ29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgIDwgIGIgPyAtMVxuICAgICAgICA6IGEgPT09IGIgPyAgMFxuICAgICAgICA6IGEgID4gIGIgPyAgMSA6IHVuZGVmaW5lZDtcbn07XG4vLyBSZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIHJlcHJlc2VudHMgcm9vdCBvZiBhc3QgaW1wb3J0ZWQgYnkgcmVmZXJlbmNlXG5Ob2RlLnByb3RvdHlwZS5ibG9ja3NWaXNpYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnZpc2liaWxpdHlCbG9ja3MgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnZpc2liaWxpdHlCbG9ja3MgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52aXNpYmlsaXR5QmxvY2tzICE9PSAwO1xufTtcbk5vZGUucHJvdG90eXBlLmFkZFZpc2liaWxpdHlCbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy52aXNpYmlsaXR5QmxvY2tzID09IG51bGwpIHtcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5QmxvY2tzID0gMDtcbiAgICB9XG4gICAgdGhpcy52aXNpYmlsaXR5QmxvY2tzID0gdGhpcy52aXNpYmlsaXR5QmxvY2tzICsgMTtcbn07XG5Ob2RlLnByb3RvdHlwZS5yZW1vdmVWaXNpYmlsaXR5QmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudmlzaWJpbGl0eUJsb2NrcyA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudmlzaWJpbGl0eUJsb2NrcyA9IDA7XG4gICAgfVxuICAgIHRoaXMudmlzaWJpbGl0eUJsb2NrcyA9IHRoaXMudmlzaWJpbGl0eUJsb2NrcyAtIDE7XG59O1xuLy9UdXJucyBvbiBub2RlIHZpc2liaWxpdHkgLSBpZiBjYWxsZWQgbm9kZSB3aWxsIGJlIHNob3duIGluIG91dHB1dCByZWdhcmRsZXNzXG4vL29mIHdoZXRoZXIgaXQgY29tZXMgZnJvbSBpbXBvcnQgYnkgcmVmZXJlbmNlIG9yIG5vdFxuTm9kZS5wcm90b3R5cGUuZW5zdXJlVmlzaWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm5vZGVWaXNpYmxlID0gdHJ1ZTtcbn07XG4vL1R1cm5zIG9mZiBub2RlIHZpc2liaWxpdHkgLSBpZiBjYWxsZWQgbm9kZSB3aWxsIE5PVCBiZSBzaG93biBpbiBvdXRwdXQgcmVnYXJkbGVzc1xuLy9vZiB3aGV0aGVyIGl0IGNvbWVzIGZyb20gaW1wb3J0IGJ5IHJlZmVyZW5jZSBvciBub3Rcbk5vZGUucHJvdG90eXBlLmVuc3VyZUludmlzaWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm5vZGVWaXNpYmxlID0gZmFsc2U7XG59O1xuLy8gcmV0dXJuIHZhbHVlczpcbi8vIGZhbHNlIC0gdGhlIG5vZGUgbXVzdCBub3QgYmUgdmlzaWJsZVxuLy8gdHJ1ZSAtIHRoZSBub2RlIG11c3QgYmUgdmlzaWJsZVxuLy8gdW5kZWZpbmVkIG9yIG51bGwgLSB0aGUgbm9kZSBoYXMgdGhlIHNhbWUgdmlzaWJpbGl0eSBhcyBpdHMgcGFyZW50XG5Ob2RlLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVZpc2libGU7XG59O1xuTm9kZS5wcm90b3R5cGUudmlzaWJpbGl0eUluZm8gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2aXNpYmlsaXR5QmxvY2tzOiB0aGlzLnZpc2liaWxpdHlCbG9ja3MsXG4gICAgICAgIG5vZGVWaXNpYmxlOiB0aGlzLm5vZGVWaXNpYmxlXG4gICAgfTtcbn07XG5Ob2RlLnByb3RvdHlwZS5jb3B5VmlzaWJpbGl0eUluZm8gPSBmdW5jdGlvbihpbmZvKSB7XG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy52aXNpYmlsaXR5QmxvY2tzID0gaW5mby52aXNpYmlsaXR5QmxvY2tzO1xuICAgIHRoaXMubm9kZVZpc2libGUgPSBpbmZvLm5vZGVWaXNpYmxlO1xufTtcbm1vZHVsZS5leHBvcnRzID0gTm9kZTtcblxufSx7fV0sNzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpLFxuICAgIENvbG9yID0gcmVxdWlyZShcIi4vY29sb3JcIiksXG4gICAgRGltZW5zaW9uID0gcmVxdWlyZShcIi4vZGltZW5zaW9uXCIpO1xuXG52YXIgT3BlcmF0aW9uID0gZnVuY3Rpb24gKG9wLCBvcGVyYW5kcywgaXNTcGFjZWQpIHtcbiAgICB0aGlzLm9wID0gb3AudHJpbSgpO1xuICAgIHRoaXMub3BlcmFuZHMgPSBvcGVyYW5kcztcbiAgICB0aGlzLmlzU3BhY2VkID0gaXNTcGFjZWQ7XG59O1xuT3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5PcGVyYXRpb24ucHJvdG90eXBlLnR5cGUgPSBcIk9wZXJhdGlvblwiO1xuT3BlcmF0aW9uLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgIHRoaXMub3BlcmFuZHMgPSB2aXNpdG9yLnZpc2l0KHRoaXMub3BlcmFuZHMpO1xufTtcbk9wZXJhdGlvbi5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIGEgPSB0aGlzLm9wZXJhbmRzWzBdLmV2YWwoY29udGV4dCksXG4gICAgICAgIGIgPSB0aGlzLm9wZXJhbmRzWzFdLmV2YWwoY29udGV4dCk7XG5cbiAgICBpZiAoY29udGV4dC5pc01hdGhPbigpKSB7XG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgRGltZW5zaW9uICYmIGIgaW5zdGFuY2VvZiBDb2xvcikge1xuICAgICAgICAgICAgYSA9IGEudG9Db2xvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiIGluc3RhbmNlb2YgRGltZW5zaW9uICYmIGEgaW5zdGFuY2VvZiBDb2xvcikge1xuICAgICAgICAgICAgYiA9IGIudG9Db2xvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYS5vcGVyYXRlKSB7XG4gICAgICAgICAgICB0aHJvdyB7IHR5cGU6IFwiT3BlcmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiT3BlcmF0aW9uIG9uIGFuIGludmFsaWQgdHlwZVwiIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYS5vcGVyYXRlKGNvbnRleHQsIHRoaXMub3AsIGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgT3BlcmF0aW9uKHRoaXMub3AsIFthLCBiXSwgdGhpcy5pc1NwYWNlZCk7XG4gICAgfVxufTtcbk9wZXJhdGlvbi5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIHRoaXMub3BlcmFuZHNbMF0uZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgaWYgKHRoaXMuaXNTcGFjZWQpIHtcbiAgICAgICAgb3V0cHV0LmFkZChcIiBcIik7XG4gICAgfVxuICAgIG91dHB1dC5hZGQodGhpcy5vcCk7XG4gICAgaWYgKHRoaXMuaXNTcGFjZWQpIHtcbiAgICAgICAgb3V0cHV0LmFkZChcIiBcIik7XG4gICAgfVxuICAgIHRoaXMub3BlcmFuZHNbMV0uZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9wZXJhdGlvbjtcblxufSx7XCIuL2NvbG9yXCI6NTAsXCIuL2RpbWVuc2lvblwiOjU2LFwiLi9ub2RlXCI6NzB9XSw3MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIik7XG5cbnZhciBQYXJlbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdGhpcy52YWx1ZSA9IG5vZGU7XG59O1xuUGFyZW4ucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblBhcmVuLnByb3RvdHlwZS50eXBlID0gXCJQYXJlblwiO1xuUGFyZW4ucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICBvdXRwdXQuYWRkKCcoJyk7XG4gICAgdGhpcy52YWx1ZS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbiAgICBvdXRwdXQuYWRkKCcpJyk7XG59O1xuUGFyZW4ucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUGFyZW4odGhpcy52YWx1ZS5ldmFsKGNvbnRleHQpKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFBhcmVuO1xuXG59LHtcIi4vbm9kZVwiOjcwfV0sNzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpLFxuICAgIEpzRXZhbE5vZGUgPSByZXF1aXJlKFwiLi9qcy1ldmFsLW5vZGVcIiksXG4gICAgVmFyaWFibGUgPSByZXF1aXJlKFwiLi92YXJpYWJsZVwiKTtcblxudmFyIFF1b3RlZCA9IGZ1bmN0aW9uIChzdHIsIGNvbnRlbnQsIGVzY2FwZWQsIGluZGV4LCBjdXJyZW50RmlsZUluZm8pIHtcbiAgICB0aGlzLmVzY2FwZWQgPSAoZXNjYXBlZCA9PSBudWxsKSA/IHRydWUgOiBlc2NhcGVkO1xuICAgIHRoaXMudmFsdWUgPSBjb250ZW50IHx8ICcnO1xuICAgIHRoaXMucXVvdGUgPSBzdHIuY2hhckF0KDApO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmN1cnJlbnRGaWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcbn07XG5RdW90ZWQucHJvdG90eXBlID0gbmV3IEpzRXZhbE5vZGUoKTtcblF1b3RlZC5wcm90b3R5cGUudHlwZSA9IFwiUXVvdGVkXCI7XG5RdW90ZWQucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICBpZiAoIXRoaXMuZXNjYXBlZCkge1xuICAgICAgICBvdXRwdXQuYWRkKHRoaXMucXVvdGUsIHRoaXMuY3VycmVudEZpbGVJbmZvLCB0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgb3V0cHV0LmFkZCh0aGlzLnZhbHVlKTtcbiAgICBpZiAoIXRoaXMuZXNjYXBlZCkge1xuICAgICAgICBvdXRwdXQuYWRkKHRoaXMucXVvdGUpO1xuICAgIH1cbn07XG5RdW90ZWQucHJvdG90eXBlLmNvbnRhaW5zVmFyaWFibGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUubWF0Y2goLyhgKFteYF0rKWApfEBcXHsoW1xcdy1dKylcXH0vKTtcbn07XG5RdW90ZWQucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciB0aGF0ID0gdGhpcywgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIHZhciBqYXZhc2NyaXB0UmVwbGFjZW1lbnQgPSBmdW5jdGlvbiAoXywgZXhwKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcodGhhdC5ldmFsdWF0ZUphdmFTY3JpcHQoZXhwLCBjb250ZXh0KSk7XG4gICAgfTtcbiAgICB2YXIgaW50ZXJwb2xhdGlvblJlcGxhY2VtZW50ID0gZnVuY3Rpb24gKF8sIG5hbWUpIHtcbiAgICAgICAgdmFyIHYgPSBuZXcgVmFyaWFibGUoJ0AnICsgbmFtZSwgdGhhdC5pbmRleCwgdGhhdC5jdXJyZW50RmlsZUluZm8pLmV2YWwoY29udGV4dCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiAodiBpbnN0YW5jZW9mIFF1b3RlZCkgPyB2LnZhbHVlIDogdi50b0NTUygpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gaXRlcmF0aXZlUmVwbGFjZSh2YWx1ZSwgcmVnZXhwLCByZXBsYWNlbWVudEZuYykge1xuICAgICAgICB2YXIgZXZhbHVhdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFsdWUgPSBldmFsdWF0ZWRWYWx1ZTtcbiAgICAgICAgICAgIGV2YWx1YXRlZFZhbHVlID0gdmFsdWUucmVwbGFjZShyZWdleHAsIHJlcGxhY2VtZW50Rm5jKTtcbiAgICAgICAgfSB3aGlsZSAodmFsdWUgIT09IGV2YWx1YXRlZFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGV2YWx1YXRlZFZhbHVlO1xuICAgIH1cbiAgICB2YWx1ZSA9IGl0ZXJhdGl2ZVJlcGxhY2UodmFsdWUsIC9gKFteYF0rKWAvZywgamF2YXNjcmlwdFJlcGxhY2VtZW50KTtcbiAgICB2YWx1ZSA9IGl0ZXJhdGl2ZVJlcGxhY2UodmFsdWUsIC9AXFx7KFtcXHctXSspXFx9L2csIGludGVycG9sYXRpb25SZXBsYWNlbWVudCk7XG4gICAgcmV0dXJuIG5ldyBRdW90ZWQodGhpcy5xdW90ZSArIHZhbHVlICsgdGhpcy5xdW90ZSwgdmFsdWUsIHRoaXMuZXNjYXBlZCwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8pO1xufTtcblF1b3RlZC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIC8vIHdoZW4gY29tcGFyaW5nIHF1b3RlZCBzdHJpbmdzIGFsbG93IHRoZSBxdW90ZSB0byBkaWZmZXJcbiAgICBpZiAob3RoZXIudHlwZSA9PT0gXCJRdW90ZWRcIiAmJiAhdGhpcy5lc2NhcGVkICYmICFvdGhlci5lc2NhcGVkKSB7XG4gICAgICAgIHJldHVybiBOb2RlLm51bWVyaWNDb21wYXJlKHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb3RoZXIudG9DU1MgJiYgdGhpcy50b0NTUygpID09PSBvdGhlci50b0NTUygpID8gMCA6IHVuZGVmaW5lZDtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBRdW90ZWQ7XG5cbn0se1wiLi9qcy1ldmFsLW5vZGVcIjo2NCxcIi4vbm9kZVwiOjcwLFwiLi92YXJpYWJsZVwiOjgyfV0sNzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpLFxuICAgIFZhbHVlID0gcmVxdWlyZShcIi4vdmFsdWVcIiksXG4gICAgS2V5d29yZCA9IHJlcXVpcmUoXCIuL2tleXdvcmRcIik7XG5cbnZhciBSdWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBpbXBvcnRhbnQsIG1lcmdlLCBpbmRleCwgY3VycmVudEZpbGVJbmZvLCBpbmxpbmUsIHZhcmlhYmxlKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnZhbHVlID0gKHZhbHVlIGluc3RhbmNlb2YgTm9kZSkgPyB2YWx1ZSA6IG5ldyBWYWx1ZShbdmFsdWVdKTsgLy92YWx1ZSBpbnN0YW5jZW9mIHRyZWUuVmFsdWUgfHwgdmFsdWUgaW5zdGFuY2VvZiB0cmVlLlJ1bGVzZXQgPz9cbiAgICB0aGlzLmltcG9ydGFudCA9IGltcG9ydGFudCA/ICcgJyArIGltcG9ydGFudC50cmltKCkgOiAnJztcbiAgICB0aGlzLm1lcmdlID0gbWVyZ2U7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuY3VycmVudEZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xuICAgIHRoaXMuaW5saW5lID0gaW5saW5lIHx8IGZhbHNlO1xuICAgIHRoaXMudmFyaWFibGUgPSAodmFyaWFibGUgIT09IHVuZGVmaW5lZCkgPyB2YXJpYWJsZVxuICAgICAgICA6IChuYW1lLmNoYXJBdCAmJiAobmFtZS5jaGFyQXQoMCkgPT09ICdAJykpO1xuICAgIHRoaXMuYWxsb3dSb290ID0gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGV2YWxOYW1lKGNvbnRleHQsIG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSBcIlwiLCBpLCBuID0gbmFtZS5sZW5ndGgsXG4gICAgICAgIG91dHB1dCA9IHthZGQ6IGZ1bmN0aW9uIChzKSB7dmFsdWUgKz0gczt9fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIG5hbWVbaV0uZXZhbChjb250ZXh0KS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5SdWxlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5SdWxlLnByb3RvdHlwZS50eXBlID0gXCJSdWxlXCI7XG5SdWxlLnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgb3V0cHV0LmFkZCh0aGlzLm5hbWUgKyAoY29udGV4dC5jb21wcmVzcyA/ICc6JyA6ICc6ICcpLCB0aGlzLmN1cnJlbnRGaWxlSW5mbywgdGhpcy5pbmRleCk7XG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy52YWx1ZS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbiAgICB9XG4gICAgY2F0Y2goZSkge1xuICAgICAgICBlLmluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgZS5maWxlbmFtZSA9IHRoaXMuY3VycmVudEZpbGVJbmZvLmZpbGVuYW1lO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBvdXRwdXQuYWRkKHRoaXMuaW1wb3J0YW50ICsgKCh0aGlzLmlubGluZSB8fCAoY29udGV4dC5sYXN0UnVsZSAmJiBjb250ZXh0LmNvbXByZXNzKSkgPyBcIlwiIDogXCI7XCIpLCB0aGlzLmN1cnJlbnRGaWxlSW5mbywgdGhpcy5pbmRleCk7XG59O1xuUnVsZS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIHN0cmljdE1hdGhCeXBhc3MgPSBmYWxzZSwgbmFtZSA9IHRoaXMubmFtZSwgZXZhbGRWYWx1ZSwgdmFyaWFibGUgPSB0aGlzLnZhcmlhYmxlO1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyBleHBhbmQgJ3ByaW1pdGl2ZScgbmFtZSBkaXJlY3RseSB0byBnZXRcbiAgICAgICAgLy8gdGhpbmdzIGZhc3RlciAofjEwJSBmb3IgYmVuY2htYXJrLmxlc3MpOlxuICAgICAgICBuYW1lID0gKG5hbWUubGVuZ3RoID09PSAxKSAmJiAobmFtZVswXSBpbnN0YW5jZW9mIEtleXdvcmQpID9cbiAgICAgICAgICAgICAgICBuYW1lWzBdLnZhbHVlIDogZXZhbE5hbWUoY29udGV4dCwgbmFtZSk7XG4gICAgICAgIHZhcmlhYmxlID0gZmFsc2U7IC8vIG5ldmVyIHRyZWF0IGV4cGFuZGVkIGludGVycG9sYXRpb24gYXMgbmV3IHZhcmlhYmxlIG5hbWVcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFwiZm9udFwiICYmICFjb250ZXh0LnN0cmljdE1hdGgpIHtcbiAgICAgICAgc3RyaWN0TWF0aEJ5cGFzcyA9IHRydWU7XG4gICAgICAgIGNvbnRleHQuc3RyaWN0TWF0aCA9IHRydWU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnRleHQuaW1wb3J0YW50U2NvcGUucHVzaCh7fSk7XG4gICAgICAgIGV2YWxkVmFsdWUgPSB0aGlzLnZhbHVlLmV2YWwoY29udGV4dCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnZhcmlhYmxlICYmIGV2YWxkVmFsdWUudHlwZSA9PT0gXCJEZXRhY2hlZFJ1bGVzZXRcIikge1xuICAgICAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiBcIlJ1bGVzZXRzIGNhbm5vdCBiZSBldmFsdWF0ZWQgb24gYSBwcm9wZXJ0eS5cIixcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsIGZpbGVuYW1lOiB0aGlzLmN1cnJlbnRGaWxlSW5mby5maWxlbmFtZSB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbXBvcnRhbnQgPSB0aGlzLmltcG9ydGFudCxcbiAgICAgICAgICAgIGltcG9ydGFudFJlc3VsdCA9IGNvbnRleHQuaW1wb3J0YW50U2NvcGUucG9wKCk7XG4gICAgICAgIGlmICghaW1wb3J0YW50ICYmIGltcG9ydGFudFJlc3VsdC5pbXBvcnRhbnQpIHtcbiAgICAgICAgICAgIGltcG9ydGFudCA9IGltcG9ydGFudFJlc3VsdC5pbXBvcnRhbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFJ1bGUobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0YW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lcmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbywgdGhpcy5pbmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZSk7XG4gICAgfVxuICAgIGNhdGNoKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlLmluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZS5pbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICBlLmZpbGVuYW1lID0gdGhpcy5jdXJyZW50RmlsZUluZm8uZmlsZW5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmIChzdHJpY3RNYXRoQnlwYXNzKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cmljdE1hdGggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5SdWxlLnByb3RvdHlwZS5tYWtlSW1wb3J0YW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgUnVsZSh0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiIWltcG9ydGFudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lcmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbywgdGhpcy5pbmxpbmUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSdWxlO1xufSx7XCIuL2tleXdvcmRcIjo2NSxcIi4vbm9kZVwiOjcwLFwiLi92YWx1ZVwiOjgxfV0sNzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpLFxuICAgIFZhcmlhYmxlID0gcmVxdWlyZShcIi4vdmFyaWFibGVcIik7XG5cbnZhciBSdWxlc2V0Q2FsbCA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICAgIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcbiAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XG59O1xuUnVsZXNldENhbGwucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblJ1bGVzZXRDYWxsLnByb3RvdHlwZS50eXBlID0gXCJSdWxlc2V0Q2FsbFwiO1xuUnVsZXNldENhbGwucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBkZXRhY2hlZFJ1bGVzZXQgPSBuZXcgVmFyaWFibGUodGhpcy52YXJpYWJsZSkuZXZhbChjb250ZXh0KTtcbiAgICByZXR1cm4gZGV0YWNoZWRSdWxlc2V0LmNhbGxFdmFsKGNvbnRleHQpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gUnVsZXNldENhbGw7XG5cbn0se1wiLi9ub2RlXCI6NzAsXCIuL3ZhcmlhYmxlXCI6ODJ9XSw3NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIiksXG4gICAgUnVsZSA9IHJlcXVpcmUoXCIuL3J1bGVcIiksXG4gICAgU2VsZWN0b3IgPSByZXF1aXJlKFwiLi9zZWxlY3RvclwiKSxcbiAgICBFbGVtZW50ID0gcmVxdWlyZShcIi4vZWxlbWVudFwiKSxcbiAgICBQYXJlbiA9IHJlcXVpcmUoXCIuL3BhcmVuXCIpLFxuICAgIGNvbnRleHRzID0gcmVxdWlyZShcIi4uL2NvbnRleHRzXCIpLFxuICAgIGdsb2JhbEZ1bmN0aW9uUmVnaXN0cnkgPSByZXF1aXJlKFwiLi4vZnVuY3Rpb25zL2Z1bmN0aW9uLXJlZ2lzdHJ5XCIpLFxuICAgIGRlZmF1bHRGdW5jID0gcmVxdWlyZShcIi4uL2Z1bmN0aW9ucy9kZWZhdWx0XCIpLFxuICAgIGdldERlYnVnSW5mbyA9IHJlcXVpcmUoXCIuL2RlYnVnLWluZm9cIik7XG5cbnZhciBSdWxlc2V0ID0gZnVuY3Rpb24gKHNlbGVjdG9ycywgcnVsZXMsIHN0cmljdEltcG9ydHMsIHZpc2liaWxpdHlJbmZvKSB7XG4gICAgdGhpcy5zZWxlY3RvcnMgPSBzZWxlY3RvcnM7XG4gICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgIHRoaXMuX2xvb2t1cHMgPSB7fTtcbiAgICB0aGlzLnN0cmljdEltcG9ydHMgPSBzdHJpY3RJbXBvcnRzO1xuICAgIHRoaXMuY29weVZpc2liaWxpdHlJbmZvKHZpc2liaWxpdHlJbmZvKTtcbiAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XG59O1xuUnVsZXNldC5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuUnVsZXNldC5wcm90b3R5cGUudHlwZSA9IFwiUnVsZXNldFwiO1xuUnVsZXNldC5wcm90b3R5cGUuaXNSdWxlc2V0ID0gdHJ1ZTtcblJ1bGVzZXQucHJvdG90eXBlLmlzUnVsZXNldExpa2UgPSB0cnVlO1xuUnVsZXNldC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICBpZiAodGhpcy5wYXRocykge1xuICAgICAgICB0aGlzLnBhdGhzID0gdmlzaXRvci52aXNpdEFycmF5KHRoaXMucGF0aHMsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3RvcnMpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSB2aXNpdG9yLnZpc2l0QXJyYXkodGhpcy5zZWxlY3RvcnMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5ydWxlcyAmJiB0aGlzLnJ1bGVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnJ1bGVzID0gdmlzaXRvci52aXNpdEFycmF5KHRoaXMucnVsZXMpO1xuICAgIH1cbn07XG5SdWxlc2V0LnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgdGhpc1NlbGVjdG9ycyA9IHRoaXMuc2VsZWN0b3JzLCBzZWxlY3RvcnMsXG4gICAgICAgIHNlbENudCwgc2VsZWN0b3IsIGksIGhhc09uZVBhc3NpbmdTZWxlY3RvciA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXNTZWxlY3RvcnMgJiYgKHNlbENudCA9IHRoaXNTZWxlY3RvcnMubGVuZ3RoKSkge1xuICAgICAgICBzZWxlY3RvcnMgPSBbXTtcbiAgICAgICAgZGVmYXVsdEZ1bmMuZXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogXCJTeW50YXhcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiaXQgaXMgY3VycmVudGx5IG9ubHkgYWxsb3dlZCBpbiBwYXJhbWV0cmljIG1peGluIGd1YXJkcyxcIlxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbENudDsgaSsrKSB7XG4gICAgICAgICAgICBzZWxlY3RvciA9IHRoaXNTZWxlY3RvcnNbaV0uZXZhbChjb250ZXh0KTtcbiAgICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rvci5ldmFsZENvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIGhhc09uZVBhc3NpbmdTZWxlY3RvciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdEZ1bmMucmVzZXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBoYXNPbmVQYXNzaW5nU2VsZWN0b3IgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBydWxlcyA9IHRoaXMucnVsZXMgPyB0aGlzLnJ1bGVzLnNsaWNlKDApIDogbnVsbCxcbiAgICAgICAgcnVsZXNldCA9IG5ldyBSdWxlc2V0KHNlbGVjdG9ycywgcnVsZXMsIHRoaXMuc3RyaWN0SW1wb3J0cywgdGhpcy52aXNpYmlsaXR5SW5mbygpKSxcbiAgICAgICAgcnVsZSwgc3ViUnVsZTtcblxuICAgIHJ1bGVzZXQub3JpZ2luYWxSdWxlc2V0ID0gdGhpcztcbiAgICBydWxlc2V0LnJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgcnVsZXNldC5maXJzdFJvb3QgPSB0aGlzLmZpcnN0Um9vdDtcbiAgICBydWxlc2V0LmFsbG93SW1wb3J0cyA9IHRoaXMuYWxsb3dJbXBvcnRzO1xuXG4gICAgaWYgKHRoaXMuZGVidWdJbmZvKSB7XG4gICAgICAgIHJ1bGVzZXQuZGVidWdJbmZvID0gdGhpcy5kZWJ1Z0luZm87XG4gICAgfVxuXG4gICAgaWYgKCFoYXNPbmVQYXNzaW5nU2VsZWN0b3IpIHtcbiAgICAgICAgcnVsZXMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICAvLyBpbmhlcml0IGEgZnVuY3Rpb24gcmVnaXN0cnkgZnJvbSB0aGUgZnJhbWVzIHN0YWNrIHdoZW4gcG9zc2libGU7XG4gICAgLy8gb3RoZXJ3aXNlIGZyb20gdGhlIGdsb2JhbCByZWdpc3RyeVxuICAgIHJ1bGVzZXQuZnVuY3Rpb25SZWdpc3RyeSA9IChmdW5jdGlvbiAoZnJhbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIG4gPSBmcmFtZXMubGVuZ3RoLFxuICAgICAgICAgICAgZm91bmQ7XG4gICAgICAgIGZvciAoIDsgaSAhPT0gbiA7ICsraSApIHtcbiAgICAgICAgICAgIGZvdW5kID0gZnJhbWVzWyBpIF0uZnVuY3Rpb25SZWdpc3RyeTtcbiAgICAgICAgICAgIGlmICggZm91bmQgKSB7IHJldHVybiBmb3VuZDsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iYWxGdW5jdGlvblJlZ2lzdHJ5O1xuICAgIH0oY29udGV4dC5mcmFtZXMpKS5pbmhlcml0KCk7XG5cbiAgICAvLyBwdXNoIHRoZSBjdXJyZW50IHJ1bGVzZXQgdG8gdGhlIGZyYW1lcyBzdGFja1xuICAgIHZhciBjdHhGcmFtZXMgPSBjb250ZXh0LmZyYW1lcztcbiAgICBjdHhGcmFtZXMudW5zaGlmdChydWxlc2V0KTtcblxuICAgIC8vIGN1cnJyZW50IHNlbGVjdG9yc1xuICAgIHZhciBjdHhTZWxlY3RvcnMgPSBjb250ZXh0LnNlbGVjdG9ycztcbiAgICBpZiAoIWN0eFNlbGVjdG9ycykge1xuICAgICAgICBjb250ZXh0LnNlbGVjdG9ycyA9IGN0eFNlbGVjdG9ycyA9IFtdO1xuICAgIH1cbiAgICBjdHhTZWxlY3RvcnMudW5zaGlmdCh0aGlzLnNlbGVjdG9ycyk7XG5cbiAgICAvLyBFdmFsdWF0ZSBpbXBvcnRzXG4gICAgaWYgKHJ1bGVzZXQucm9vdCB8fCBydWxlc2V0LmFsbG93SW1wb3J0cyB8fCAhcnVsZXNldC5zdHJpY3RJbXBvcnRzKSB7XG4gICAgICAgIHJ1bGVzZXQuZXZhbEltcG9ydHMoY29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gU3RvcmUgdGhlIGZyYW1lcyBhcm91bmQgbWl4aW4gZGVmaW5pdGlvbnMsXG4gICAgLy8gc28gdGhleSBjYW4gYmUgZXZhbHVhdGVkIGxpa2UgY2xvc3VyZXMgd2hlbiB0aGUgdGltZSBjb21lcy5cbiAgICB2YXIgcnNSdWxlcyA9IHJ1bGVzZXQucnVsZXMsIHJzUnVsZUNudCA9IHJzUnVsZXMgPyByc1J1bGVzLmxlbmd0aCA6IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHJzUnVsZUNudDsgaSsrKSB7XG4gICAgICAgIGlmIChyc1J1bGVzW2ldLmV2YWxGaXJzdCkge1xuICAgICAgICAgICAgcnNSdWxlc1tpXSA9IHJzUnVsZXNbaV0uZXZhbChjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtZWRpYUJsb2NrQ291bnQgPSAoY29udGV4dC5tZWRpYUJsb2NrcyAmJiBjb250ZXh0Lm1lZGlhQmxvY2tzLmxlbmd0aCkgfHwgMDtcblxuICAgIC8vIEV2YWx1YXRlIG1peGluIGNhbGxzLlxuICAgIGZvciAoaSA9IDA7IGkgPCByc1J1bGVDbnQ7IGkrKykge1xuICAgICAgICBpZiAocnNSdWxlc1tpXS50eXBlID09PSBcIk1peGluQ2FsbFwiKSB7XG4gICAgICAgICAgICAvKmpzaGludCBsb29wZnVuYzp0cnVlICovXG4gICAgICAgICAgICBydWxlcyA9IHJzUnVsZXNbaV0uZXZhbChjb250ZXh0KS5maWx0ZXIoZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAgIGlmICgociBpbnN0YW5jZW9mIFJ1bGUpICYmIHIudmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IHBvbGx1dGUgdGhlIHNjb3BlIGlmIHRoZSB2YXJpYWJsZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IHRoZXJlLiBjb25zaWRlciByZXR1cm5pbmcgZmFsc2UgaGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2UgbmVlZCBhIHdheSB0byBcInJldHVyblwiIHZhcmlhYmxlIGZyb20gbWl4aW5zXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhKHJ1bGVzZXQudmFyaWFibGUoci5uYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByc1J1bGVzLnNwbGljZS5hcHBseShyc1J1bGVzLCBbaSwgMV0uY29uY2F0KHJ1bGVzKSk7XG4gICAgICAgICAgICByc1J1bGVDbnQgKz0gcnVsZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGkgKz0gcnVsZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHJ1bGVzZXQucmVzZXRDYWNoZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHJzUnVsZXNbaV0udHlwZSA9PT0gXCJSdWxlc2V0Q2FsbFwiKSB7XG4gICAgICAgICAgICAvKmpzaGludCBsb29wZnVuYzp0cnVlICovXG4gICAgICAgICAgICBydWxlcyA9IHJzUnVsZXNbaV0uZXZhbChjb250ZXh0KS5ydWxlcy5maWx0ZXIoZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAgIGlmICgociBpbnN0YW5jZW9mIFJ1bGUpICYmIHIudmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IHBvbGx1dGUgdGhlIHNjb3BlIGF0IGFsbFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByc1J1bGVzLnNwbGljZS5hcHBseShyc1J1bGVzLCBbaSwgMV0uY29uY2F0KHJ1bGVzKSk7XG4gICAgICAgICAgICByc1J1bGVDbnQgKz0gcnVsZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGkgKz0gcnVsZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHJ1bGVzZXQucmVzZXRDYWNoZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXZhbHVhdGUgZXZlcnl0aGluZyBlbHNlXG4gICAgZm9yIChpID0gMDsgaSA8IHJzUnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcnVsZSA9IHJzUnVsZXNbaV07XG4gICAgICAgIGlmICghcnVsZS5ldmFsRmlyc3QpIHtcbiAgICAgICAgICAgIHJzUnVsZXNbaV0gPSBydWxlID0gcnVsZS5ldmFsID8gcnVsZS5ldmFsKGNvbnRleHQpIDogcnVsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV2YWx1YXRlIGV2ZXJ5dGhpbmcgZWxzZVxuICAgIGZvciAoaSA9IDA7IGkgPCByc1J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJ1bGUgPSByc1J1bGVzW2ldO1xuICAgICAgICAvLyBmb3IgcnVsZXNldHMsIGNoZWNrIGlmIGl0IGlzIGEgY3NzIGd1YXJkIGFuZCBjYW4gYmUgcmVtb3ZlZFxuICAgICAgICBpZiAocnVsZSBpbnN0YW5jZW9mIFJ1bGVzZXQgJiYgcnVsZS5zZWxlY3RvcnMgJiYgcnVsZS5zZWxlY3RvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBpdCBjYW4gYmUgZm9sZGVkIGluIChlLmcuICYgd2hlcmUpXG4gICAgICAgICAgICBpZiAocnVsZS5zZWxlY3RvcnNbMF0uaXNKdXN0UGFyZW50U2VsZWN0b3IoKSkge1xuICAgICAgICAgICAgICAgIHJzUnVsZXMuc3BsaWNlKGktLSwgMSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJ1bGUucnVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViUnVsZSA9IHJ1bGUucnVsZXNbal07XG4gICAgICAgICAgICAgICAgICAgIHN1YlJ1bGUuY29weVZpc2liaWxpdHlJbmZvKHJ1bGUudmlzaWJpbGl0eUluZm8oKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHN1YlJ1bGUgaW5zdGFuY2VvZiBSdWxlKSB8fCAhc3ViUnVsZS52YXJpYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnNSdWxlcy5zcGxpY2UoKytpLCAwLCBzdWJSdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBvcCB0aGUgc3RhY2tcbiAgICBjdHhGcmFtZXMuc2hpZnQoKTtcbiAgICBjdHhTZWxlY3RvcnMuc2hpZnQoKTtcblxuICAgIGlmIChjb250ZXh0Lm1lZGlhQmxvY2tzKSB7XG4gICAgICAgIGZvciAoaSA9IG1lZGlhQmxvY2tDb3VudDsgaSA8IGNvbnRleHQubWVkaWFCbG9ja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRleHQubWVkaWFCbG9ja3NbaV0uYnViYmxlU2VsZWN0b3JzKHNlbGVjdG9ycyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnVsZXNldDtcbn07XG5SdWxlc2V0LnByb3RvdHlwZS5ldmFsSW1wb3J0cyA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzLCBpLCBpbXBvcnRSdWxlcztcbiAgICBpZiAoIXJ1bGVzKSB7IHJldHVybjsgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChydWxlc1tpXS50eXBlID09PSBcIkltcG9ydFwiKSB7XG4gICAgICAgICAgICBpbXBvcnRSdWxlcyA9IHJ1bGVzW2ldLmV2YWwoY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoaW1wb3J0UnVsZXMgJiYgKGltcG9ydFJ1bGVzLmxlbmd0aCB8fCBpbXBvcnRSdWxlcy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgcnVsZXMuc3BsaWNlLmFwcGx5KHJ1bGVzLCBbaSwgMV0uY29uY2F0KGltcG9ydFJ1bGVzKSk7XG4gICAgICAgICAgICAgICAgaSs9IGltcG9ydFJ1bGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJ1bGVzLnNwbGljZShpLCAxLCBpbXBvcnRSdWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5SdWxlc2V0LnByb3RvdHlwZS5tYWtlSW1wb3J0YW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBSdWxlc2V0KHRoaXMuc2VsZWN0b3JzLCB0aGlzLnJ1bGVzLm1hcChmdW5jdGlvbiAocikge1xuICAgICAgICBpZiAoci5tYWtlSW1wb3J0YW50KSB7XG4gICAgICAgICAgICByZXR1cm4gci5tYWtlSW1wb3J0YW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgIH0pLCB0aGlzLnN0cmljdEltcG9ydHMsIHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblJ1bGVzZXQucHJvdG90eXBlLm1hdGNoQXJncyA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuICFhcmdzIHx8IGFyZ3MubGVuZ3RoID09PSAwO1xufTtcbi8vIGxldHMgeW91IGNhbGwgYSBjc3Mgc2VsZWN0b3Igd2l0aCBhIGd1YXJkXG5SdWxlc2V0LnByb3RvdHlwZS5tYXRjaENvbmRpdGlvbiA9IGZ1bmN0aW9uIChhcmdzLCBjb250ZXh0KSB7XG4gICAgdmFyIGxhc3RTZWxlY3RvciA9IHRoaXMuc2VsZWN0b3JzW3RoaXMuc2VsZWN0b3JzLmxlbmd0aCAtIDFdO1xuICAgIGlmICghbGFzdFNlbGVjdG9yLmV2YWxkQ29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxhc3RTZWxlY3Rvci5jb25kaXRpb24gJiZcbiAgICAgICAgIWxhc3RTZWxlY3Rvci5jb25kaXRpb24uZXZhbChcbiAgICAgICAgICAgIG5ldyBjb250ZXh0cy5FdmFsKGNvbnRleHQsXG4gICAgICAgICAgICAgICAgY29udGV4dC5mcmFtZXMpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblJ1bGVzZXQucHJvdG90eXBlLnJlc2V0Q2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcnVsZXNldHMgPSBudWxsO1xuICAgIHRoaXMuX3ZhcmlhYmxlcyA9IG51bGw7XG4gICAgdGhpcy5fbG9va3VwcyA9IHt9O1xufTtcblJ1bGVzZXQucHJvdG90eXBlLnZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX3ZhcmlhYmxlcykge1xuICAgICAgICB0aGlzLl92YXJpYWJsZXMgPSAhdGhpcy5ydWxlcyA/IHt9IDogdGhpcy5ydWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGhhc2gsIHIpIHtcbiAgICAgICAgICAgIGlmIChyIGluc3RhbmNlb2YgUnVsZSAmJiByLnZhcmlhYmxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaGFzaFtyLm5hbWVdID0gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdoZW4gZXZhbHVhdGluZyB2YXJpYWJsZXMgaW4gYW4gaW1wb3J0IHN0YXRlbWVudCwgaW1wb3J0cyBoYXZlIG5vdCBiZWVuIGV2YWwnZFxuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBnbyBpbnNpZGUgaW1wb3J0IHN0YXRlbWVudHMuXG4gICAgICAgICAgICAvLyBndWFyZCBhZ2FpbnN0IHJvb3QgYmVpbmcgYSBzdHJpbmcgKGluIHRoZSBjYXNlIG9mIGlubGluZWQgbGVzcylcbiAgICAgICAgICAgIGlmIChyLnR5cGUgPT09IFwiSW1wb3J0XCIgJiYgci5yb290ICYmIHIucm9vdC52YXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFycyA9IHIucm9vdC52YXJpYWJsZXMoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHZhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhcnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hbbmFtZV0gPSB2YXJzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZhcmlhYmxlcztcbn07XG5SdWxlc2V0LnByb3RvdHlwZS52YXJpYWJsZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMudmFyaWFibGVzKClbbmFtZV07XG59O1xuUnVsZXNldC5wcm90b3R5cGUucnVsZXNldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLnJ1bGVzKSB7IHJldHVybiBbXTsgfVxuXG4gICAgdmFyIGZpbHRSdWxlcyA9IFtdLCBydWxlcyA9IHRoaXMucnVsZXMsIGNudCA9IHJ1bGVzLmxlbmd0aCxcbiAgICAgICAgaSwgcnVsZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICBydWxlID0gcnVsZXNbaV07XG4gICAgICAgIGlmIChydWxlLmlzUnVsZXNldCkge1xuICAgICAgICAgICAgZmlsdFJ1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmlsdFJ1bGVzO1xufTtcblJ1bGVzZXQucHJvdG90eXBlLnByZXBlbmRSdWxlID0gZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuICAgIGlmIChydWxlcykge1xuICAgICAgICBydWxlcy51bnNoaWZ0KHJ1bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucnVsZXMgPSBbIHJ1bGUgXTtcbiAgICB9XG59O1xuUnVsZXNldC5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2VsZiwgZmlsdGVyKSB7XG4gICAgc2VsZiA9IHNlbGYgfHwgdGhpcztcbiAgICB2YXIgcnVsZXMgPSBbXSwgbWF0Y2gsIGZvdW5kTWl4aW5zLFxuICAgICAgICBrZXkgPSBzZWxlY3Rvci50b0NTUygpO1xuXG4gICAgaWYgKGtleSBpbiB0aGlzLl9sb29rdXBzKSB7IHJldHVybiB0aGlzLl9sb29rdXBzW2tleV07IH1cblxuICAgIHRoaXMucnVsZXNldHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgIGlmIChydWxlICE9PSBzZWxmKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJ1bGUuc2VsZWN0b3JzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBzZWxlY3Rvci5tYXRjaChydWxlLnNlbGVjdG9yc1tqXSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvci5lbGVtZW50cy5sZW5ndGggPiBtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKHJ1bGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRNaXhpbnMgPSBydWxlLmZpbmQobmV3IFNlbGVjdG9yKHNlbGVjdG9yLmVsZW1lbnRzLnNsaWNlKG1hdGNoKSksIHNlbGYsIGZpbHRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3VuZE1peGlucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZE1peGluc1tpXS5wYXRoLnB1c2gocnVsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJ1bGVzLCBmb3VuZE1peGlucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlcy5wdXNoKHsgcnVsZTogcnVsZSwgcGF0aDogW119KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9sb29rdXBzW2tleV0gPSBydWxlcztcbiAgICByZXR1cm4gcnVsZXM7XG59O1xuUnVsZXNldC5wcm90b3R5cGUuZ2VuQ1NTID0gZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xuICAgIHZhciBpLCBqLFxuICAgICAgICBjaGFyc2V0UnVsZU5vZGVzID0gW10sXG4gICAgICAgIHJ1bGVOb2RlcyA9IFtdLFxuICAgICAgICBkZWJ1Z0luZm8sICAgICAvLyBMaW5lIG51bWJlciBkZWJ1Z2dpbmdcbiAgICAgICAgcnVsZSxcbiAgICAgICAgcGF0aDtcblxuICAgIGNvbnRleHQudGFiTGV2ZWwgPSAoY29udGV4dC50YWJMZXZlbCB8fCAwKTtcblxuICAgIGlmICghdGhpcy5yb290KSB7XG4gICAgICAgIGNvbnRleHQudGFiTGV2ZWwrKztcbiAgICB9XG5cbiAgICB2YXIgdGFiUnVsZVN0ciA9IGNvbnRleHQuY29tcHJlc3MgPyAnJyA6IEFycmF5KGNvbnRleHQudGFiTGV2ZWwgKyAxKS5qb2luKFwiICBcIiksXG4gICAgICAgIHRhYlNldFN0ciA9IGNvbnRleHQuY29tcHJlc3MgPyAnJyA6IEFycmF5KGNvbnRleHQudGFiTGV2ZWwpLmpvaW4oXCIgIFwiKSxcbiAgICAgICAgc2VwO1xuXG4gICAgZnVuY3Rpb24gaXNSdWxlc2V0TGlrZU5vZGUocnVsZSkge1xuICAgICAgICAvLyBpZiBpdCBoYXMgbmVzdGVkIHJ1bGVzLCB0aGVuIGl0IHNob3VsZCBiZSB0cmVhdGVkIGxpa2UgYSBydWxlc2V0XG4gICAgICAgIC8vIG1lZGlhcyBhbmQgY29tbWVudHMgZG8gbm90IGhhdmUgbmVzdGVkIHJ1bGVzLCBidXQgc2hvdWxkIGJlIHRyZWF0ZWQgbGlrZSBydWxlc2V0cyBhbnl3YXlcbiAgICAgICAgLy8gc29tZSBkaXJlY3RpdmVzIGFuZCBhbm9ueW1vdXMgbm9kZXMgYXJlIHJ1bGVzZXQgbGlrZSwgb3RoZXJzIGFyZSBub3RcbiAgICAgICAgaWYgKHR5cGVvZiBydWxlLmlzUnVsZXNldExpa2UgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVsZS5pc1J1bGVzZXRMaWtlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBydWxlLmlzUnVsZXNldExpa2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHJ1bGUuaXNSdWxlc2V0TGlrZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9hbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYSBydWxlXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2hhcnNldE5vZGVJbmRleCA9IDA7XG4gICAgdmFyIGltcG9ydE5vZGVJbmRleCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMucnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcnVsZSA9IHRoaXMucnVsZXNbaV07XG4gICAgICAgIGlmIChydWxlLnR5cGUgPT09IFwiQ29tbWVudFwiKSB7XG4gICAgICAgICAgICBpZiAoaW1wb3J0Tm9kZUluZGV4ID09PSBpKSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0Tm9kZUluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBydWxlTm9kZXMucHVzaChydWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChydWxlLmlzQ2hhcnNldCAmJiBydWxlLmlzQ2hhcnNldCgpKSB7XG4gICAgICAgICAgICBydWxlTm9kZXMuc3BsaWNlKGNoYXJzZXROb2RlSW5kZXgsIDAsIHJ1bGUpO1xuICAgICAgICAgICAgY2hhcnNldE5vZGVJbmRleCsrO1xuICAgICAgICAgICAgaW1wb3J0Tm9kZUluZGV4Kys7XG4gICAgICAgIH0gZWxzZSBpZiAocnVsZS50eXBlID09PSBcIkltcG9ydFwiKSB7XG4gICAgICAgICAgICBydWxlTm9kZXMuc3BsaWNlKGltcG9ydE5vZGVJbmRleCwgMCwgcnVsZSk7XG4gICAgICAgICAgICBpbXBvcnROb2RlSW5kZXgrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJ1bGVOb2Rlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJ1bGVOb2RlcyA9IGNoYXJzZXRSdWxlTm9kZXMuY29uY2F0KHJ1bGVOb2Rlcyk7XG5cbiAgICAvLyBJZiB0aGlzIGlzIHRoZSByb290IG5vZGUsIHdlIGRvbid0IHJlbmRlclxuICAgIC8vIGEgc2VsZWN0b3IsIG9yIHt9LlxuICAgIGlmICghdGhpcy5yb290KSB7XG4gICAgICAgIGRlYnVnSW5mbyA9IGdldERlYnVnSW5mbyhjb250ZXh0LCB0aGlzLCB0YWJTZXRTdHIpO1xuXG4gICAgICAgIGlmIChkZWJ1Z0luZm8pIHtcbiAgICAgICAgICAgIG91dHB1dC5hZGQoZGVidWdJbmZvKTtcbiAgICAgICAgICAgIG91dHB1dC5hZGQodGFiU2V0U3RyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXRocyA9IHRoaXMucGF0aHMsIHBhdGhDbnQgPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgICBwYXRoU3ViQ250O1xuXG4gICAgICAgIHNlcCA9IGNvbnRleHQuY29tcHJlc3MgPyAnLCcgOiAoJyxcXG4nICsgdGFiU2V0U3RyKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aENudDsgaSsrKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aHNbaV07XG4gICAgICAgICAgICBpZiAoIShwYXRoU3ViQ250ID0gcGF0aC5sZW5ndGgpKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICBpZiAoaSA+IDApIHsgb3V0cHV0LmFkZChzZXApOyB9XG5cbiAgICAgICAgICAgIGNvbnRleHQuZmlyc3RTZWxlY3RvciA9IHRydWU7XG4gICAgICAgICAgICBwYXRoWzBdLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuXG4gICAgICAgICAgICBjb250ZXh0LmZpcnN0U2VsZWN0b3IgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPCBwYXRoU3ViQ250OyBqKyspIHtcbiAgICAgICAgICAgICAgICBwYXRoW2pdLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0LmFkZCgoY29udGV4dC5jb21wcmVzcyA/ICd7JyA6ICcge1xcbicpICsgdGFiUnVsZVN0cik7XG4gICAgfVxuXG4gICAgLy8gQ29tcGlsZSBydWxlcyBhbmQgcnVsZXNldHNcbiAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZU5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJ1bGUgPSBydWxlTm9kZXNbaV07XG5cbiAgICAgICAgaWYgKGkgKyAxID09PSBydWxlTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb250ZXh0Lmxhc3RSdWxlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJyZW50TGFzdFJ1bGUgPSBjb250ZXh0Lmxhc3RSdWxlO1xuICAgICAgICBpZiAoaXNSdWxlc2V0TGlrZU5vZGUocnVsZSkpIHtcbiAgICAgICAgICAgIGNvbnRleHQubGFzdFJ1bGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChydWxlLmdlbkNTUykge1xuICAgICAgICAgICAgcnVsZS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbiAgICAgICAgfSBlbHNlIGlmIChydWxlLnZhbHVlKSB7XG4gICAgICAgICAgICBvdXRwdXQuYWRkKHJ1bGUudmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lmxhc3RSdWxlID0gY3VycmVudExhc3RSdWxlO1xuXG4gICAgICAgIGlmICghY29udGV4dC5sYXN0UnVsZSkge1xuICAgICAgICAgICAgb3V0cHV0LmFkZChjb250ZXh0LmNvbXByZXNzID8gJycgOiAoJ1xcbicgKyB0YWJSdWxlU3RyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0Lmxhc3RSdWxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucm9vdCkge1xuICAgICAgICBvdXRwdXQuYWRkKChjb250ZXh0LmNvbXByZXNzID8gJ30nIDogJ1xcbicgKyB0YWJTZXRTdHIgKyAnfScpKTtcbiAgICAgICAgY29udGV4dC50YWJMZXZlbC0tO1xuICAgIH1cblxuICAgIGlmICghb3V0cHV0LmlzRW1wdHkoKSAmJiAhY29udGV4dC5jb21wcmVzcyAmJiB0aGlzLmZpcnN0Um9vdCkge1xuICAgICAgICBvdXRwdXQuYWRkKCdcXG4nKTtcbiAgICB9XG59O1xuXG5SdWxlc2V0LnByb3RvdHlwZS5qb2luU2VsZWN0b3JzID0gZnVuY3Rpb24gKHBhdGhzLCBjb250ZXh0LCBzZWxlY3RvcnMpIHtcbiAgICBmb3IgKHZhciBzID0gMDsgcyA8IHNlbGVjdG9ycy5sZW5ndGg7IHMrKykge1xuICAgICAgICB0aGlzLmpvaW5TZWxlY3RvcihwYXRocywgY29udGV4dCwgc2VsZWN0b3JzW3NdKTtcbiAgICB9XG59O1xuXG5SdWxlc2V0LnByb3RvdHlwZS5qb2luU2VsZWN0b3IgPSBmdW5jdGlvbiAocGF0aHMsIGNvbnRleHQsIHNlbGVjdG9yKSB7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJlbnRoZXNpcyhlbGVtZW50c1RvUGFrLCBvcmlnaW5hbEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHJlcGxhY2VtZW50UGFyZW4sIGo7XG4gICAgICAgIGlmIChlbGVtZW50c1RvUGFrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVwbGFjZW1lbnRQYXJlbiA9IG5ldyBQYXJlbihlbGVtZW50c1RvUGFrWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbnNpZGVQYXJlbnQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBlbGVtZW50c1RvUGFrLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaW5zaWRlUGFyZW50LnB1c2gobmV3IEVsZW1lbnQobnVsbCwgZWxlbWVudHNUb1Bha1tqXSwgb3JpZ2luYWxFbGVtZW50LmluZGV4LCBvcmlnaW5hbEVsZW1lbnQuY3VycmVudEZpbGVJbmZvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXBsYWNlbWVudFBhcmVuID0gbmV3IFBhcmVuKG5ldyBTZWxlY3RvcihpbnNpZGVQYXJlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnRQYXJlbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVTZWxlY3Rvcihjb250YWluZWRFbGVtZW50LCBvcmlnaW5hbEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQsIHNlbGVjdG9yO1xuICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQobnVsbCwgY29udGFpbmVkRWxlbWVudCwgb3JpZ2luYWxFbGVtZW50LmluZGV4LCBvcmlnaW5hbEVsZW1lbnQuY3VycmVudEZpbGVJbmZvKTtcbiAgICAgICAgc2VsZWN0b3IgPSBuZXcgU2VsZWN0b3IoW2VsZW1lbnRdKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgIH1cblxuICAgIC8vIGpvaW5zIHNlbGVjdG9yIHBhdGggZnJvbSBgYmVnaW5uaW5nUGF0aGAgd2l0aCBzZWxlY3RvciBwYXRoIGluIGBhZGRQYXRoYFxuICAgIC8vIGByZXBsYWNlZEVsZW1lbnRgIGNvbnRhaW5zIGVsZW1lbnQgdGhhdCBpcyBiZWluZyByZXBsYWNlZCBieSBgYWRkUGF0aGBcbiAgICAvLyByZXR1cm5zIGNvbmNhdGVuYXRlZCBwYXRoXG4gICAgZnVuY3Rpb24gYWRkUmVwbGFjZW1lbnRJbnRvUGF0aChiZWdpbm5pbmdQYXRoLCBhZGRQYXRoLCByZXBsYWNlZEVsZW1lbnQsIG9yaWdpbmFsU2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIG5ld1NlbGVjdG9yUGF0aCwgbGFzdFNlbGVjdG9yLCBuZXdKb2luZWRTZWxlY3RvcjtcbiAgICAgICAgLy8gb3VyIG5ldyBzZWxlY3RvciBwYXRoXG4gICAgICAgIG5ld1NlbGVjdG9yUGF0aCA9IFtdO1xuXG4gICAgICAgIC8vY29uc3RydWN0IHRoZSBqb2luZWQgc2VsZWN0b3IgLSBpZiAmIGlzIHRoZSBmaXJzdCB0aGluZyB0aGlzIHdpbGwgYmUgZW1wdHksXG4gICAgICAgIC8vIGlmIG5vdCBuZXdKb2luZWRTZWxlY3RvciB3aWxsIGJlIHRoZSBsYXN0IHNldCBvZiBlbGVtZW50cyBpbiB0aGUgc2VsZWN0b3JcbiAgICAgICAgaWYgKGJlZ2lubmluZ1BhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbmV3U2VsZWN0b3JQYXRoID0gYmVnaW5uaW5nUGF0aC5zbGljZSgwKTtcbiAgICAgICAgICAgIGxhc3RTZWxlY3RvciA9IG5ld1NlbGVjdG9yUGF0aC5wb3AoKTtcbiAgICAgICAgICAgIG5ld0pvaW5lZFNlbGVjdG9yID0gb3JpZ2luYWxTZWxlY3Rvci5jcmVhdGVEZXJpdmVkKGxhc3RTZWxlY3Rvci5lbGVtZW50cy5zbGljZSgwKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdKb2luZWRTZWxlY3RvciA9IG9yaWdpbmFsU2VsZWN0b3IuY3JlYXRlRGVyaXZlZChbXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWRkUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyAvZGVlcC8gaXMgYSBjb21iaW5hdG9yIHRoYXQgaXMgdmFsaWQgd2l0aG91dCBhbnl0aGluZyBpbiBmcm9udCBvZiBpdFxuICAgICAgICAgICAgLy8gc28gaWYgdGhlICYgZG9lcyBub3QgaGF2ZSBhIGNvbWJpbmF0b3IgdGhhdCBpcyBcIlwiIG9yIFwiIFwiIHRoZW5cbiAgICAgICAgICAgIC8vIGFuZCB0aGVyZSBpcyBhIGNvbWJpbmF0b3Igb24gdGhlIHBhcmVudCwgdGhlbiBncmFiIHRoYXQuXG4gICAgICAgICAgICAvLyB0aGlzIGFsc28gYWxsb3dzICsgYSB7ICYgLmIgeyAuYSAmIHsgLi4uIHRob3VnaCBub3Qgc3VyZSB3aHkgeW91IHdvdWxkIHdhbnQgdG8gZG8gdGhhdFxuICAgICAgICAgICAgdmFyIGNvbWJpbmF0b3IgPSByZXBsYWNlZEVsZW1lbnQuY29tYmluYXRvciwgcGFyZW50RWwgPSBhZGRQYXRoWzBdLmVsZW1lbnRzWzBdO1xuICAgICAgICAgICAgaWYgKGNvbWJpbmF0b3IuZW1wdHlPcldoaXRlc3BhY2UgJiYgIXBhcmVudEVsLmNvbWJpbmF0b3IuZW1wdHlPcldoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBjb21iaW5hdG9yID0gcGFyZW50RWwuY29tYmluYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGpvaW4gdGhlIGVsZW1lbnRzIHNvIGZhciB3aXRoIHRoZSBmaXJzdCBwYXJ0IG9mIHRoZSBwYXJlbnRcbiAgICAgICAgICAgIG5ld0pvaW5lZFNlbGVjdG9yLmVsZW1lbnRzLnB1c2gobmV3IEVsZW1lbnQoY29tYmluYXRvciwgcGFyZW50RWwudmFsdWUsIHJlcGxhY2VkRWxlbWVudC5pbmRleCwgcmVwbGFjZWRFbGVtZW50LmN1cnJlbnRGaWxlSW5mbykpO1xuICAgICAgICAgICAgbmV3Sm9pbmVkU2VsZWN0b3IuZWxlbWVudHMgPSBuZXdKb2luZWRTZWxlY3Rvci5lbGVtZW50cy5jb25jYXQoYWRkUGF0aFswXS5lbGVtZW50cy5zbGljZSgxKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3cgYWRkIHRoZSBqb2luZWQgc2VsZWN0b3IgLSBidXQgb25seSBpZiBpdCBpcyBub3QgZW1wdHlcbiAgICAgICAgaWYgKG5ld0pvaW5lZFNlbGVjdG9yLmVsZW1lbnRzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgbmV3U2VsZWN0b3JQYXRoLnB1c2gobmV3Sm9pbmVkU2VsZWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9wdXQgdG9nZXRoZXIgdGhlIHBhcmVudCBzZWxlY3RvcnMgYWZ0ZXIgdGhlIGpvaW4gKGUuZy4gdGhlIHJlc3Qgb2YgdGhlIHBhcmVudClcbiAgICAgICAgaWYgKGFkZFBhdGgubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIHJlc3RPZlBhdGggPSBhZGRQYXRoLnNsaWNlKDEpO1xuICAgICAgICAgICAgcmVzdE9mUGF0aCA9IHJlc3RPZlBhdGgubWFwKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rvci5jcmVhdGVEZXJpdmVkKHNlbGVjdG9yLmVsZW1lbnRzLCBbXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5ld1NlbGVjdG9yUGF0aCA9IG5ld1NlbGVjdG9yUGF0aC5jb25jYXQocmVzdE9mUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1NlbGVjdG9yUGF0aDtcbiAgICB9XG5cbiAgICAvLyBqb2lucyBzZWxlY3RvciBwYXRoIGZyb20gYGJlZ2lubmluZ1BhdGhgIHdpdGggZXZlcnkgc2VsZWN0b3IgcGF0aCBpbiBgYWRkUGF0aHNgIGFycmF5XG4gICAgLy8gYHJlcGxhY2VkRWxlbWVudGAgY29udGFpbnMgZWxlbWVudCB0aGF0IGlzIGJlaW5nIHJlcGxhY2VkIGJ5IGBhZGRQYXRoYFxuICAgIC8vIHJldHVybnMgYXJyYXkgd2l0aCBhbGwgY29uY2F0ZW5hdGVkIHBhdGhzXG4gICAgZnVuY3Rpb24gYWRkQWxsUmVwbGFjZW1lbnRzSW50b1BhdGgoIGJlZ2lubmluZ1BhdGgsIGFkZFBhdGhzLCByZXBsYWNlZEVsZW1lbnQsIG9yaWdpbmFsU2VsZWN0b3IsIHJlc3VsdCkge1xuICAgICAgICB2YXIgajtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGJlZ2lubmluZ1BhdGgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBuZXdTZWxlY3RvclBhdGggPSBhZGRSZXBsYWNlbWVudEludG9QYXRoKGJlZ2lubmluZ1BhdGhbal0sIGFkZFBhdGhzLCByZXBsYWNlZEVsZW1lbnQsIG9yaWdpbmFsU2VsZWN0b3IpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3U2VsZWN0b3JQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlRWxlbWVudHNPblRvU2VsZWN0b3JzKGVsZW1lbnRzLCBzZWxlY3RvcnMpIHtcbiAgICAgICAgdmFyIGksIHNlbDtcblxuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3RvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzZWxlY3RvcnMucHVzaChbIG5ldyBTZWxlY3RvcihlbGVtZW50cykgXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZWwgPSBzZWxlY3RvcnNbaV07XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBwcmV2aW91cyB0aGluZyBpbiBzZWwgaXMgYSBwYXJlbnQgdGhpcyBuZWVkcyB0byBqb2luIG9uIHRvIGl0XG4gICAgICAgICAgICBpZiAoc2VsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZWxbc2VsLmxlbmd0aCAtIDFdID0gc2VsW3NlbC5sZW5ndGggLSAxXS5jcmVhdGVEZXJpdmVkKHNlbFtzZWwubGVuZ3RoIC0gMV0uZWxlbWVudHMuY29uY2F0KGVsZW1lbnRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWwucHVzaChuZXcgU2VsZWN0b3IoZWxlbWVudHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlcGxhY2UgYWxsIHBhcmVudCBzZWxlY3RvcnMgaW5zaWRlIGBpblNlbGVjdG9yYCBieSBjb250ZW50IG9mIGBjb250ZXh0YCBhcnJheVxuICAgIC8vIHJlc3VsdGluZyBzZWxlY3RvcnMgYXJlIHJldHVybmVkIGluc2lkZSBgcGF0aHNgIGFycmF5XG4gICAgLy8gcmV0dXJucyB0cnVlIGlmIGBpblNlbGVjdG9yYCBjb250YWluZWQgYXQgbGVhc3Qgb25lIHBhcmVudCBzZWxlY3RvclxuICAgIGZ1bmN0aW9uIHJlcGxhY2VQYXJlbnRTZWxlY3RvcihwYXRocywgY29udGV4dCwgaW5TZWxlY3Rvcikge1xuICAgICAgICAvLyBUaGUgcGF0aHMgYXJlIFtbU2VsZWN0b3JdXVxuICAgICAgICAvLyBUaGUgZmlyc3QgbGlzdCBpcyBhIGxpc3Qgb2YgY29tbWEgc2VwYXJhdGVkIHNlbGVjdG9yc1xuICAgICAgICAvLyBUaGUgaW5uZXIgbGlzdCBpcyBhIGxpc3Qgb2YgaW5oZXJpdGFuY2Ugc2VwYXJhdGVkIHNlbGVjdG9yc1xuICAgICAgICAvLyBlLmcuXG4gICAgICAgIC8vIC5hLCAuYiB7XG4gICAgICAgIC8vICAgLmMge1xuICAgICAgICAvLyAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICAvLyA9PSBbWy5hXSBbLmNdXSBbWy5iXSBbLmNdXVxuICAgICAgICAvL1xuICAgICAgICB2YXIgaSwgaiwgaywgY3VycmVudEVsZW1lbnRzLCBuZXdTZWxlY3RvcnMsIHNlbGVjdG9yc011bHRpcGxpZWQsIHNlbCwgZWwsIGhhZFBhcmVudFNlbGVjdG9yID0gZmFsc2UsIGxlbmd0aCwgbGFzdFNlbGVjdG9yO1xuICAgICAgICBmdW5jdGlvbiBmaW5kTmVzdGVkU2VsZWN0b3IoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIG1heWJlU2VsZWN0b3I7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC52YWx1ZS50eXBlICE9PSAnUGFyZW4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1heWJlU2VsZWN0b3IgPSBlbGVtZW50LnZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgaWYgKG1heWJlU2VsZWN0b3IudHlwZSAhPT0gJ1NlbGVjdG9yJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWF5YmVTZWxlY3RvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdG9yIHNvIGZhclxuICAgICAgICBjdXJyZW50RWxlbWVudHMgPSBbXTtcbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgbGlzdCBvZiBuZXcgc2VsZWN0b3JzIHRvIGFkZCB0byB0aGUgcGF0aC5cbiAgICAgICAgLy8gV2Ugd2lsbCBidWlsZCBpdCB1cC4gV2UgaW5pdGlhdGUgaXQgd2l0aCBvbmUgZW1wdHkgc2VsZWN0b3IgYXMgd2UgXCJtdWx0aXBseVwiIHRoZSBuZXcgc2VsZWN0b3JzXG4gICAgICAgIC8vIGJ5IHRoZSBwYXJlbnRzXG4gICAgICAgIG5ld1NlbGVjdG9ycyA9IFtcbiAgICAgICAgICAgIFtdXG4gICAgICAgIF07XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGluU2VsZWN0b3IuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGVsID0gaW5TZWxlY3Rvci5lbGVtZW50c1tpXTtcbiAgICAgICAgICAgIC8vIG5vbiBwYXJlbnQgcmVmZXJlbmNlIGVsZW1lbnRzIGp1c3QgZ2V0IGFkZGVkXG4gICAgICAgICAgICBpZiAoZWwudmFsdWUgIT09IFwiJlwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5lc3RlZFNlbGVjdG9yID0gZmluZE5lc3RlZFNlbGVjdG9yKGVsKTtcbiAgICAgICAgICAgICAgICBpZiAobmVzdGVkU2VsZWN0b3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSB0aGUgY3VycmVudCBsaXN0IG9mIG5vbiBwYXJlbnQgc2VsZWN0b3IgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gdG8gdGhlIGN1cnJlbnQgbGlzdCBvZiBzZWxlY3RvcnMgdG8gYWRkXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlRWxlbWVudHNPblRvU2VsZWN0b3JzKGN1cnJlbnRFbGVtZW50cywgbmV3U2VsZWN0b3JzKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbmVzdGVkUGF0aHMgPSBbXSwgcmVwbGFjZWQsIHJlcGxhY2VkTmV3U2VsZWN0b3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VkID0gcmVwbGFjZVBhcmVudFNlbGVjdG9yKG5lc3RlZFBhdGhzLCBjb250ZXh0LCBuZXN0ZWRTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIGhhZFBhcmVudFNlbGVjdG9yID0gaGFkUGFyZW50U2VsZWN0b3IgfHwgcmVwbGFjZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5lc3RlZFBhdGhzIGFycmF5IHNob3VsZCBoYXZlIG9ubHkgb25lIG1lbWJlciAtIHJlcGxhY2VQYXJlbnRTZWxlY3RvciBkb2VzIG5vdCBtdWx0aXBseSBzZWxlY3RvcnNcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG5lc3RlZFBhdGhzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnRTZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yKGNyZWF0ZVBhcmVudGhlc2lzKG5lc3RlZFBhdGhzW2tdLCBlbCksIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEFsbFJlcGxhY2VtZW50c0ludG9QYXRoKG5ld1NlbGVjdG9ycywgW3JlcGxhY2VtZW50U2VsZWN0b3JdLCBlbCwgaW5TZWxlY3RvciwgcmVwbGFjZWROZXdTZWxlY3RvcnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9ycyA9IHJlcGxhY2VkTmV3U2VsZWN0b3JzO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFkUGFyZW50U2VsZWN0b3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIHRoZSBuZXcgbGlzdCBvZiBzZWxlY3RvcnMgdG8gYWRkXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzTXVsdGlwbGllZCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gbWVyZ2UgdGhlIGN1cnJlbnQgbGlzdCBvZiBub24gcGFyZW50IHNlbGVjdG9yIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgLy8gb24gdG8gdGhlIGN1cnJlbnQgbGlzdCBvZiBzZWxlY3RvcnMgdG8gYWRkXG4gICAgICAgICAgICAgICAgbWVyZ2VFbGVtZW50c09uVG9TZWxlY3RvcnMoY3VycmVudEVsZW1lbnRzLCBuZXdTZWxlY3RvcnMpO1xuXG4gICAgICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIG91ciBjdXJyZW50IHNlbGVjdG9yc1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBuZXdTZWxlY3RvcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsID0gbmV3U2VsZWN0b3JzW2pdO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIGFueSBwYXJlbnQgcGF0aHMsIHRoZSAmIG1pZ2h0IGJlIGluIGEgbWl4aW4gc28gdGhhdCBpdCBjYW4gYmUgdXNlZFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGV0aGVyIHRoZXJlIGFyZSBwYXJlbnRzIG9yIG5vdFxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjb21iaW5hdG9yIHVzZWQgb24gZWwgc2hvdWxkIG5vdyBiZSBhcHBsaWVkIHRvIHRoZSBuZXh0IGVsZW1lbnQgaW5zdGVhZCBzbyB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBpcyBub3QgbG9zdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsWzBdLmVsZW1lbnRzLnB1c2gobmV3IEVsZW1lbnQoZWwuY29tYmluYXRvciwgJycsIGVsLmluZGV4LCBlbC5jdXJyZW50RmlsZUluZm8pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yc011bHRpcGxpZWQucHVzaChzZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoZSBwYXJlbnQgc2VsZWN0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgY29udGV4dC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcHV0IHRoZSBjdXJyZW50IHNlbGVjdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gam9pbiB0aGUgbGFzdCBzZWxlY3RvcidzIGVsZW1lbnRzIG9uIHRvIHRoZSBwYXJlbnRzIHNlbGVjdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdTZWxlY3RvclBhdGggPSBhZGRSZXBsYWNlbWVudEludG9QYXRoKHNlbCwgY29udGV4dFtrXSwgZWwsIGluU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGF0IHRvIG91ciBuZXcgc2V0IG9mIHNlbGVjdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yc011bHRpcGxpZWQucHVzaChuZXdTZWxlY3RvclBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gb3VyIG5ldyBzZWxlY3RvcnMgaGFzIGJlZW4gbXVsdGlwbGllZCwgc28gcmVzZXQgdGhlIHN0YXRlXG4gICAgICAgICAgICAgICAgbmV3U2VsZWN0b3JzID0gc2VsZWN0b3JzTXVsdGlwbGllZDtcbiAgICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYW55IGVsZW1lbnRzIGxlZnQgb3ZlciAoZS5nLiAuYSYgLmIgPT0gLmIpXG4gICAgICAgIC8vIGFkZCB0aGVtIG9uIHRvIGFsbCB0aGUgY3VycmVudCBzZWxlY3RvcnNcbiAgICAgICAgbWVyZ2VFbGVtZW50c09uVG9TZWxlY3RvcnMoY3VycmVudEVsZW1lbnRzLCBuZXdTZWxlY3RvcnMpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXdTZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IG5ld1NlbGVjdG9yc1tpXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gobmV3U2VsZWN0b3JzW2ldKTtcbiAgICAgICAgICAgICAgICBsYXN0U2VsZWN0b3IgPSBuZXdTZWxlY3RvcnNbaV1bbGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgbmV3U2VsZWN0b3JzW2ldW2xlbmd0aCAtIDFdID0gbGFzdFNlbGVjdG9yLmNyZWF0ZURlcml2ZWQobGFzdFNlbGVjdG9yLmVsZW1lbnRzLCBpblNlbGVjdG9yLmV4dGVuZExpc3QpO1xuICAgICAgICAgICAgICAgIC8vbmV3U2VsZWN0b3JzW2ldW2xlbmd0aCAtIDFdLmNvcHlWaXNpYmlsaXR5SW5mbyhpblNlbGVjdG9yLnZpc2liaWxpdHlJbmZvKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhhZFBhcmVudFNlbGVjdG9yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcml2ZVNlbGVjdG9yKHZpc2liaWxpdHlJbmZvLCBkZXJpdmVGcm9tKSB7XG4gICAgICAgIHZhciBuZXdTZWxlY3RvciA9IGRlcml2ZUZyb20uY3JlYXRlRGVyaXZlZChkZXJpdmVGcm9tLmVsZW1lbnRzLCBkZXJpdmVGcm9tLmV4dGVuZExpc3QsIGRlcml2ZUZyb20uZXZhbGRDb25kaXRpb24pO1xuICAgICAgICBuZXdTZWxlY3Rvci5jb3B5VmlzaWJpbGl0eUluZm8odmlzaWJpbGl0eUluZm8pO1xuICAgICAgICByZXR1cm4gbmV3U2VsZWN0b3I7XG4gICAgfVxuXG4gICAgLy8gam9pblNlbGVjdG9yIGNvZGUgZm9sbG93c1xuICAgIHZhciBpLCBuZXdQYXRocywgaGFkUGFyZW50U2VsZWN0b3I7XG5cbiAgICBuZXdQYXRocyA9IFtdO1xuICAgIGhhZFBhcmVudFNlbGVjdG9yID0gcmVwbGFjZVBhcmVudFNlbGVjdG9yKG5ld1BhdGhzLCBjb250ZXh0LCBzZWxlY3Rvcik7XG5cbiAgICBpZiAoIWhhZFBhcmVudFNlbGVjdG9yKSB7XG4gICAgICAgIGlmIChjb250ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG5ld1BhdGhzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29udGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vdmFyIGNvbmNhdGVuYXRlZCA9IFtdO1xuICAgICAgICAgICAgICAgIC8vY29udGV4dFtpXS5mb3JFYWNoKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gICAgdmFyIG5ld0VudHJ5ID0gZW50cnkuY3JlYXRlRGVyaXZlZChlbnRyeS5lbGVtZW50cywgZW50cnkuZXh0ZW5kTGlzdCwgZW50cnkuZXZhbGRDb25kaXRpb24pO1xuICAgICAgICAgICAgICAgIC8vICAgIG5ld0VudHJ5LmNvcHlWaXNpYmlsaXR5SW5mbyhzZWxlY3Rvci52aXNpYmlsaXR5SW5mbygpKTtcbiAgICAgICAgICAgICAgICAvLyAgICBjb25jYXRlbmF0ZWQucHVzaChuZXdFbnRyeSk7XG4gICAgICAgICAgICAgICAgLy99LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB2YXIgY29uY2F0ZW5hdGVkID0gY29udGV4dFtpXS5tYXAoZGVyaXZlU2VsZWN0b3IuYmluZCh0aGlzLCBzZWxlY3Rvci52aXNpYmlsaXR5SW5mbygpKSk7XG5cbiAgICAgICAgICAgICAgICBjb25jYXRlbmF0ZWQucHVzaChzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgbmV3UGF0aHMucHVzaChjb25jYXRlbmF0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3UGF0aHMgPSBbW3NlbGVjdG9yXV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbmV3UGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0aHMucHVzaChuZXdQYXRoc1tpXSk7XG4gICAgfVxuXG59O1xubW9kdWxlLmV4cG9ydHMgPSBSdWxlc2V0O1xuXG59LHtcIi4uL2NvbnRleHRzXCI6MTEsXCIuLi9mdW5jdGlvbnMvZGVmYXVsdFwiOjIwLFwiLi4vZnVuY3Rpb25zL2Z1bmN0aW9uLXJlZ2lzdHJ5XCI6MjIsXCIuL2RlYnVnLWluZm9cIjo1NCxcIi4vZWxlbWVudFwiOjU4LFwiLi9ub2RlXCI6NzAsXCIuL3BhcmVuXCI6NzIsXCIuL3J1bGVcIjo3NCxcIi4vc2VsZWN0b3JcIjo3N31dLDc3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBOb2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKSxcbiAgICBFbGVtZW50ID0gcmVxdWlyZShcIi4vZWxlbWVudFwiKTtcblxudmFyIFNlbGVjdG9yID0gZnVuY3Rpb24gKGVsZW1lbnRzLCBleHRlbmRMaXN0LCBjb25kaXRpb24sIGluZGV4LCBjdXJyZW50RmlsZUluZm8sIHZpc2liaWxpdHlJbmZvKSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgIHRoaXMuZXh0ZW5kTGlzdCA9IGV4dGVuZExpc3Q7XG4gICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgdGhpcy5jdXJyZW50RmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm8gfHwge307XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5ldmFsZENvbmRpdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuY29weVZpc2liaWxpdHlJbmZvKHZpc2liaWxpdHlJbmZvKTtcbn07XG5TZWxlY3Rvci5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuU2VsZWN0b3IucHJvdG90eXBlLnR5cGUgPSBcIlNlbGVjdG9yXCI7XG5TZWxlY3Rvci5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50cykge1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gdmlzaXRvci52aXNpdEFycmF5KHRoaXMuZWxlbWVudHMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5leHRlbmRMaXN0KSB7XG4gICAgICAgIHRoaXMuZXh0ZW5kTGlzdCA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLmV4dGVuZExpc3QpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSB2aXNpdG9yLnZpc2l0KHRoaXMuY29uZGl0aW9uKTtcbiAgICB9XG59O1xuU2VsZWN0b3IucHJvdG90eXBlLmNyZWF0ZURlcml2ZWQgPSBmdW5jdGlvbihlbGVtZW50cywgZXh0ZW5kTGlzdCwgZXZhbGRDb25kaXRpb24pIHtcbiAgICB2YXIgaW5mbyA9IHRoaXMudmlzaWJpbGl0eUluZm8oKTtcbiAgICBldmFsZENvbmRpdGlvbiA9IChldmFsZENvbmRpdGlvbiAhPSBudWxsKSA/IGV2YWxkQ29uZGl0aW9uIDogdGhpcy5ldmFsZENvbmRpdGlvbjtcbiAgICB2YXIgbmV3U2VsZWN0b3IgPSBuZXcgU2VsZWN0b3IoZWxlbWVudHMsIGV4dGVuZExpc3QgfHwgdGhpcy5leHRlbmRMaXN0LCBudWxsLCB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbywgaW5mbyk7XG4gICAgbmV3U2VsZWN0b3IuZXZhbGRDb25kaXRpb24gPSBldmFsZENvbmRpdGlvbjtcbiAgICBuZXdTZWxlY3Rvci5tZWRpYUVtcHR5ID0gdGhpcy5tZWRpYUVtcHR5O1xuICAgIHJldHVybiBuZXdTZWxlY3Rvcjtcbn07XG5TZWxlY3Rvci5wcm90b3R5cGUuY3JlYXRlRW1wdHlTZWxlY3RvcnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZWwgPSBuZXcgRWxlbWVudCgnJywgJyYnLCB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbyksXG4gICAgICAgIHNlbHMgPSBbbmV3IFNlbGVjdG9yKFtlbF0sIG51bGwsIG51bGwsIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvKV07XG4gICAgc2Vsc1swXS5tZWRpYUVtcHR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gc2Vscztcbn07XG5TZWxlY3Rvci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLFxuICAgICAgICBsZW4gPSBlbGVtZW50cy5sZW5ndGgsXG4gICAgICAgIG9sZW4sIGk7XG5cbiAgICBvdGhlci5DYWNoZUVsZW1lbnRzKCk7XG5cbiAgICBvbGVuID0gb3RoZXIuX2VsZW1lbnRzLmxlbmd0aDtcbiAgICBpZiAob2xlbiA9PT0gMCB8fCBsZW4gPCBvbGVuKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50c1tpXS52YWx1ZSAhPT0gb3RoZXIuX2VsZW1lbnRzW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2xlbjsgLy8gcmV0dXJuIG51bWJlciBvZiBtYXRjaGVkIGVsZW1lbnRzXG59O1xuU2VsZWN0b3IucHJvdG90eXBlLkNhY2hlRWxlbWVudHMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMubWFwKCBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB2LmNvbWJpbmF0b3IudmFsdWUgKyAodi52YWx1ZS52YWx1ZSB8fCB2LnZhbHVlKTtcbiAgICB9KS5qb2luKFwiXCIpLm1hdGNoKC9bLCYjXFwqXFwuXFx3LV0oW1xcdy1dfChcXFxcLikpKi9nKTtcblxuICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICBpZiAoZWxlbWVudHNbMF0gPT09IFwiJlwiKSB7XG4gICAgICAgICAgICBlbGVtZW50cy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudHMgPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50cyA9IGVsZW1lbnRzO1xufTtcblNlbGVjdG9yLnByb3RvdHlwZS5pc0p1c3RQYXJlbnRTZWxlY3RvciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5tZWRpYUVtcHR5ICYmXG4gICAgICAgIHRoaXMuZWxlbWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgIHRoaXMuZWxlbWVudHNbMF0udmFsdWUgPT09ICcmJyAmJlxuICAgICAgICAodGhpcy5lbGVtZW50c1swXS5jb21iaW5hdG9yLnZhbHVlID09PSAnICcgfHwgdGhpcy5lbGVtZW50c1swXS5jb21iaW5hdG9yLnZhbHVlID09PSAnJyk7XG59O1xuU2VsZWN0b3IucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBldmFsZENvbmRpdGlvbiA9IHRoaXMuY29uZGl0aW9uICYmIHRoaXMuY29uZGl0aW9uLmV2YWwoY29udGV4dCksXG4gICAgICAgIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cywgZXh0ZW5kTGlzdCA9IHRoaXMuZXh0ZW5kTGlzdDtcblxuICAgIGVsZW1lbnRzID0gZWxlbWVudHMgJiYgZWxlbWVudHMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmV2YWwoY29udGV4dCk7IH0pO1xuICAgIGV4dGVuZExpc3QgPSBleHRlbmRMaXN0ICYmIGV4dGVuZExpc3QubWFwKGZ1bmN0aW9uKGV4dGVuZCkgeyByZXR1cm4gZXh0ZW5kLmV2YWwoY29udGV4dCk7IH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlRGVyaXZlZChlbGVtZW50cywgZXh0ZW5kTGlzdCwgZXZhbGRDb25kaXRpb24pO1xufTtcblNlbGVjdG9yLnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgdmFyIGksIGVsZW1lbnQ7XG4gICAgaWYgKCghY29udGV4dCB8fCAhY29udGV4dC5maXJzdFNlbGVjdG9yKSAmJiB0aGlzLmVsZW1lbnRzWzBdLmNvbWJpbmF0b3IudmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgb3V0cHV0LmFkZCgnICcsIHRoaXMuY3VycmVudEZpbGVJbmZvLCB0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9jc3MpIHtcbiAgICAgICAgLy9UT0RPIGNhY2hpbmc/IHNwZWVkIGNvbXBhcmlzb24/XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1tpXTtcbiAgICAgICAgICAgIGVsZW1lbnQuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuU2VsZWN0b3IucHJvdG90eXBlLmdldElzT3V0cHV0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZXZhbGRDb25kaXRpb247XG59O1xubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3RvcjtcblxufSx7XCIuL2VsZW1lbnRcIjo1OCxcIi4vbm9kZVwiOjcwfV0sNzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpO1xuXG52YXIgVW5pY29kZURlc2NyaXB0b3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG59O1xuVW5pY29kZURlc2NyaXB0b3IucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblVuaWNvZGVEZXNjcmlwdG9yLnByb3RvdHlwZS50eXBlID0gXCJVbmljb2RlRGVzY3JpcHRvclwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuaWNvZGVEZXNjcmlwdG9yO1xuXG59LHtcIi4vbm9kZVwiOjcwfV0sNzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpLFxuICAgIHVuaXRDb252ZXJzaW9ucyA9IHJlcXVpcmUoXCIuLi9kYXRhL3VuaXQtY29udmVyc2lvbnNcIik7XG5cbnZhciBVbml0ID0gZnVuY3Rpb24gKG51bWVyYXRvciwgZGVub21pbmF0b3IsIGJhY2t1cFVuaXQpIHtcbiAgICB0aGlzLm51bWVyYXRvciA9IG51bWVyYXRvciA/IG51bWVyYXRvci5zbGljZSgwKS5zb3J0KCkgOiBbXTtcbiAgICB0aGlzLmRlbm9taW5hdG9yID0gZGVub21pbmF0b3IgPyBkZW5vbWluYXRvci5zbGljZSgwKS5zb3J0KCkgOiBbXTtcbiAgICBpZiAoYmFja3VwVW5pdCkge1xuICAgICAgICB0aGlzLmJhY2t1cFVuaXQgPSBiYWNrdXBVbml0O1xuICAgIH0gZWxzZSBpZiAobnVtZXJhdG9yICYmIG51bWVyYXRvci5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5iYWNrdXBVbml0ID0gbnVtZXJhdG9yWzBdO1xuICAgIH1cbn07XG5cblVuaXQucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblVuaXQucHJvdG90eXBlLnR5cGUgPSBcIlVuaXRcIjtcblVuaXQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgVW5pdCh0aGlzLm51bWVyYXRvci5zbGljZSgwKSwgdGhpcy5kZW5vbWluYXRvci5zbGljZSgwKSwgdGhpcy5iYWNrdXBVbml0KTtcbn07XG5Vbml0LnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgLy8gRGltZW5zaW9uIGNoZWNrcyB0aGUgdW5pdCBpcyBzaW5ndWxhciBhbmQgdGhyb3dzIGFuIGVycm9yIGlmIGluIHN0cmljdCBtYXRoIG1vZGUuXG4gICAgdmFyIHN0cmljdFVuaXRzID0gY29udGV4dCAmJiBjb250ZXh0LnN0cmljdFVuaXRzO1xuICAgIGlmICh0aGlzLm51bWVyYXRvci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgb3V0cHV0LmFkZCh0aGlzLm51bWVyYXRvclswXSk7IC8vIHRoZSBpZGVhbCBzaXR1YXRpb25cbiAgICB9IGVsc2UgaWYgKCFzdHJpY3RVbml0cyAmJiB0aGlzLmJhY2t1cFVuaXQpIHtcbiAgICAgICAgb3V0cHV0LmFkZCh0aGlzLmJhY2t1cFVuaXQpO1xuICAgIH0gZWxzZSBpZiAoIXN0cmljdFVuaXRzICYmIHRoaXMuZGVub21pbmF0b3IubGVuZ3RoKSB7XG4gICAgICAgIG91dHB1dC5hZGQodGhpcy5kZW5vbWluYXRvclswXSk7XG4gICAgfVxufTtcblVuaXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpLCByZXR1cm5TdHIgPSB0aGlzLm51bWVyYXRvci5qb2luKFwiKlwiKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5kZW5vbWluYXRvci5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXR1cm5TdHIgKz0gXCIvXCIgKyB0aGlzLmRlbm9taW5hdG9yW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuU3RyO1xufTtcblVuaXQucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5pcyhvdGhlci50b1N0cmluZygpKSA/IDAgOiB1bmRlZmluZWQ7XG59O1xuVW5pdC5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbiAodW5pdFN0cmluZykge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKSA9PT0gdW5pdFN0cmluZy50b1VwcGVyQ2FzZSgpO1xufTtcblVuaXQucHJvdG90eXBlLmlzTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMudG9DU1MoKS5tYXRjaCgvcHh8ZW18JXxpbnxjbXxtbXxwY3xwdHxleC8pKTtcbn07XG5Vbml0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm51bWVyYXRvci5sZW5ndGggPT09IDAgJiYgdGhpcy5kZW5vbWluYXRvci5sZW5ndGggPT09IDA7XG59O1xuVW5pdC5wcm90b3R5cGUuaXNTaW5ndWxhciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm51bWVyYXRvci5sZW5ndGggPD0gMSAmJiB0aGlzLmRlbm9taW5hdG9yLmxlbmd0aCA9PT0gMDtcbn07XG5Vbml0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubnVtZXJhdG9yLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMubnVtZXJhdG9yW2ldID0gY2FsbGJhY2sodGhpcy5udW1lcmF0b3JbaV0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5kZW5vbWluYXRvci5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmRlbm9taW5hdG9yW2ldID0gY2FsbGJhY2sodGhpcy5kZW5vbWluYXRvcltpXSwgdHJ1ZSk7XG4gICAgfVxufTtcblVuaXQucHJvdG90eXBlLnVzZWRVbml0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBncm91cCwgcmVzdWx0ID0ge30sIG1hcFVuaXQsIGdyb3VwTmFtZTtcblxuICAgIG1hcFVuaXQgPSBmdW5jdGlvbiAoYXRvbWljVW5pdCkge1xuICAgICAgICAvKmpzaGludCBsb29wZnVuYzp0cnVlICovXG4gICAgICAgIGlmIChncm91cC5oYXNPd25Qcm9wZXJ0eShhdG9taWNVbml0KSAmJiAhcmVzdWx0W2dyb3VwTmFtZV0pIHtcbiAgICAgICAgICAgIHJlc3VsdFtncm91cE5hbWVdID0gYXRvbWljVW5pdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhdG9taWNVbml0O1xuICAgIH07XG5cbiAgICBmb3IgKGdyb3VwTmFtZSBpbiB1bml0Q29udmVyc2lvbnMpIHtcbiAgICAgICAgaWYgKHVuaXRDb252ZXJzaW9ucy5oYXNPd25Qcm9wZXJ0eShncm91cE5hbWUpKSB7XG4gICAgICAgICAgICBncm91cCA9IHVuaXRDb252ZXJzaW9uc1tncm91cE5hbWVdO1xuXG4gICAgICAgICAgICB0aGlzLm1hcChtYXBVbml0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuVW5pdC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb3VudGVyID0ge30sIGF0b21pY1VuaXQsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5udW1lcmF0b3IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXRvbWljVW5pdCA9IHRoaXMubnVtZXJhdG9yW2ldO1xuICAgICAgICBjb3VudGVyW2F0b21pY1VuaXRdID0gKGNvdW50ZXJbYXRvbWljVW5pdF0gfHwgMCkgKyAxO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRlbm9taW5hdG9yLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGF0b21pY1VuaXQgPSB0aGlzLmRlbm9taW5hdG9yW2ldO1xuICAgICAgICBjb3VudGVyW2F0b21pY1VuaXRdID0gKGNvdW50ZXJbYXRvbWljVW5pdF0gfHwgMCkgLSAxO1xuICAgIH1cblxuICAgIHRoaXMubnVtZXJhdG9yID0gW107XG4gICAgdGhpcy5kZW5vbWluYXRvciA9IFtdO1xuXG4gICAgZm9yIChhdG9taWNVbml0IGluIGNvdW50ZXIpIHtcbiAgICAgICAgaWYgKGNvdW50ZXIuaGFzT3duUHJvcGVydHkoYXRvbWljVW5pdCkpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IGNvdW50ZXJbYXRvbWljVW5pdF07XG5cbiAgICAgICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm51bWVyYXRvci5wdXNoKGF0b21pY1VuaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IC1jb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVub21pbmF0b3IucHVzaChhdG9taWNVbml0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm51bWVyYXRvci5zb3J0KCk7XG4gICAgdGhpcy5kZW5vbWluYXRvci5zb3J0KCk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBVbml0O1xuXG59LHtcIi4uL2RhdGEvdW5pdC1jb252ZXJzaW9uc1wiOjE0LFwiLi9ub2RlXCI6NzB9XSw4MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIik7XG5cbnZhciBVUkwgPSBmdW5jdGlvbiAodmFsLCBpbmRleCwgY3VycmVudEZpbGVJbmZvLCBpc0V2YWxkKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbDtcbiAgICB0aGlzLmN1cnJlbnRGaWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5pc0V2YWxkID0gaXNFdmFsZDtcbn07XG5VUkwucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblVSTC5wcm90b3R5cGUudHlwZSA9IFwiVXJsXCI7XG5VUkwucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZpc2l0b3IudmlzaXQodGhpcy52YWx1ZSk7XG59O1xuVVJMLnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XG4gICAgb3V0cHV0LmFkZChcInVybChcIik7XG4gICAgdGhpcy52YWx1ZS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcbiAgICBvdXRwdXQuYWRkKFwiKVwiKTtcbn07XG5VUkwucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciB2YWwgPSB0aGlzLnZhbHVlLmV2YWwoY29udGV4dCksXG4gICAgICAgIHJvb3RwYXRoO1xuXG4gICAgaWYgKCF0aGlzLmlzRXZhbGQpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBiYXNlIHBhdGggaWYgdGhlIFVSTCBpcyByZWxhdGl2ZVxuICAgICAgICByb290cGF0aCA9IHRoaXMuY3VycmVudEZpbGVJbmZvICYmIHRoaXMuY3VycmVudEZpbGVJbmZvLnJvb3RwYXRoO1xuICAgICAgICBpZiAocm9vdHBhdGggJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWwudmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgIGNvbnRleHQuaXNQYXRoUmVsYXRpdmUodmFsLnZhbHVlKSkge1xuXG4gICAgICAgICAgICBpZiAoIXZhbC5xdW90ZSkge1xuICAgICAgICAgICAgICAgIHJvb3RwYXRoID0gcm9vdHBhdGgucmVwbGFjZSgvW1xcKFxcKSdcIlxcc10vZywgZnVuY3Rpb24obWF0Y2gpIHsgcmV0dXJuIFwiXFxcXFwiICsgbWF0Y2g7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsLnZhbHVlID0gcm9vdHBhdGggKyB2YWwudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YWwudmFsdWUgPSBjb250ZXh0Lm5vcm1hbGl6ZVBhdGgodmFsLnZhbHVlKTtcblxuICAgICAgICAvLyBBZGQgdXJsIGFyZ3MgaWYgZW5hYmxlZFxuICAgICAgICBpZiAoY29udGV4dC51cmxBcmdzKSB7XG4gICAgICAgICAgICBpZiAoIXZhbC52YWx1ZS5tYXRjaCgvXlxccypkYXRhOi8pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbGltaXRlciA9IHZhbC52YWx1ZS5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnO1xuICAgICAgICAgICAgICAgIHZhciB1cmxBcmdzID0gZGVsaW1pdGVyICsgY29udGV4dC51cmxBcmdzO1xuICAgICAgICAgICAgICAgIGlmICh2YWwudmFsdWUuaW5kZXhPZignIycpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwudmFsdWUgPSB2YWwudmFsdWUucmVwbGFjZSgnIycsIHVybEFyZ3MgKyAnIycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbC52YWx1ZSArPSB1cmxBcmdzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgVVJMKHZhbCwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8sIHRydWUpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gVVJMO1xuXG59LHtcIi4vbm9kZVwiOjcwfV0sODE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpO1xuXG52YXIgVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZSByZXF1aXJlcyBhbiBhcnJheSBhcmd1bWVudFwiKTtcbiAgICB9XG59O1xuVmFsdWUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblZhbHVlLnByb3RvdHlwZS50eXBlID0gXCJWYWx1ZVwiO1xuVmFsdWUucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLnZhbHVlKTtcbiAgICB9XG59O1xuVmFsdWUucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVswXS5ldmFsKGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWUodGhpcy52YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2LmV2YWwoY29udGV4dCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG59O1xuVmFsdWUucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnZhbHVlW2ldLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xuICAgICAgICBpZiAoaSArIDEgPCB0aGlzLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgb3V0cHV0LmFkZCgoY29udGV4dCAmJiBjb250ZXh0LmNvbXByZXNzKSA/ICcsJyA6ICcsICcpO1xuICAgICAgICB9XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gVmFsdWU7XG5cbn0se1wiLi9ub2RlXCI6NzB9XSw4MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIik7XG5cbnZhciBWYXJpYWJsZSA9IGZ1bmN0aW9uIChuYW1lLCBpbmRleCwgY3VycmVudEZpbGVJbmZvKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5jdXJyZW50RmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm8gfHwge307XG59O1xuVmFyaWFibGUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblZhcmlhYmxlLnByb3RvdHlwZS50eXBlID0gXCJWYXJpYWJsZVwiO1xuVmFyaWFibGUucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciB2YXJpYWJsZSwgbmFtZSA9IHRoaXMubmFtZTtcblxuICAgIGlmIChuYW1lLmluZGV4T2YoJ0BAJykgPT09IDApIHtcbiAgICAgICAgbmFtZSA9ICdAJyArIG5ldyBWYXJpYWJsZShuYW1lLnNsaWNlKDEpLCB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbykuZXZhbChjb250ZXh0KS52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ldmFsdWF0aW5nKSB7XG4gICAgICAgIHRocm93IHsgdHlwZTogJ05hbWUnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiUmVjdXJzaXZlIHZhcmlhYmxlIGRlZmluaXRpb24gZm9yIFwiICsgbmFtZSxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5jdXJyZW50RmlsZUluZm8uZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXggfTtcbiAgICB9XG5cbiAgICB0aGlzLmV2YWx1YXRpbmcgPSB0cnVlO1xuXG4gICAgdmFyaWFibGUgPSB0aGlzLmZpbmQoY29udGV4dC5mcmFtZXMsIGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICB2YXIgdiA9IGZyYW1lLnZhcmlhYmxlKG5hbWUpO1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgaWYgKHYuaW1wb3J0YW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGltcG9ydGFudFNjb3BlID0gY29udGV4dC5pbXBvcnRhbnRTY29wZVtjb250ZXh0LmltcG9ydGFudFNjb3BlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGltcG9ydGFudFNjb3BlLmltcG9ydGFudCA9IHYuaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHYudmFsdWUuZXZhbChjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh2YXJpYWJsZSkge1xuICAgICAgICB0aGlzLmV2YWx1YXRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHsgdHlwZTogJ05hbWUnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwidmFyaWFibGUgXCIgKyBuYW1lICsgXCIgaXMgdW5kZWZpbmVkXCIsXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuY3VycmVudEZpbGVJbmZvLmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4IH07XG4gICAgfVxufTtcblZhcmlhYmxlLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKG9iaiwgZnVuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgciA9IGZ1bi5jYWxsKG9iaiwgb2JqW2ldKTtcbiAgICAgICAgaWYgKHIpIHsgcmV0dXJuIHI7IH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBWYXJpYWJsZTtcblxufSx7XCIuL25vZGVcIjo3MH1dLDgzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldExvY2F0aW9uOiBmdW5jdGlvbihpbmRleCwgaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgdmFyIG4gPSBpbmRleCArIDEsXG4gICAgICAgICAgICBsaW5lID0gbnVsbCxcbiAgICAgICAgICAgIGNvbHVtbiA9IC0xO1xuXG4gICAgICAgIHdoaWxlICgtLW4gPj0gMCAmJiBpbnB1dFN0cmVhbS5jaGFyQXQobikgIT09ICdcXG4nKSB7XG4gICAgICAgICAgICBjb2x1bW4rKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBsaW5lID0gKGlucHV0U3RyZWFtLnNsaWNlKDAsIGluZGV4KS5tYXRjaCgvXFxuL2cpIHx8IFwiXCIpLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG59LHt9XSw4NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdHJlZSA9IHJlcXVpcmUoXCIuLi90cmVlXCIpLFxuICAgIFZpc2l0b3IgPSByZXF1aXJlKFwiLi92aXNpdG9yXCIpLFxuICAgIGxvZ2dlciA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XG5cbi8qanNoaW50IGxvb3BmdW5jOnRydWUgKi9cblxudmFyIEV4dGVuZEZpbmRlclZpc2l0b3IgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl92aXNpdG9yID0gbmV3IFZpc2l0b3IodGhpcyk7XG4gICAgdGhpcy5jb250ZXh0cyA9IFtdO1xuICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrID0gW1tdXTtcbn07XG5cbkV4dGVuZEZpbmRlclZpc2l0b3IucHJvdG90eXBlID0ge1xuICAgIHJ1bjogZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgcm9vdCA9IHRoaXMuX3Zpc2l0b3IudmlzaXQocm9vdCk7XG4gICAgICAgIHJvb3QuYWxsRXh0ZW5kcyA9IHRoaXMuYWxsRXh0ZW5kc1N0YWNrWzBdO1xuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9LFxuICAgIHZpc2l0UnVsZTogZnVuY3Rpb24gKHJ1bGVOb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgdmlzaXRBcmdzLnZpc2l0RGVlcGVyID0gZmFsc2U7XG4gICAgfSxcbiAgICB2aXNpdE1peGluRGVmaW5pdGlvbjogZnVuY3Rpb24gKG1peGluRGVmaW5pdGlvbk5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcbiAgICB9LFxuICAgIHZpc2l0UnVsZXNldDogZnVuY3Rpb24gKHJ1bGVzZXROb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgaWYgKHJ1bGVzZXROb2RlLnJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpLCBqLCBleHRlbmQsIGFsbFNlbGVjdG9yc0V4dGVuZExpc3QgPSBbXSwgZXh0ZW5kTGlzdDtcblxuICAgICAgICAvLyBnZXQgJjpleHRlbmQoLmEpOyBydWxlcyB3aGljaCBhcHBseSB0byBhbGwgc2VsZWN0b3JzIGluIHRoaXMgcnVsZXNldFxuICAgICAgICB2YXIgcnVsZXMgPSBydWxlc2V0Tm9kZS5ydWxlcywgcnVsZUNudCA9IHJ1bGVzID8gcnVsZXMubGVuZ3RoIDogMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJ1bGVDbnQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJ1bGVzZXROb2RlLnJ1bGVzW2ldIGluc3RhbmNlb2YgdHJlZS5FeHRlbmQpIHtcbiAgICAgICAgICAgICAgICBhbGxTZWxlY3RvcnNFeHRlbmRMaXN0LnB1c2gocnVsZXNbaV0pO1xuICAgICAgICAgICAgICAgIHJ1bGVzZXROb2RlLmV4dGVuZE9uRXZlcnlQYXRoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdyBmaW5kIGV2ZXJ5IHNlbGVjdG9yIGFuZCBhcHBseSB0aGUgZXh0ZW5kcyB0aGF0IGFwcGx5IHRvIGFsbCBleHRlbmRzXG4gICAgICAgIC8vIGFuZCB0aGUgb25lcyB3aGljaCBhcHBseSB0byBhbiBpbmRpdmlkdWFsIGV4dGVuZFxuICAgICAgICB2YXIgcGF0aHMgPSBydWxlc2V0Tm9kZS5wYXRocztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JQYXRoID0gcGF0aHNbaV0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvclBhdGhbc2VsZWN0b3JQYXRoLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIHNlbEV4dGVuZExpc3QgPSBzZWxlY3Rvci5leHRlbmRMaXN0O1xuXG4gICAgICAgICAgICBleHRlbmRMaXN0ID0gc2VsRXh0ZW5kTGlzdCA/IHNlbEV4dGVuZExpc3Quc2xpY2UoMCkuY29uY2F0KGFsbFNlbGVjdG9yc0V4dGVuZExpc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFsbFNlbGVjdG9yc0V4dGVuZExpc3Q7XG5cbiAgICAgICAgICAgIGlmIChleHRlbmRMaXN0KSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5kTGlzdCA9IGV4dGVuZExpc3QubWFwKGZ1bmN0aW9uKGFsbFNlbGVjdG9yc0V4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsU2VsZWN0b3JzRXh0ZW5kLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBleHRlbmRMaXN0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3VuZEV4dGVuZHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGV4dGVuZCA9IGV4dGVuZExpc3Rbal07XG4gICAgICAgICAgICAgICAgZXh0ZW5kLmZpbmRTZWxmU2VsZWN0b3JzKHNlbGVjdG9yUGF0aCk7XG4gICAgICAgICAgICAgICAgZXh0ZW5kLnJ1bGVzZXQgPSBydWxlc2V0Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCkgeyBleHRlbmQuZmlyc3RFeHRlbmRPblRoaXNTZWxlY3RvclBhdGggPSB0cnVlOyB9XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxFeHRlbmRzU3RhY2tbdGhpcy5hbGxFeHRlbmRzU3RhY2subGVuZ3RoIC0gMV0ucHVzaChleHRlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb250ZXh0cy5wdXNoKHJ1bGVzZXROb2RlLnNlbGVjdG9ycyk7XG4gICAgfSxcbiAgICB2aXNpdFJ1bGVzZXRPdXQ6IGZ1bmN0aW9uIChydWxlc2V0Tm9kZSkge1xuICAgICAgICBpZiAoIXJ1bGVzZXROb2RlLnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMubGVuZ3RoID0gdGhpcy5jb250ZXh0cy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB2aXNpdE1lZGlhOiBmdW5jdGlvbiAobWVkaWFOb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgbWVkaWFOb2RlLmFsbEV4dGVuZHMgPSBbXTtcbiAgICAgICAgdGhpcy5hbGxFeHRlbmRzU3RhY2sucHVzaChtZWRpYU5vZGUuYWxsRXh0ZW5kcyk7XG4gICAgfSxcbiAgICB2aXNpdE1lZGlhT3V0OiBmdW5jdGlvbiAobWVkaWFOb2RlKSB7XG4gICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCA9IHRoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCAtIDE7XG4gICAgfSxcbiAgICB2aXNpdERpcmVjdGl2ZTogZnVuY3Rpb24gKGRpcmVjdGl2ZU5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICBkaXJlY3RpdmVOb2RlLmFsbEV4dGVuZHMgPSBbXTtcbiAgICAgICAgdGhpcy5hbGxFeHRlbmRzU3RhY2sucHVzaChkaXJlY3RpdmVOb2RlLmFsbEV4dGVuZHMpO1xuICAgIH0sXG4gICAgdmlzaXREaXJlY3RpdmVPdXQ6IGZ1bmN0aW9uIChkaXJlY3RpdmVOb2RlKSB7XG4gICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCA9IHRoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCAtIDE7XG4gICAgfVxufTtcblxudmFyIFByb2Nlc3NFeHRlbmRzVmlzaXRvciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3Zpc2l0b3IgPSBuZXcgVmlzaXRvcih0aGlzKTtcbn07XG5cblByb2Nlc3NFeHRlbmRzVmlzaXRvci5wcm90b3R5cGUgPSB7XG4gICAgcnVuOiBmdW5jdGlvbihyb290KSB7XG4gICAgICAgIHZhciBleHRlbmRGaW5kZXIgPSBuZXcgRXh0ZW5kRmluZGVyVmlzaXRvcigpO1xuICAgICAgICB0aGlzLmV4dGVuZEluZGljZXMgPSB7fTtcbiAgICAgICAgZXh0ZW5kRmluZGVyLnJ1bihyb290KTtcbiAgICAgICAgaWYgKCFleHRlbmRGaW5kZXIuZm91bmRFeHRlbmRzKSB7IHJldHVybiByb290OyB9XG4gICAgICAgIHJvb3QuYWxsRXh0ZW5kcyA9IHJvb3QuYWxsRXh0ZW5kcy5jb25jYXQodGhpcy5kb0V4dGVuZENoYWluaW5nKHJvb3QuYWxsRXh0ZW5kcywgcm9vdC5hbGxFeHRlbmRzKSk7XG4gICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrID0gW3Jvb3QuYWxsRXh0ZW5kc107XG4gICAgICAgIHZhciBuZXdSb290ID0gdGhpcy5fdmlzaXRvci52aXNpdChyb290KTtcbiAgICAgICAgdGhpcy5jaGVja0V4dGVuZHNGb3JOb25NYXRjaGVkKHJvb3QuYWxsRXh0ZW5kcyk7XG4gICAgICAgIHJldHVybiBuZXdSb290O1xuICAgIH0sXG4gICAgY2hlY2tFeHRlbmRzRm9yTm9uTWF0Y2hlZDogZnVuY3Rpb24oZXh0ZW5kTGlzdCkge1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuZXh0ZW5kSW5kaWNlcztcbiAgICAgICAgZXh0ZW5kTGlzdC5maWx0ZXIoZnVuY3Rpb24oZXh0ZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gIWV4dGVuZC5oYXNGb3VuZE1hdGNoZXMgJiYgZXh0ZW5kLnBhcmVudF9pZHMubGVuZ3RoID09IDE7XG4gICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24oZXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gXCJfdW5rbm93bl9cIjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IGV4dGVuZC5zZWxlY3Rvci50b0NTUyh7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoKF8pIHt9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWluZGljZXNbZXh0ZW5kLmluZGV4ICsgJyAnICsgc2VsZWN0b3JdKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGljZXNbZXh0ZW5kLmluZGV4ICsgJyAnICsgc2VsZWN0b3JdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJleHRlbmQgJ1wiICsgc2VsZWN0b3IgKyBcIicgaGFzIG5vIG1hdGNoZXNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfSxcbiAgICBkb0V4dGVuZENoYWluaW5nOiBmdW5jdGlvbiAoZXh0ZW5kc0xpc3QsIGV4dGVuZHNMaXN0VGFyZ2V0LCBpdGVyYXRpb25Db3VudCkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBjaGFpbmluZyBpcyBkaWZmZXJlbnQgZnJvbSBub3JtYWwgZXh0ZW5zaW9uLi4gaWYgd2UgZXh0ZW5kIGFuIGV4dGVuZCB0aGVuIHdlIGFyZSBub3QganVzdCBjb3B5aW5nLCBhbHRlcmluZ1xuICAgICAgICAvLyBhbmQgcGFzdGluZyB0aGUgc2VsZWN0b3Igd2Ugd291bGQgZG8gbm9ybWFsbHksIGJ1dCB3ZSBhcmUgYWxzbyBhZGRpbmcgYW4gZXh0ZW5kIHdpdGggdGhlIHNhbWUgdGFyZ2V0IHNlbGVjdG9yXG4gICAgICAgIC8vIHRoaXMgbWVhbnMgdGhpcyBuZXcgZXh0ZW5kIGNhbiB0aGVuIGdvIGFuZCBhbHRlciBvdGhlciBleHRlbmRzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGRlYWxzIHdpdGggYWxsIHRoZSBjaGFpbmluZyB3b3JrIC0gd2l0aG91dCBpdCwgZXh0ZW5kIGlzIGZsYXQgYW5kIGRvZXNuJ3Qgd29yayBvbiBvdGhlciBleHRlbmQgc2VsZWN0b3JzXG4gICAgICAgIC8vIHRoaXMgaXMgYWxzbyB0aGUgbW9zdCBleHBlbnNpdmUuLiBhbmQgYSBtYXRjaCBvbiBvbmUgc2VsZWN0b3IgY2FuIGNhdXNlIGFuIGV4dGVuc2lvbiBvZiBhIHNlbGVjdG9yIHdlIGhhZCBhbHJlYWR5XG4gICAgICAgIC8vIHByb2Nlc3NlZCBpZiB3ZSBsb29rIGF0IGVhY2ggc2VsZWN0b3IgYXQgYSB0aW1lLCBhcyBpcyBkb25lIGluIHZpc2l0UnVsZXNldFxuXG4gICAgICAgIHZhciBleHRlbmRJbmRleCwgdGFyZ2V0RXh0ZW5kSW5kZXgsIG1hdGNoZXMsIGV4dGVuZHNUb0FkZCA9IFtdLCBuZXdTZWxlY3RvciwgZXh0ZW5kVmlzaXRvciA9IHRoaXMsIHNlbGVjdG9yUGF0aCxcbiAgICAgICAgICAgIGV4dGVuZCwgdGFyZ2V0RXh0ZW5kLCBuZXdFeHRlbmQ7XG5cbiAgICAgICAgaXRlcmF0aW9uQ291bnQgPSBpdGVyYXRpb25Db3VudCB8fCAwO1xuXG4gICAgICAgIC8vbG9vcCB0aHJvdWdoIGNvbXBhcmluZyBldmVyeSBleHRlbmQgd2l0aCBldmVyeSB0YXJnZXQgZXh0ZW5kLlxuICAgICAgICAvLyBhIHRhcmdldCBleHRlbmQgaXMgdGhlIG9uZSBvbiB0aGUgcnVsZXNldCB3ZSBhcmUgbG9va2luZyBhdCBjb3B5L2VkaXQvcGFzdGluZyBpbiBwbGFjZVxuICAgICAgICAvLyBlLmcuICAuYTpleHRlbmQoLmIpIHt9ICBhbmQgLmI6ZXh0ZW5kKC5jKSB7fSB0aGVuIHRoZSBmaXJzdCBleHRlbmQgZXh0ZW5kcyB0aGUgc2Vjb25kIG9uZVxuICAgICAgICAvLyBhbmQgdGhlIHNlY29uZCBpcyB0aGUgdGFyZ2V0LlxuICAgICAgICAvLyB0aGUgc2VwYXJhdGlvbiBpbnRvIHR3byBsaXN0cyBhbGxvd3MgdXMgdG8gcHJvY2VzcyBhIHN1YnNldCBvZiBjaGFpbnMgd2l0aCBhIGJpZ2dlciBzZXQsIGFzIGlzIHRoZVxuICAgICAgICAvLyBjYXNlIHdoZW4gcHJvY2Vzc2luZyBtZWRpYSBxdWVyaWVzXG4gICAgICAgIGZvciAoZXh0ZW5kSW5kZXggPSAwOyBleHRlbmRJbmRleCA8IGV4dGVuZHNMaXN0Lmxlbmd0aDsgZXh0ZW5kSW5kZXgrKykge1xuICAgICAgICAgICAgZm9yICh0YXJnZXRFeHRlbmRJbmRleCA9IDA7IHRhcmdldEV4dGVuZEluZGV4IDwgZXh0ZW5kc0xpc3RUYXJnZXQubGVuZ3RoOyB0YXJnZXRFeHRlbmRJbmRleCsrKSB7XG5cbiAgICAgICAgICAgICAgICBleHRlbmQgPSBleHRlbmRzTGlzdFtleHRlbmRJbmRleF07XG4gICAgICAgICAgICAgICAgdGFyZ2V0RXh0ZW5kID0gZXh0ZW5kc0xpc3RUYXJnZXRbdGFyZ2V0RXh0ZW5kSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgLy8gbG9vayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgICAgICAgICAgICAgIGlmICggZXh0ZW5kLnBhcmVudF9pZHMuaW5kZXhPZiggdGFyZ2V0RXh0ZW5kLm9iamVjdF9pZCApID49IDAgKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICAgICAgICAvLyBmaW5kIGEgbWF0Y2ggaW4gdGhlIHRhcmdldCBleHRlbmRzIHNlbGYgc2VsZWN0b3IgKHRoZSBiaXQgYmVmb3JlIDpleHRlbmQpXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JQYXRoID0gW3RhcmdldEV4dGVuZC5zZWxmU2VsZWN0b3JzWzBdXTtcbiAgICAgICAgICAgICAgICBtYXRjaGVzID0gZXh0ZW5kVmlzaXRvci5maW5kTWF0Y2goZXh0ZW5kLCBzZWxlY3RvclBhdGgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZC5oYXNGb3VuZE1hdGNoZXMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGZvdW5kIGEgbWF0Y2gsIHNvIGZvciBlYWNoIHNlbGYgc2VsZWN0b3IuLlxuICAgICAgICAgICAgICAgICAgICBleHRlbmQuc2VsZlNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKHNlbGZTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSB0YXJnZXRFeHRlbmQudmlzaWJpbGl0eUluZm8oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2VzcyB0aGUgZXh0ZW5kIGFzIHVzdWFsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RvciA9IGV4dGVuZFZpc2l0b3IuZXh0ZW5kU2VsZWN0b3IobWF0Y2hlcywgc2VsZWN0b3JQYXRoLCBzZWxmU2VsZWN0b3IsIGV4dGVuZC5pc1Zpc2libGUoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBub3cgd2UgY3JlYXRlIGEgbmV3IGV4dGVuZCBmcm9tIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdFeHRlbmQgPSBuZXcodHJlZS5FeHRlbmQpKHRhcmdldEV4dGVuZC5zZWxlY3RvciwgdGFyZ2V0RXh0ZW5kLm9wdGlvbiwgMCwgdGFyZ2V0RXh0ZW5kLmN1cnJlbnRGaWxlSW5mbywgaW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdFeHRlbmQuc2VsZlNlbGVjdG9ycyA9IG5ld1NlbGVjdG9yO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGV4dGVuZCBvbnRvIHRoZSBsaXN0IG9mIGV4dGVuZHMgZm9yIHRoYXQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yW25ld1NlbGVjdG9yLmxlbmd0aCAtIDFdLmV4dGVuZExpc3QgPSBbbmV3RXh0ZW5kXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjb3JkIHRoYXQgd2UgbmVlZCB0byBhZGQgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRzVG9BZGQucHVzaChuZXdFeHRlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXh0ZW5kLnJ1bGVzZXQgPSB0YXJnZXRFeHRlbmQucnVsZXNldDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW1lbWJlciBpdHMgcGFyZW50cyBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXh0ZW5kLnBhcmVudF9pZHMgPSBuZXdFeHRlbmQucGFyZW50X2lkcy5jb25jYXQodGFyZ2V0RXh0ZW5kLnBhcmVudF9pZHMsIGV4dGVuZC5wYXJlbnRfaWRzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBwcm9jZXNzIHRoZSBzZWxlY3RvciBvbmNlLi4gaWYgd2UgaGF2ZSA6ZXh0ZW5kKC5hLC5iKSB0aGVuIG11bHRpcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBleHRlbmRzIHdpbGwgbG9vayBhdCB0aGUgc2FtZSBzZWxlY3RvciBwYXRoLCBzbyB3aGVuIGV4dGVuZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Uga25vdyB0aGF0IGFueSBvdGhlcnMgd2lsbCBiZSBkdXBsaWNhdGVzIGluIHRlcm1zIG9mIHdoYXQgaXMgYWRkZWQgdG8gdGhlIGNzc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEV4dGVuZC5maXJzdEV4dGVuZE9uVGhpc1NlbGVjdG9yUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V4dGVuZC5maXJzdEV4dGVuZE9uVGhpc1NlbGVjdG9yUGF0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RXh0ZW5kLnJ1bGVzZXQucGF0aHMucHVzaChuZXdTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRlbmRzVG9BZGQubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyB0cnkgdG8gZGV0ZWN0IGNpcmN1bGFyIHJlZmVyZW5jZXMgdG8gc3RvcCBhIHN0YWNrIG92ZXJmbG93LlxuICAgICAgICAgICAgLy8gbWF5IG5vIGxvbmdlciBiZSBuZWVkZWQuXG4gICAgICAgICAgICB0aGlzLmV4dGVuZENoYWluQ291bnQrKztcbiAgICAgICAgICAgIGlmIChpdGVyYXRpb25Db3VudCA+IDEwMCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rvck9uZSA9IFwie3VuYWJsZSB0byBjYWxjdWxhdGV9XCI7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yVHdvID0gXCJ7dW5hYmxlIHRvIGNhbGN1bGF0ZX1cIjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvck9uZSA9IGV4dGVuZHNUb0FkZFswXS5zZWxmU2VsZWN0b3JzWzBdLnRvQ1NTKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yVHdvID0gZXh0ZW5kc1RvQWRkWzBdLnNlbGVjdG9yLnRvQ1NTKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoKGUpIHt9XG4gICAgICAgICAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiBcImV4dGVuZCBjaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0ZWQuIE9uZSBvZiB0aGUgY2lyY3VsYXIgZXh0ZW5kcyBpcyBjdXJyZW50bHk6XCIgK1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvck9uZSArIFwiOmV4dGVuZChcIiArIHNlbGVjdG9yVHdvICsgXCIpXCJ9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub3cgcHJvY2VzcyB0aGUgbmV3IGV4dGVuZHMgb24gdGhlIGV4aXN0aW5nIHJ1bGVzIHNvIHRoYXQgd2UgY2FuIGhhbmRsZSBhIGV4dGVuZGluZyBiIGV4dGVuZGluZyBjIGV4dGVuZGluZ1xuICAgICAgICAgICAgLy8gZCBleHRlbmRpbmcgZS4uLlxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZHNUb0FkZC5jb25jYXQoZXh0ZW5kVmlzaXRvci5kb0V4dGVuZENoYWluaW5nKGV4dGVuZHNUb0FkZCwgZXh0ZW5kc0xpc3RUYXJnZXQsIGl0ZXJhdGlvbkNvdW50ICsgMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZHNUb0FkZDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdmlzaXRSdWxlOiBmdW5jdGlvbiAocnVsZU5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcbiAgICB9LFxuICAgIHZpc2l0TWl4aW5EZWZpbml0aW9uOiBmdW5jdGlvbiAobWl4aW5EZWZpbml0aW9uTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xuICAgIH0sXG4gICAgdmlzaXRTZWxlY3RvcjogZnVuY3Rpb24gKHNlbGVjdG9yTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xuICAgIH0sXG4gICAgdmlzaXRSdWxlc2V0OiBmdW5jdGlvbiAocnVsZXNldE5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICBpZiAocnVsZXNldE5vZGUucm9vdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaGVzLCBwYXRoSW5kZXgsIGV4dGVuZEluZGV4LCBhbGxFeHRlbmRzID0gdGhpcy5hbGxFeHRlbmRzU3RhY2tbdGhpcy5hbGxFeHRlbmRzU3RhY2subGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBzZWxlY3RvcnNUb0FkZCA9IFtdLCBleHRlbmRWaXNpdG9yID0gdGhpcywgc2VsZWN0b3JQYXRoO1xuXG4gICAgICAgIC8vIGxvb2sgYXQgZWFjaCBzZWxlY3RvciBwYXRoIGluIHRoZSBydWxlc2V0LCBmaW5kIGFueSBleHRlbmQgbWF0Y2hlcyBhbmQgdGhlbiBjb3B5LCBmaW5kIGFuZCByZXBsYWNlXG5cbiAgICAgICAgZm9yIChleHRlbmRJbmRleCA9IDA7IGV4dGVuZEluZGV4IDwgYWxsRXh0ZW5kcy5sZW5ndGg7IGV4dGVuZEluZGV4KyspIHtcbiAgICAgICAgICAgIGZvciAocGF0aEluZGV4ID0gMDsgcGF0aEluZGV4IDwgcnVsZXNldE5vZGUucGF0aHMubGVuZ3RoOyBwYXRoSW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yUGF0aCA9IHJ1bGVzZXROb2RlLnBhdGhzW3BhdGhJbmRleF07XG5cbiAgICAgICAgICAgICAgICAvLyBleHRlbmRpbmcgZXh0ZW5kcyBoYXBwZW5zIGluaXRpYWxseSwgYmVmb3JlIHRoZSBtYWluIHBhc3NcbiAgICAgICAgICAgICAgICBpZiAocnVsZXNldE5vZGUuZXh0ZW5kT25FdmVyeVBhdGgpIHsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICB2YXIgZXh0ZW5kTGlzdCA9IHNlbGVjdG9yUGF0aFtzZWxlY3RvclBhdGgubGVuZ3RoIC0gMV0uZXh0ZW5kTGlzdDtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5kTGlzdCAmJiBleHRlbmRMaXN0Lmxlbmd0aCkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgICAgICAgbWF0Y2hlcyA9IHRoaXMuZmluZE1hdGNoKGFsbEV4dGVuZHNbZXh0ZW5kSW5kZXhdLCBzZWxlY3RvclBhdGgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbEV4dGVuZHNbZXh0ZW5kSW5kZXhdLmhhc0ZvdW5kTWF0Y2hlcyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgYWxsRXh0ZW5kc1tleHRlbmRJbmRleF0uc2VsZlNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKHNlbGZTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4dGVuZGVkU2VsZWN0b3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRTZWxlY3RvcnMgPSBleHRlbmRWaXNpdG9yLmV4dGVuZFNlbGVjdG9yKG1hdGNoZXMsIHNlbGVjdG9yUGF0aCwgc2VsZlNlbGVjdG9yLCBhbGxFeHRlbmRzW2V4dGVuZEluZGV4XS5pc1Zpc2libGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnNUb0FkZC5wdXNoKGV4dGVuZGVkU2VsZWN0b3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJ1bGVzZXROb2RlLnBhdGhzID0gcnVsZXNldE5vZGUucGF0aHMuY29uY2F0KHNlbGVjdG9yc1RvQWRkKTtcbiAgICB9LFxuICAgIGZpbmRNYXRjaDogZnVuY3Rpb24gKGV4dGVuZCwgaGF5c3RhY2tTZWxlY3RvclBhdGgpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gbG9vayB0aHJvdWdoIHRoZSBoYXlzdGFjayBzZWxlY3RvciBwYXRoIHRvIHRyeSBhbmQgZmluZCB0aGUgbmVlZGxlIC0gZXh0ZW5kLnNlbGVjdG9yXG4gICAgICAgIC8vIHJldHVybnMgYW4gYXJyYXkgb2Ygc2VsZWN0b3IgbWF0Y2hlcyB0aGF0IGNhbiB0aGVuIGJlIHJlcGxhY2VkXG4gICAgICAgIC8vXG4gICAgICAgIHZhciBoYXlzdGFja1NlbGVjdG9ySW5kZXgsIGhhY2tzdGFja1NlbGVjdG9yLCBoYWNrc3RhY2tFbGVtZW50SW5kZXgsIGhheXN0YWNrRWxlbWVudCxcbiAgICAgICAgICAgIHRhcmdldENvbWJpbmF0b3IsIGksXG4gICAgICAgICAgICBleHRlbmRWaXNpdG9yID0gdGhpcyxcbiAgICAgICAgICAgIG5lZWRsZUVsZW1lbnRzID0gZXh0ZW5kLnNlbGVjdG9yLmVsZW1lbnRzLFxuICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2hlcyA9IFtdLCBwb3RlbnRpYWxNYXRjaCwgbWF0Y2hlcyA9IFtdO1xuXG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgaGF5c3RhY2sgZWxlbWVudHNcbiAgICAgICAgZm9yIChoYXlzdGFja1NlbGVjdG9ySW5kZXggPSAwOyBoYXlzdGFja1NlbGVjdG9ySW5kZXggPCBoYXlzdGFja1NlbGVjdG9yUGF0aC5sZW5ndGg7IGhheXN0YWNrU2VsZWN0b3JJbmRleCsrKSB7XG4gICAgICAgICAgICBoYWNrc3RhY2tTZWxlY3RvciA9IGhheXN0YWNrU2VsZWN0b3JQYXRoW2hheXN0YWNrU2VsZWN0b3JJbmRleF07XG5cbiAgICAgICAgICAgIGZvciAoaGFja3N0YWNrRWxlbWVudEluZGV4ID0gMDsgaGFja3N0YWNrRWxlbWVudEluZGV4IDwgaGFja3N0YWNrU2VsZWN0b3IuZWxlbWVudHMubGVuZ3RoOyBoYWNrc3RhY2tFbGVtZW50SW5kZXgrKykge1xuXG4gICAgICAgICAgICAgICAgaGF5c3RhY2tFbGVtZW50ID0gaGFja3N0YWNrU2VsZWN0b3IuZWxlbWVudHNbaGFja3N0YWNrRWxlbWVudEluZGV4XTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFsbG93IGVsZW1lbnRzIGJlZm9yZSBvdXIgbWF0Y2ggd2UgY2FuIGFkZCBhIHBvdGVudGlhbCBtYXRjaCBldmVyeSB0aW1lLiBvdGhlcndpc2Ugb25seSBhdCB0aGUgZmlyc3QgZWxlbWVudC5cbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5kLmFsbG93QmVmb3JlIHx8IChoYXlzdGFja1NlbGVjdG9ySW5kZXggPT09IDAgJiYgaGFja3N0YWNrRWxlbWVudEluZGV4ID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxNYXRjaGVzLnB1c2goe3BhdGhJbmRleDogaGF5c3RhY2tTZWxlY3RvckluZGV4LCBpbmRleDogaGFja3N0YWNrRWxlbWVudEluZGV4LCBtYXRjaGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbWJpbmF0b3I6IGhheXN0YWNrRWxlbWVudC5jb21iaW5hdG9yfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBvdGVudGlhbE1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2ggPSBwb3RlbnRpYWxNYXRjaGVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdG9ycyBhZGQgXCIgXCIgb250byB0aGUgZmlyc3QgZWxlbWVudC4gV2hlbiB3ZSB1c2UgJiBpdCBqb2lucyB0aGUgc2VsZWN0b3JzIHRvZ2V0aGVyLCBidXQgaWYgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBlYWNoIHNlbGVjdG9yIGluIGhheXN0YWNrU2VsZWN0b3JQYXRoIGhhcyBhIHNwYWNlIGJlZm9yZSBpdCBhZGRlZCBpbiB0aGUgdG9DU1MgcGhhc2UuIHNvIHdlIG5lZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gd29yayBvdXQgd2hhdCB0aGUgcmVzdWx0aW5nIGNvbWJpbmF0b3Igd2lsbCBiZVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDb21iaW5hdG9yID0gaGF5c3RhY2tFbGVtZW50LmNvbWJpbmF0b3IudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRDb21iaW5hdG9yID09PSAnJyAmJiBoYWNrc3RhY2tFbGVtZW50SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENvbWJpbmF0b3IgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBkb24ndCBtYXRjaCwgbnVsbCBvdXIgbWF0Y2ggdG8gaW5kaWNhdGUgZmFpbHVyZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4dGVuZFZpc2l0b3IuaXNFbGVtZW50VmFsdWVzRXF1YWwobmVlZGxlRWxlbWVudHNbcG90ZW50aWFsTWF0Y2gubWF0Y2hlZF0udmFsdWUsIGhheXN0YWNrRWxlbWVudC52YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChwb3RlbnRpYWxNYXRjaC5tYXRjaGVkID4gMCAmJiBuZWVkbGVFbGVtZW50c1twb3RlbnRpYWxNYXRjaC5tYXRjaGVkXS5jb21iaW5hdG9yLnZhbHVlICE9PSB0YXJnZXRDb21iaW5hdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2ggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2gubWF0Y2hlZCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIHN0aWxsIHZhbGlkIGFuZCBoYXZlIGZpbmlzaGVkLCB0ZXN0IHdoZXRoZXIgd2UgaGF2ZSBlbGVtZW50cyBhZnRlciBhbmQgd2hldGhlciB0aGVzZSBhcmUgYWxsb3dlZFxuICAgICAgICAgICAgICAgICAgICBpZiAocG90ZW50aWFsTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoLmZpbmlzaGVkID0gcG90ZW50aWFsTWF0Y2gubWF0Y2hlZCA9PT0gbmVlZGxlRWxlbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvdGVudGlhbE1hdGNoLmZpbmlzaGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFleHRlbmQuYWxsb3dBZnRlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaGFja3N0YWNrRWxlbWVudEluZGV4ICsgMSA8IGhhY2tzdGFja1NlbGVjdG9yLmVsZW1lbnRzLmxlbmd0aCB8fCBoYXlzdGFja1NlbGVjdG9ySW5kZXggKyAxIDwgaGF5c3RhY2tTZWxlY3RvclBhdGgubGVuZ3RoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxNYXRjaCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbnVsbCB3ZSByZW1vdmUsIGlmIG5vdCwgd2UgYXJlIHN0aWxsIHZhbGlkLCBzbyBlaXRoZXIgcHVzaCBhcyBhIHZhbGlkIG1hdGNoIG9yIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3RlbnRpYWxNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvdGVudGlhbE1hdGNoLmZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2gubGVuZ3RoID0gbmVlZGxlRWxlbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoLmVuZFBhdGhJbmRleCA9IGhheXN0YWNrU2VsZWN0b3JJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxNYXRjaC5lbmRQYXRoRWxlbWVudEluZGV4ID0gaGFja3N0YWNrRWxlbWVudEluZGV4ICsgMTsgLy8gaW5kZXggYWZ0ZXIgZW5kIG9mIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2hlcy5sZW5ndGggPSAwOyAvLyB3ZSBkb24ndCBhbGxvdyBtYXRjaGVzIHRvIG92ZXJsYXAsIHNvIHN0YXJ0IG1hdGNoaW5nIGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHBvdGVudGlhbE1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH0sXG4gICAgaXNFbGVtZW50VmFsdWVzRXF1YWw6IGZ1bmN0aW9uKGVsZW1lbnRWYWx1ZTEsIGVsZW1lbnRWYWx1ZTIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50VmFsdWUxID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBlbGVtZW50VmFsdWUyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudFZhbHVlMSA9PT0gZWxlbWVudFZhbHVlMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudFZhbHVlMSBpbnN0YW5jZW9mIHRyZWUuQXR0cmlidXRlKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudFZhbHVlMS5vcCAhPT0gZWxlbWVudFZhbHVlMi5vcCB8fCBlbGVtZW50VmFsdWUxLmtleSAhPT0gZWxlbWVudFZhbHVlMi5rZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnRWYWx1ZTEudmFsdWUgfHwgIWVsZW1lbnRWYWx1ZTIudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFZhbHVlMS52YWx1ZSB8fCBlbGVtZW50VmFsdWUyLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50VmFsdWUxID0gZWxlbWVudFZhbHVlMS52YWx1ZS52YWx1ZSB8fCBlbGVtZW50VmFsdWUxLnZhbHVlO1xuICAgICAgICAgICAgZWxlbWVudFZhbHVlMiA9IGVsZW1lbnRWYWx1ZTIudmFsdWUudmFsdWUgfHwgZWxlbWVudFZhbHVlMi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50VmFsdWUxID09PSBlbGVtZW50VmFsdWUyO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRWYWx1ZTEgPSBlbGVtZW50VmFsdWUxLnZhbHVlO1xuICAgICAgICBlbGVtZW50VmFsdWUyID0gZWxlbWVudFZhbHVlMi52YWx1ZTtcbiAgICAgICAgaWYgKGVsZW1lbnRWYWx1ZTEgaW5zdGFuY2VvZiB0cmVlLlNlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoIShlbGVtZW50VmFsdWUyIGluc3RhbmNlb2YgdHJlZS5TZWxlY3RvcikgfHwgZWxlbWVudFZhbHVlMS5lbGVtZW50cy5sZW5ndGggIT09IGVsZW1lbnRWYWx1ZTIuZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIDwgZWxlbWVudFZhbHVlMS5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50VmFsdWUxLmVsZW1lbnRzW2ldLmNvbWJpbmF0b3IudmFsdWUgIT09IGVsZW1lbnRWYWx1ZTIuZWxlbWVudHNbaV0uY29tYmluYXRvci52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gMCB8fCAoZWxlbWVudFZhbHVlMS5lbGVtZW50c1tpXS5jb21iaW5hdG9yLnZhbHVlIHx8ICcgJykgIT09IChlbGVtZW50VmFsdWUyLmVsZW1lbnRzW2ldLmNvbWJpbmF0b3IudmFsdWUgfHwgJyAnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0VsZW1lbnRWYWx1ZXNFcXVhbChlbGVtZW50VmFsdWUxLmVsZW1lbnRzW2ldLnZhbHVlLCBlbGVtZW50VmFsdWUyLmVsZW1lbnRzW2ldLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgZXh0ZW5kU2VsZWN0b3I6ZnVuY3Rpb24gKG1hdGNoZXMsIHNlbGVjdG9yUGF0aCwgcmVwbGFjZW1lbnRTZWxlY3RvciwgaXNWaXNpYmxlKSB7XG5cbiAgICAgICAgLy9mb3IgYSBzZXQgb2YgbWF0Y2hlcywgcmVwbGFjZSBlYWNoIG1hdGNoIHdpdGggdGhlIHJlcGxhY2VtZW50IHNlbGVjdG9yXG5cbiAgICAgICAgdmFyIGN1cnJlbnRTZWxlY3RvclBhdGhJbmRleCA9IDAsXG4gICAgICAgICAgICBjdXJyZW50U2VsZWN0b3JQYXRoRWxlbWVudEluZGV4ID0gMCxcbiAgICAgICAgICAgIHBhdGggPSBbXSxcbiAgICAgICAgICAgIG1hdGNoSW5kZXgsXG4gICAgICAgICAgICBzZWxlY3RvcixcbiAgICAgICAgICAgIGZpcnN0RWxlbWVudCxcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgbmV3RWxlbWVudHM7XG5cbiAgICAgICAgZm9yIChtYXRjaEluZGV4ID0gMDsgbWF0Y2hJbmRleCA8IG1hdGNoZXMubGVuZ3RoOyBtYXRjaEluZGV4KyspIHtcbiAgICAgICAgICAgIG1hdGNoID0gbWF0Y2hlc1ttYXRjaEluZGV4XTtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3JQYXRoW21hdGNoLnBhdGhJbmRleF07XG4gICAgICAgICAgICBmaXJzdEVsZW1lbnQgPSBuZXcgdHJlZS5FbGVtZW50KFxuICAgICAgICAgICAgICAgIG1hdGNoLmluaXRpYWxDb21iaW5hdG9yLFxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50U2VsZWN0b3IuZWxlbWVudHNbMF0udmFsdWUsXG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnRTZWxlY3Rvci5lbGVtZW50c1swXS5pbmRleCxcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudFNlbGVjdG9yLmVsZW1lbnRzWzBdLmN1cnJlbnRGaWxlSW5mb1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoLnBhdGhJbmRleCA+IGN1cnJlbnRTZWxlY3RvclBhdGhJbmRleCAmJiBjdXJyZW50U2VsZWN0b3JQYXRoRWxlbWVudEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHBhdGhbcGF0aC5sZW5ndGggLSAxXS5lbGVtZW50cyA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXVxuICAgICAgICAgICAgICAgICAgICAuZWxlbWVudHMuY29uY2F0KHNlbGVjdG9yUGF0aFtjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXhdLmVsZW1lbnRzLnNsaWNlKGN1cnJlbnRTZWxlY3RvclBhdGhFbGVtZW50SW5kZXgpKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0b3JQYXRoRWxlbWVudEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXgrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3RWxlbWVudHMgPSBzZWxlY3Rvci5lbGVtZW50c1xuICAgICAgICAgICAgICAgIC5zbGljZShjdXJyZW50U2VsZWN0b3JQYXRoRWxlbWVudEluZGV4LCBtYXRjaC5pbmRleClcbiAgICAgICAgICAgICAgICAuY29uY2F0KFtmaXJzdEVsZW1lbnRdKVxuICAgICAgICAgICAgICAgIC5jb25jYXQocmVwbGFjZW1lbnRTZWxlY3Rvci5lbGVtZW50cy5zbGljZSgxKSk7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXggPT09IG1hdGNoLnBhdGhJbmRleCAmJiBtYXRjaEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHBhdGhbcGF0aC5sZW5ndGggLSAxXS5lbGVtZW50cyA9XG4gICAgICAgICAgICAgICAgICAgIHBhdGhbcGF0aC5sZW5ndGggLSAxXS5lbGVtZW50cy5jb25jYXQobmV3RWxlbWVudHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5jb25jYXQoc2VsZWN0b3JQYXRoLnNsaWNlKGN1cnJlbnRTZWxlY3RvclBhdGhJbmRleCwgbWF0Y2gucGF0aEluZGV4KSk7XG5cbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobmV3IHRyZWUuU2VsZWN0b3IoXG4gICAgICAgICAgICAgICAgICAgIG5ld0VsZW1lbnRzXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXggPSBtYXRjaC5lbmRQYXRoSW5kZXg7XG4gICAgICAgICAgICBjdXJyZW50U2VsZWN0b3JQYXRoRWxlbWVudEluZGV4ID0gbWF0Y2guZW5kUGF0aEVsZW1lbnRJbmRleDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U2VsZWN0b3JQYXRoRWxlbWVudEluZGV4ID49IHNlbGVjdG9yUGF0aFtjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXhdLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3RvclBhdGhFbGVtZW50SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3RvclBhdGhJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRTZWxlY3RvclBhdGhJbmRleCA8IHNlbGVjdG9yUGF0aC5sZW5ndGggJiYgY3VycmVudFNlbGVjdG9yUGF0aEVsZW1lbnRJbmRleCA+IDApIHtcbiAgICAgICAgICAgIHBhdGhbcGF0aC5sZW5ndGggLSAxXS5lbGVtZW50cyA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXVxuICAgICAgICAgICAgICAgIC5lbGVtZW50cy5jb25jYXQoc2VsZWN0b3JQYXRoW2N1cnJlbnRTZWxlY3RvclBhdGhJbmRleF0uZWxlbWVudHMuc2xpY2UoY3VycmVudFNlbGVjdG9yUGF0aEVsZW1lbnRJbmRleCkpO1xuICAgICAgICAgICAgY3VycmVudFNlbGVjdG9yUGF0aEluZGV4Kys7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoID0gcGF0aC5jb25jYXQoc2VsZWN0b3JQYXRoLnNsaWNlKGN1cnJlbnRTZWxlY3RvclBhdGhJbmRleCwgc2VsZWN0b3JQYXRoLmxlbmd0aCkpO1xuICAgICAgICBwYXRoID0gcGF0aC5tYXAoZnVuY3Rpb24gKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgLy8gd2UgY2FuIHJlLXVzZSBlbGVtZW50cyBoZXJlLCBiZWNhdXNlIHRoZSB2aXNpYmlsaXR5IHByb3BlcnR5IG1hdHRlcnMgb25seSBmb3Igc2VsZWN0b3JzXG4gICAgICAgICAgICB2YXIgZGVyaXZlZCA9IGN1cnJlbnRWYWx1ZS5jcmVhdGVEZXJpdmVkKGN1cnJlbnRWYWx1ZS5lbGVtZW50cyk7XG4gICAgICAgICAgICBpZiAoaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgZGVyaXZlZC5lbnN1cmVWaXNpYmlsaXR5KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlcml2ZWQuZW5zdXJlSW52aXNpYmlsaXR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVyaXZlZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG4gICAgdmlzaXRNZWRpYTogZnVuY3Rpb24gKG1lZGlhTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHZhciBuZXdBbGxFeHRlbmRzID0gbWVkaWFOb2RlLmFsbEV4dGVuZHMuY29uY2F0KHRoaXMuYWxsRXh0ZW5kc1N0YWNrW3RoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgbmV3QWxsRXh0ZW5kcyA9IG5ld0FsbEV4dGVuZHMuY29uY2F0KHRoaXMuZG9FeHRlbmRDaGFpbmluZyhuZXdBbGxFeHRlbmRzLCBtZWRpYU5vZGUuYWxsRXh0ZW5kcykpO1xuICAgICAgICB0aGlzLmFsbEV4dGVuZHNTdGFjay5wdXNoKG5ld0FsbEV4dGVuZHMpO1xuICAgIH0sXG4gICAgdmlzaXRNZWRpYU91dDogZnVuY3Rpb24gKG1lZGlhTm9kZSkge1xuICAgICAgICB2YXIgbGFzdEluZGV4ID0gdGhpcy5hbGxFeHRlbmRzU3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5hbGxFeHRlbmRzU3RhY2subGVuZ3RoID0gbGFzdEluZGV4O1xuICAgIH0sXG4gICAgdmlzaXREaXJlY3RpdmU6IGZ1bmN0aW9uIChkaXJlY3RpdmVOb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgdmFyIG5ld0FsbEV4dGVuZHMgPSBkaXJlY3RpdmVOb2RlLmFsbEV4dGVuZHMuY29uY2F0KHRoaXMuYWxsRXh0ZW5kc1N0YWNrW3RoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgbmV3QWxsRXh0ZW5kcyA9IG5ld0FsbEV4dGVuZHMuY29uY2F0KHRoaXMuZG9FeHRlbmRDaGFpbmluZyhuZXdBbGxFeHRlbmRzLCBkaXJlY3RpdmVOb2RlLmFsbEV4dGVuZHMpKTtcbiAgICAgICAgdGhpcy5hbGxFeHRlbmRzU3RhY2sucHVzaChuZXdBbGxFeHRlbmRzKTtcbiAgICB9LFxuICAgIHZpc2l0RGlyZWN0aXZlT3V0OiBmdW5jdGlvbiAoZGlyZWN0aXZlTm9kZSkge1xuICAgICAgICB2YXIgbGFzdEluZGV4ID0gdGhpcy5hbGxFeHRlbmRzU3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5hbGxFeHRlbmRzU3RhY2subGVuZ3RoID0gbGFzdEluZGV4O1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvY2Vzc0V4dGVuZHNWaXNpdG9yO1xuXG59LHtcIi4uL2xvZ2dlclwiOjMzLFwiLi4vdHJlZVwiOjYyLFwiLi92aXNpdG9yXCI6OTF9XSw4NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5mdW5jdGlvbiBJbXBvcnRTZXF1ZW5jZXIob25TZXF1ZW5jZXJFbXB0eSkge1xuICAgIHRoaXMuaW1wb3J0cyA9IFtdO1xuICAgIHRoaXMudmFyaWFibGVJbXBvcnRzID0gW107XG4gICAgdGhpcy5fb25TZXF1ZW5jZXJFbXB0eSA9IG9uU2VxdWVuY2VyRW1wdHk7XG4gICAgdGhpcy5fY3VycmVudERlcHRoID0gMDtcbn1cblxuSW1wb3J0U2VxdWVuY2VyLnByb3RvdHlwZS5hZGRJbXBvcnQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBpbXBvcnRTZXF1ZW5jZXIgPSB0aGlzLFxuICAgICAgICBpbXBvcnRJdGVtID0ge1xuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgYXJnczogbnVsbCxcbiAgICAgICAgICAgIGlzUmVhZHk6IGZhbHNlXG4gICAgICAgIH07XG4gICAgdGhpcy5pbXBvcnRzLnB1c2goaW1wb3J0SXRlbSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpbXBvcnRJdGVtLmFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICBpbXBvcnRJdGVtLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICBpbXBvcnRTZXF1ZW5jZXIudHJ5UnVuKCk7XG4gICAgfTtcbn07XG5cbkltcG9ydFNlcXVlbmNlci5wcm90b3R5cGUuYWRkVmFyaWFibGVJbXBvcnQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHRoaXMudmFyaWFibGVJbXBvcnRzLnB1c2goY2FsbGJhY2spO1xufTtcblxuSW1wb3J0U2VxdWVuY2VyLnByb3RvdHlwZS50cnlSdW4gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jdXJyZW50RGVwdGgrKztcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaW1wb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGltcG9ydEl0ZW0gPSB0aGlzLmltcG9ydHNbMF07XG4gICAgICAgICAgICAgICAgaWYgKCFpbXBvcnRJdGVtLmlzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmltcG9ydHMgPSB0aGlzLmltcG9ydHMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgaW1wb3J0SXRlbS5jYWxsYmFjay5hcHBseShudWxsLCBpbXBvcnRJdGVtLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudmFyaWFibGVJbXBvcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhcmlhYmxlSW1wb3J0ID0gdGhpcy52YXJpYWJsZUltcG9ydHNbMF07XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlSW1wb3J0cyA9IHRoaXMudmFyaWFibGVJbXBvcnRzLnNsaWNlKDEpO1xuICAgICAgICAgICAgdmFyaWFibGVJbXBvcnQoKTtcbiAgICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnREZXB0aC0tO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY3VycmVudERlcHRoID09PSAwICYmIHRoaXMuX29uU2VxdWVuY2VyRW1wdHkpIHtcbiAgICAgICAgdGhpcy5fb25TZXF1ZW5jZXJFbXB0eSgpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW1wb3J0U2VxdWVuY2VyO1xuXG59LHt9XSw4NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgY29udGV4dHMgPSByZXF1aXJlKFwiLi4vY29udGV4dHNcIiksXG4gICAgVmlzaXRvciA9IHJlcXVpcmUoXCIuL3Zpc2l0b3JcIiksXG4gICAgSW1wb3J0U2VxdWVuY2VyID0gcmVxdWlyZShcIi4vaW1wb3J0LXNlcXVlbmNlclwiKTtcblxudmFyIEltcG9ydFZpc2l0b3IgPSBmdW5jdGlvbihpbXBvcnRlciwgZmluaXNoKSB7XG5cbiAgICB0aGlzLl92aXNpdG9yID0gbmV3IFZpc2l0b3IodGhpcyk7XG4gICAgdGhpcy5faW1wb3J0ZXIgPSBpbXBvcnRlcjtcbiAgICB0aGlzLl9maW5pc2ggPSBmaW5pc2g7XG4gICAgdGhpcy5jb250ZXh0ID0gbmV3IGNvbnRleHRzLkV2YWwoKTtcbiAgICB0aGlzLmltcG9ydENvdW50ID0gMDtcbiAgICB0aGlzLm9uY2VGaWxlRGV0ZWN0aW9uTWFwID0ge307XG4gICAgdGhpcy5yZWN1cnNpb25EZXRlY3RvciA9IHt9O1xuICAgIHRoaXMuX3NlcXVlbmNlciA9IG5ldyBJbXBvcnRTZXF1ZW5jZXIodGhpcy5fb25TZXF1ZW5jZXJFbXB0eS5iaW5kKHRoaXMpKTtcbn07XG5cbkltcG9ydFZpc2l0b3IucHJvdG90eXBlID0ge1xuICAgIGlzUmVwbGFjaW5nOiBmYWxzZSxcbiAgICBydW46IGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBwcm9jZXNzIHRoZSBjb250ZW50c1xuICAgICAgICAgICAgdGhpcy5fdmlzaXRvci52aXNpdChyb290KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NlcXVlbmNlci50cnlSdW4oKTtcbiAgICB9LFxuICAgIF9vblNlcXVlbmNlckVtcHR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maW5pc2godGhpcy5lcnJvcik7XG4gICAgfSxcbiAgICB2aXNpdEltcG9ydDogZnVuY3Rpb24gKGltcG9ydE5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICB2YXIgaW5saW5lQ1NTID0gaW1wb3J0Tm9kZS5vcHRpb25zLmlubGluZTtcblxuICAgICAgICBpZiAoIWltcG9ydE5vZGUuY3NzIHx8IGlubGluZUNTUykge1xuXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBjb250ZXh0cy5FdmFsKHRoaXMuY29udGV4dCwgdGhpcy5jb250ZXh0LmZyYW1lcy5zbGljZSgwKSk7XG4gICAgICAgICAgICB2YXIgaW1wb3J0UGFyZW50ID0gY29udGV4dC5mcmFtZXNbMF07XG5cbiAgICAgICAgICAgIHRoaXMuaW1wb3J0Q291bnQrKztcbiAgICAgICAgICAgIGlmIChpbXBvcnROb2RlLmlzVmFyaWFibGVJbXBvcnQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlcXVlbmNlci5hZGRWYXJpYWJsZUltcG9ydCh0aGlzLnByb2Nlc3NJbXBvcnROb2RlLmJpbmQodGhpcywgaW1wb3J0Tm9kZSwgY29udGV4dCwgaW1wb3J0UGFyZW50KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0ltcG9ydE5vZGUoaW1wb3J0Tm9kZSwgY29udGV4dCwgaW1wb3J0UGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcbiAgICB9LFxuICAgIHByb2Nlc3NJbXBvcnROb2RlOiBmdW5jdGlvbihpbXBvcnROb2RlLCBjb250ZXh0LCBpbXBvcnRQYXJlbnQpIHtcbiAgICAgICAgdmFyIGV2YWxkSW1wb3J0Tm9kZSxcbiAgICAgICAgICAgIGlubGluZUNTUyA9IGltcG9ydE5vZGUub3B0aW9ucy5pbmxpbmU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV2YWxkSW1wb3J0Tm9kZSA9IGltcG9ydE5vZGUuZXZhbEZvckltcG9ydChjb250ZXh0KTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBpZiAoIWUuZmlsZW5hbWUpIHsgZS5pbmRleCA9IGltcG9ydE5vZGUuaW5kZXg7IGUuZmlsZW5hbWUgPSBpbXBvcnROb2RlLmN1cnJlbnRGaWxlSW5mby5maWxlbmFtZTsgfVxuICAgICAgICAgICAgLy8gYXR0ZW1wdCB0byBldmFsIHByb3Blcmx5IGFuZCB0cmVhdCBhcyBjc3NcbiAgICAgICAgICAgIGltcG9ydE5vZGUuY3NzID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGlmIHRoYXQgZmFpbHMsIHRoaXMgZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAgICAgICAgICAgIGltcG9ydE5vZGUuZXJyb3IgPSBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2YWxkSW1wb3J0Tm9kZSAmJiAoIWV2YWxkSW1wb3J0Tm9kZS5jc3MgfHwgaW5saW5lQ1NTKSkge1xuXG4gICAgICAgICAgICBpZiAoZXZhbGRJbXBvcnROb2RlLm9wdGlvbnMubXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmltcG9ydE11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdHJ5IGFwcGVuZGluZyBpZiB3ZSBoYXZlbid0IGRldGVybWluZWQgaWYgaXQgaXMgY3NzIG9yIG5vdFxuICAgICAgICAgICAgdmFyIHRyeUFwcGVuZExlc3NFeHRlbnNpb24gPSBldmFsZEltcG9ydE5vZGUuY3NzID09PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW1wb3J0UGFyZW50LnJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGltcG9ydFBhcmVudC5ydWxlc1tpXSA9PT0gaW1wb3J0Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRQYXJlbnQucnVsZXNbaV0gPSBldmFsZEltcG9ydE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9uSW1wb3J0ZWQgPSB0aGlzLm9uSW1wb3J0ZWQuYmluZCh0aGlzLCBldmFsZEltcG9ydE5vZGUsIGNvbnRleHQpLFxuICAgICAgICAgICAgICAgIHNlcXVlbmNlZE9uSW1wb3J0ZWQgPSB0aGlzLl9zZXF1ZW5jZXIuYWRkSW1wb3J0KG9uSW1wb3J0ZWQpO1xuXG4gICAgICAgICAgICB0aGlzLl9pbXBvcnRlci5wdXNoKGV2YWxkSW1wb3J0Tm9kZS5nZXRQYXRoKCksIHRyeUFwcGVuZExlc3NFeHRlbnNpb24sIGV2YWxkSW1wb3J0Tm9kZS5jdXJyZW50RmlsZUluZm8sXG4gICAgICAgICAgICAgICAgZXZhbGRJbXBvcnROb2RlLm9wdGlvbnMsIHNlcXVlbmNlZE9uSW1wb3J0ZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbXBvcnRDb3VudC0tO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlcXVlbmNlci50cnlSdW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgb25JbXBvcnRlZDogZnVuY3Rpb24gKGltcG9ydE5vZGUsIGNvbnRleHQsIGUsIHJvb3QsIGltcG9ydGVkQXRSb290LCBmdWxsUGF0aCkge1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgaWYgKCFlLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgZS5pbmRleCA9IGltcG9ydE5vZGUuaW5kZXg7IGUuZmlsZW5hbWUgPSBpbXBvcnROb2RlLmN1cnJlbnRGaWxlSW5mby5maWxlbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGltcG9ydFZpc2l0b3IgPSB0aGlzLFxuICAgICAgICAgICAgaW5saW5lQ1NTID0gaW1wb3J0Tm9kZS5vcHRpb25zLmlubGluZSxcbiAgICAgICAgICAgIGlzUGx1Z2luID0gaW1wb3J0Tm9kZS5vcHRpb25zLnBsdWdpbixcbiAgICAgICAgICAgIGlzT3B0aW9uYWwgPSBpbXBvcnROb2RlLm9wdGlvbnMub3B0aW9uYWwsXG4gICAgICAgICAgICBkdXBsaWNhdGVJbXBvcnQgPSBpbXBvcnRlZEF0Um9vdCB8fCBmdWxsUGF0aCBpbiBpbXBvcnRWaXNpdG9yLnJlY3Vyc2lvbkRldGVjdG9yO1xuXG4gICAgICAgIGlmICghY29udGV4dC5pbXBvcnRNdWx0aXBsZSkge1xuICAgICAgICAgICAgaWYgKGR1cGxpY2F0ZUltcG9ydCkge1xuICAgICAgICAgICAgICAgIGltcG9ydE5vZGUuc2tpcCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGltcG9ydE5vZGUuc2tpcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnVsbFBhdGggaW4gaW1wb3J0VmlzaXRvci5vbmNlRmlsZURldGVjdGlvbk1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0VmlzaXRvci5vbmNlRmlsZURldGVjdGlvbk1hcFtmdWxsUGF0aF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZnVsbFBhdGggJiYgaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgaW1wb3J0Tm9kZS5za2lwID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgICBpbXBvcnROb2RlLnJvb3QgPSByb290O1xuICAgICAgICAgICAgaW1wb3J0Tm9kZS5pbXBvcnRlZEZpbGVuYW1lID0gZnVsbFBhdGg7XG5cbiAgICAgICAgICAgIGlmICghaW5saW5lQ1NTICYmICFpc1BsdWdpbiAmJiAoY29udGV4dC5pbXBvcnRNdWx0aXBsZSB8fCAhZHVwbGljYXRlSW1wb3J0KSkge1xuICAgICAgICAgICAgICAgIGltcG9ydFZpc2l0b3IucmVjdXJzaW9uRGV0ZWN0b3JbZnVsbFBhdGhdID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHZhciBvbGRDb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmlzaXRvci52aXNpdChyb290KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBvbGRDb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaW1wb3J0VmlzaXRvci5pbXBvcnRDb3VudC0tO1xuXG4gICAgICAgIGlmIChpbXBvcnRWaXNpdG9yLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIGltcG9ydFZpc2l0b3IuX3NlcXVlbmNlci50cnlSdW4oKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdmlzaXRSdWxlOiBmdW5jdGlvbiAocnVsZU5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICBpZiAocnVsZU5vZGUudmFsdWUudHlwZSA9PT0gXCJEZXRhY2hlZFJ1bGVzZXRcIikge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lcy51bnNoaWZ0KHJ1bGVOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB2aXNpdFJ1bGVPdXQgOiBmdW5jdGlvbihydWxlTm9kZSkge1xuICAgICAgICBpZiAocnVsZU5vZGUudmFsdWUudHlwZSA9PT0gXCJEZXRhY2hlZFJ1bGVzZXRcIikge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lcy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB2aXNpdERpcmVjdGl2ZTogZnVuY3Rpb24gKGRpcmVjdGl2ZU5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVzLnVuc2hpZnQoZGlyZWN0aXZlTm9kZSk7XG4gICAgfSxcbiAgICB2aXNpdERpcmVjdGl2ZU91dDogZnVuY3Rpb24gKGRpcmVjdGl2ZU5vZGUpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lcy5zaGlmdCgpO1xuICAgIH0sXG4gICAgdmlzaXRNaXhpbkRlZmluaXRpb246IGZ1bmN0aW9uIChtaXhpbkRlZmluaXRpb25Ob2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lcy51bnNoaWZ0KG1peGluRGVmaW5pdGlvbk5vZGUpO1xuICAgIH0sXG4gICAgdmlzaXRNaXhpbkRlZmluaXRpb25PdXQ6IGZ1bmN0aW9uIChtaXhpbkRlZmluaXRpb25Ob2RlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5mcmFtZXMuc2hpZnQoKTtcbiAgICB9LFxuICAgIHZpc2l0UnVsZXNldDogZnVuY3Rpb24gKHJ1bGVzZXROb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lcy51bnNoaWZ0KHJ1bGVzZXROb2RlKTtcbiAgICB9LFxuICAgIHZpc2l0UnVsZXNldE91dDogZnVuY3Rpb24gKHJ1bGVzZXROb2RlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5mcmFtZXMuc2hpZnQoKTtcbiAgICB9LFxuICAgIHZpc2l0TWVkaWE6IGZ1bmN0aW9uIChtZWRpYU5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVzLnVuc2hpZnQobWVkaWFOb2RlLnJ1bGVzWzBdKTtcbiAgICB9LFxuICAgIHZpc2l0TWVkaWFPdXQ6IGZ1bmN0aW9uIChtZWRpYU5vZGUpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lcy5zaGlmdCgpO1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IEltcG9ydFZpc2l0b3I7XG5cbn0se1wiLi4vY29udGV4dHNcIjoxMSxcIi4vaW1wb3J0LXNlcXVlbmNlclwiOjg1LFwiLi92aXNpdG9yXCI6OTF9XSw4NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmlzaXRvcnMgPSB7XG4gICAgVmlzaXRvcjogcmVxdWlyZShcIi4vdmlzaXRvclwiKSxcbiAgICBJbXBvcnRWaXNpdG9yOiByZXF1aXJlKCcuL2ltcG9ydC12aXNpdG9yJyksXG4gICAgTWFya1Zpc2libGVTZWxlY3RvcnNWaXNpdG9yOiByZXF1aXJlKFwiLi9zZXQtdHJlZS12aXNpYmlsaXR5LXZpc2l0b3JcIiksXG4gICAgRXh0ZW5kVmlzaXRvcjogcmVxdWlyZSgnLi9leHRlbmQtdmlzaXRvcicpLFxuICAgIEpvaW5TZWxlY3RvclZpc2l0b3I6IHJlcXVpcmUoJy4vam9pbi1zZWxlY3Rvci12aXNpdG9yJyksXG4gICAgVG9DU1NWaXNpdG9yOiByZXF1aXJlKCcuL3RvLWNzcy12aXNpdG9yJylcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdmlzaXRvcnM7XG5cbn0se1wiLi9leHRlbmQtdmlzaXRvclwiOjg0LFwiLi9pbXBvcnQtdmlzaXRvclwiOjg2LFwiLi9qb2luLXNlbGVjdG9yLXZpc2l0b3JcIjo4OCxcIi4vc2V0LXRyZWUtdmlzaWJpbGl0eS12aXNpdG9yXCI6ODksXCIuL3RvLWNzcy12aXNpdG9yXCI6OTAsXCIuL3Zpc2l0b3JcIjo5MX1dLDg4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBWaXNpdG9yID0gcmVxdWlyZShcIi4vdmlzaXRvclwiKTtcblxudmFyIEpvaW5TZWxlY3RvclZpc2l0b3IgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRleHRzID0gW1tdXTtcbiAgICB0aGlzLl92aXNpdG9yID0gbmV3IFZpc2l0b3IodGhpcyk7XG59O1xuXG5Kb2luU2VsZWN0b3JWaXNpdG9yLnByb3RvdHlwZSA9IHtcbiAgICBydW46IGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdG9yLnZpc2l0KHJvb3QpO1xuICAgIH0sXG4gICAgdmlzaXRSdWxlOiBmdW5jdGlvbiAocnVsZU5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcbiAgICB9LFxuICAgIHZpc2l0TWl4aW5EZWZpbml0aW9uOiBmdW5jdGlvbiAobWl4aW5EZWZpbml0aW9uTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICB2aXNpdFJ1bGVzZXQ6IGZ1bmN0aW9uIChydWxlc2V0Tm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0c1t0aGlzLmNvbnRleHRzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcGF0aHMgPSBbXSwgc2VsZWN0b3JzO1xuXG4gICAgICAgIHRoaXMuY29udGV4dHMucHVzaChwYXRocyk7XG5cbiAgICAgICAgaWYgKCEgcnVsZXNldE5vZGUucm9vdCkge1xuICAgICAgICAgICAgc2VsZWN0b3JzID0gcnVsZXNldE5vZGUuc2VsZWN0b3JzO1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9ycykge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IHNlbGVjdG9ycy5maWx0ZXIoZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHNlbGVjdG9yLmdldElzT3V0cHV0KCk7IH0pO1xuICAgICAgICAgICAgICAgIHJ1bGVzZXROb2RlLnNlbGVjdG9ycyA9IHNlbGVjdG9ycy5sZW5ndGggPyBzZWxlY3RvcnMgOiAoc2VsZWN0b3JzID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9ycykgeyBydWxlc2V0Tm9kZS5qb2luU2VsZWN0b3JzKHBhdGhzLCBjb250ZXh0LCBzZWxlY3RvcnMpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGVjdG9ycykgeyBydWxlc2V0Tm9kZS5ydWxlcyA9IG51bGw7IH1cbiAgICAgICAgICAgIHJ1bGVzZXROb2RlLnBhdGhzID0gcGF0aHM7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHZpc2l0UnVsZXNldE91dDogZnVuY3Rpb24gKHJ1bGVzZXROb2RlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dHMubGVuZ3RoID0gdGhpcy5jb250ZXh0cy5sZW5ndGggLSAxO1xuICAgIH0sXG4gICAgdmlzaXRNZWRpYTogZnVuY3Rpb24gKG1lZGlhTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0c1t0aGlzLmNvbnRleHRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBtZWRpYU5vZGUucnVsZXNbMF0ucm9vdCA9IChjb250ZXh0Lmxlbmd0aCA9PT0gMCB8fCBjb250ZXh0WzBdLm11bHRpTWVkaWEpO1xuICAgIH0sXG4gICAgdmlzaXREaXJlY3RpdmU6IGZ1bmN0aW9uIChkaXJlY3RpdmVOb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRzW3RoaXMuY29udGV4dHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChkaXJlY3RpdmVOb2RlLnJ1bGVzICYmIGRpcmVjdGl2ZU5vZGUucnVsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkaXJlY3RpdmVOb2RlLnJ1bGVzWzBdLnJvb3QgPSAoZGlyZWN0aXZlTm9kZS5pc1Jvb3RlZCB8fCBjb250ZXh0Lmxlbmd0aCA9PT0gMCB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSm9pblNlbGVjdG9yVmlzaXRvcjtcblxufSx7XCIuL3Zpc2l0b3JcIjo5MX1dLDg5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBTZXRUcmVlVmlzaWJpbGl0eVZpc2l0b3IgPSBmdW5jdGlvbih2aXNpYmxlKSB7XG4gICAgdGhpcy52aXNpYmxlID0gdmlzaWJsZTtcbn07XG5TZXRUcmVlVmlzaWJpbGl0eVZpc2l0b3IucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKHJvb3QpIHtcbiAgICB0aGlzLnZpc2l0KHJvb3QpO1xufTtcblNldFRyZWVWaXNpYmlsaXR5VmlzaXRvci5wcm90b3R5cGUudmlzaXRBcnJheSA9IGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgaWYgKCFub2Rlcykge1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuXG4gICAgdmFyIGNudCA9IG5vZGVzLmxlbmd0aCwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY250OyBpKyspIHtcbiAgICAgICAgdGhpcy52aXNpdChub2Rlc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBub2Rlcztcbn07XG5TZXRUcmVlVmlzaWJpbGl0eVZpc2l0b3IucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0QXJyYXkobm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKCFub2RlLmJsb2Nrc1Zpc2liaWxpdHkgfHwgbm9kZS5ibG9ja3NWaXNpYmlsaXR5KCkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgbm9kZS5lbnN1cmVWaXNpYmlsaXR5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5lbnN1cmVJbnZpc2liaWxpdHkoKTtcbiAgICB9XG5cbiAgICBub2RlLmFjY2VwdCh0aGlzKTtcbiAgICByZXR1cm4gbm9kZTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFNldFRyZWVWaXNpYmlsaXR5VmlzaXRvcjtcbn0se31dLDkwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB0cmVlID0gcmVxdWlyZShcIi4uL3RyZWVcIiksXG4gICAgVmlzaXRvciA9IHJlcXVpcmUoXCIuL3Zpc2l0b3JcIik7XG5cbnZhciBDU1NWaXNpdG9yVXRpbHMgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdGhpcy5fdmlzaXRvciA9IG5ldyBWaXNpdG9yKHRoaXMpO1xuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufTtcblxuQ1NTVmlzaXRvclV0aWxzLnByb3RvdHlwZSA9IHtcbiAgICBjb250YWluc1NpbGVudE5vbkJsb2NrZWRDaGlsZDogZnVuY3Rpb24oYm9keVJ1bGVzKSB7XG4gICAgICAgIHZhciBydWxlO1xuICAgICAgICBpZiAoYm9keVJ1bGVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IGJvZHlSdWxlcy5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgcnVsZSA9IGJvZHlSdWxlc1tyXTtcbiAgICAgICAgICAgIGlmIChydWxlLmlzU2lsZW50ICYmIHJ1bGUuaXNTaWxlbnQodGhpcy5fY29udGV4dCkgJiYgIXJ1bGUuYmxvY2tzVmlzaWJpbGl0eSgpKSB7XG4gICAgICAgICAgICAgICAgLy90aGUgZGlyZWN0aXZlIGNvbnRhaW5zIHNvbWV0aGluZyB0aGF0IHdhcyByZWZlcmVuY2VkIChsaWtlbHkgYnkgZXh0ZW5kKVxuICAgICAgICAgICAgICAgIC8vdGhlcmVmb3JlIGl0IG5lZWRzIHRvIGJlIHNob3duIGluIG91dHB1dCB0b29cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGtlZXBPbmx5VmlzaWJsZUNoaWxkczogZnVuY3Rpb24ob3duZXIpIHtcbiAgICAgICAgaWYgKG93bmVyID09IG51bGwgfHwgb3duZXIucnVsZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDtcbiAgICAgICAgfVxuXG4gICAgICAgIG93bmVyLnJ1bGVzID0gb3duZXIucnVsZXMuZmlsdGVyKGZ1bmN0aW9uKHRoaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaW5nLmlzVmlzaWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBpc0VtcHR5OiBmdW5jdGlvbihvd25lcikge1xuICAgICAgICBpZiAob3duZXIgPT0gbnVsbCB8fCBvd25lci5ydWxlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3duZXIucnVsZXMubGVuZ3RoID09PSAwO1xuICAgIH0sXG5cbiAgICBoYXNWaXNpYmxlU2VsZWN0b3I6IGZ1bmN0aW9uKHJ1bGVzZXROb2RlKSB7XG4gICAgICAgIGlmIChydWxlc2V0Tm9kZSA9PSBudWxsIHx8IHJ1bGVzZXROb2RlLnBhdGhzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZXNldE5vZGUucGF0aHMubGVuZ3RoID4gMDtcbiAgICB9LFxuXG4gICAgcmVzb2x2ZVZpc2liaWxpdHk6IGZ1bmN0aW9uIChub2RlLCBvcmlnaW5hbFJ1bGVzKSB7XG4gICAgICAgIGlmICghbm9kZS5ibG9ja3NWaXNpYmlsaXR5KCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW1wdHkobm9kZSkgJiYgIXRoaXMuY29udGFpbnNTaWxlbnROb25CbG9ja2VkQ2hpbGQob3JpZ2luYWxSdWxlcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb21waWxlZFJ1bGVzQm9keSA9IG5vZGUucnVsZXNbMF07XG4gICAgICAgIHRoaXMua2VlcE9ubHlWaXNpYmxlQ2hpbGRzKGNvbXBpbGVkUnVsZXNCb2R5KTtcblxuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KGNvbXBpbGVkUnVsZXNCb2R5KSkge1xuICAgICAgICAgICAgcmV0dXJuIDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuZW5zdXJlVmlzaWJpbGl0eSgpO1xuICAgICAgICBub2RlLnJlbW92ZVZpc2liaWxpdHlCbG9jaygpO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBpc1Zpc2libGVSdWxlc2V0OiBmdW5jdGlvbihydWxlc2V0Tm9kZSkge1xuICAgICAgICBpZiAocnVsZXNldE5vZGUuZmlyc3RSb290KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkocnVsZXNldE5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJ1bGVzZXROb2RlLnJvb3QgJiYgIXRoaXMuaGFzVmlzaWJsZVNlbGVjdG9yKHJ1bGVzZXROb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG59O1xuXG52YXIgVG9DU1NWaXNpdG9yID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHRoaXMuX3Zpc2l0b3IgPSBuZXcgVmlzaXRvcih0aGlzKTtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLnV0aWxzID0gbmV3IENTU1Zpc2l0b3JVdGlscyhjb250ZXh0KTtcbn07XG5cblRvQ1NTVmlzaXRvci5wcm90b3R5cGUgPSB7XG4gICAgaXNSZXBsYWNpbmc6IHRydWUsXG4gICAgcnVuOiBmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRvci52aXNpdChyb290KTtcbiAgICB9LFxuXG4gICAgdmlzaXRSdWxlOiBmdW5jdGlvbiAocnVsZU5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICBpZiAocnVsZU5vZGUuYmxvY2tzVmlzaWJpbGl0eSgpIHx8IHJ1bGVOb2RlLnZhcmlhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bGVOb2RlO1xuICAgIH0sXG5cbiAgICB2aXNpdE1peGluRGVmaW5pdGlvbjogZnVuY3Rpb24gKG1peGluTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIC8vIG1peGluIGRlZmluaXRpb25zIGRvIG5vdCBnZXQgZXZhbCdkIC0gdGhpcyBtZWFucyB0aGV5IGtlZXAgc3RhdGVcbiAgICAgICAgLy8gc28gd2UgaGF2ZSB0byBjbGVhciB0aGF0IHN0YXRlIGhlcmUgc28gaXQgaXNuJ3QgdXNlZCBpZiB0b0NTUyBpcyBjYWxsZWQgdHdpY2VcbiAgICAgICAgbWl4aW5Ob2RlLmZyYW1lcyA9IFtdO1xuICAgIH0sXG5cbiAgICB2aXNpdEV4dGVuZDogZnVuY3Rpb24gKGV4dGVuZE5vZGUsIHZpc2l0QXJncykge1xuICAgIH0sXG5cbiAgICB2aXNpdENvbW1lbnQ6IGZ1bmN0aW9uIChjb21tZW50Tm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIGlmIChjb21tZW50Tm9kZS5ibG9ja3NWaXNpYmlsaXR5KCkgfHwgY29tbWVudE5vZGUuaXNTaWxlbnQodGhpcy5fY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWVudE5vZGU7XG4gICAgfSxcblxuICAgIHZpc2l0TWVkaWE6IGZ1bmN0aW9uKG1lZGlhTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbFJ1bGVzID0gbWVkaWFOb2RlLnJ1bGVzWzBdLnJ1bGVzO1xuICAgICAgICBtZWRpYU5vZGUuYWNjZXB0KHRoaXMuX3Zpc2l0b3IpO1xuICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdGhpcy51dGlscy5yZXNvbHZlVmlzaWJpbGl0eShtZWRpYU5vZGUsIG9yaWdpbmFsUnVsZXMpO1xuICAgIH0sXG5cbiAgICB2aXNpdEltcG9ydDogZnVuY3Rpb24gKGltcG9ydE5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICBpZiAoaW1wb3J0Tm9kZS5ibG9ja3NWaXNpYmlsaXR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltcG9ydE5vZGU7XG4gICAgfSxcblxuICAgIHZpc2l0RGlyZWN0aXZlOiBmdW5jdGlvbihkaXJlY3RpdmVOb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgaWYgKGRpcmVjdGl2ZU5vZGUucnVsZXMgJiYgZGlyZWN0aXZlTm9kZS5ydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0RGlyZWN0aXZlV2l0aEJvZHkoZGlyZWN0aXZlTm9kZSwgdmlzaXRBcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0RGlyZWN0aXZlV2l0aG91dEJvZHkoZGlyZWN0aXZlTm9kZSwgdmlzaXRBcmdzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2aXNpdERpcmVjdGl2ZVdpdGhCb2R5OiBmdW5jdGlvbihkaXJlY3RpdmVOb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgLy9pZiB0aGVyZSBpcyBvbmx5IG9uZSBuZXN0ZWQgcnVsZXNldCBhbmQgdGhhdCBvbmUgaGFzIG5vIHBhdGgsIHRoZW4gaXQgaXNcbiAgICAgICAgLy9qdXN0IGZha2UgcnVsZXNldFxuICAgICAgICBmdW5jdGlvbiBoYXNGYWtlUnVsZXNldChkaXJlY3RpdmVOb2RlKSB7XG4gICAgICAgICAgICB2YXIgYm9keVJ1bGVzID0gZGlyZWN0aXZlTm9kZS5ydWxlcztcbiAgICAgICAgICAgIHJldHVybiBib2R5UnVsZXMubGVuZ3RoID09PSAxICYmICghYm9keVJ1bGVzWzBdLnBhdGhzIHx8IGJvZHlSdWxlc1swXS5wYXRocy5sZW5ndGggPT09IDApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEJvZHlSdWxlcyhkaXJlY3RpdmVOb2RlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZVJ1bGVzID0gZGlyZWN0aXZlTm9kZS5ydWxlcztcbiAgICAgICAgICAgIGlmIChoYXNGYWtlUnVsZXNldChkaXJlY3RpdmVOb2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlUnVsZXNbMF0ucnVsZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBub2RlUnVsZXM7XG4gICAgICAgIH1cbiAgICAgICAgLy9pdCBpcyBzdGlsbCB0cnVlIHRoYXQgaXQgaXMgb25seSBvbmUgcnVsZXNldCBpbiBhcnJheVxuICAgICAgICAvL3RoaXMgaXMgbGFzdCBzdWNoIG1vbWVudFxuICAgICAgICAvL3Byb2Nlc3MgY2hpbGRzXG4gICAgICAgIHZhciBvcmlnaW5hbFJ1bGVzID0gZ2V0Qm9keVJ1bGVzKGRpcmVjdGl2ZU5vZGUpO1xuICAgICAgICBkaXJlY3RpdmVOb2RlLmFjY2VwdCh0aGlzLl92aXNpdG9yKTtcbiAgICAgICAgdmlzaXRBcmdzLnZpc2l0RGVlcGVyID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCF0aGlzLnV0aWxzLmlzRW1wdHkoZGlyZWN0aXZlTm9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX21lcmdlUnVsZXMoZGlyZWN0aXZlTm9kZS5ydWxlc1swXS5ydWxlcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy51dGlscy5yZXNvbHZlVmlzaWJpbGl0eShkaXJlY3RpdmVOb2RlLCBvcmlnaW5hbFJ1bGVzKTtcbiAgICB9LFxuXG4gICAgdmlzaXREaXJlY3RpdmVXaXRob3V0Qm9keTogZnVuY3Rpb24oZGlyZWN0aXZlTm9kZSwgdmlzaXRBcmdzKSB7XG4gICAgICAgIGlmIChkaXJlY3RpdmVOb2RlLmJsb2Nrc1Zpc2liaWxpdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpcmVjdGl2ZU5vZGUubmFtZSA9PT0gXCJAY2hhcnNldFwiKSB7XG4gICAgICAgICAgICAvLyBPbmx5IG91dHB1dCB0aGUgZGVidWcgaW5mbyB0b2dldGhlciB3aXRoIHN1YnNlcXVlbnQgQGNoYXJzZXQgZGVmaW5pdGlvbnNcbiAgICAgICAgICAgIC8vIGEgY29tbWVudCAob3IgQG1lZGlhIHN0YXRlbWVudCkgYmVmb3JlIHRoZSBhY3R1YWwgQGNoYXJzZXQgZGlyZWN0aXZlIHdvdWxkXG4gICAgICAgICAgICAvLyBiZSBjb25zaWRlcmVkIGlsbGVnYWwgY3NzIGFzIGl0IGhhcyB0byBiZSBvbiB0aGUgZmlyc3QgbGluZVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hhcnNldCkge1xuICAgICAgICAgICAgICAgIGlmIChkaXJlY3RpdmVOb2RlLmRlYnVnSW5mbykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IG5ldyB0cmVlLkNvbW1lbnQoXCIvKiBcIiArIGRpcmVjdGl2ZU5vZGUudG9DU1ModGhpcy5fY29udGV4dCkucmVwbGFjZSgvXFxuL2csIFwiXCIpICsgXCIgKi9cXG5cIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQuZGVidWdJbmZvID0gZGlyZWN0aXZlTm9kZS5kZWJ1Z0luZm87XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92aXNpdG9yLnZpc2l0KGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoYXJzZXQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZU5vZGU7XG4gICAgfSxcblxuICAgIGNoZWNrVmFsaWROb2RlczogZnVuY3Rpb24ocnVsZXMsIGlzUm9vdCkge1xuICAgICAgICBpZiAoIXJ1bGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcnVsZU5vZGUgPSBydWxlc1tpXTtcbiAgICAgICAgICAgIGlmIChpc1Jvb3QgJiYgcnVsZU5vZGUgaW5zdGFuY2VvZiB0cmVlLlJ1bGUgJiYgIXJ1bGVOb2RlLnZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiBcIlByb3BlcnRpZXMgbXVzdCBiZSBpbnNpZGUgc2VsZWN0b3IgYmxvY2tzLiBUaGV5IGNhbm5vdCBiZSBpbiB0aGUgcm9vdFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogcnVsZU5vZGUuaW5kZXgsIGZpbGVuYW1lOiBydWxlTm9kZS5jdXJyZW50RmlsZUluZm8gJiYgcnVsZU5vZGUuY3VycmVudEZpbGVJbmZvLmZpbGVuYW1lfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydWxlTm9kZSBpbnN0YW5jZW9mIHRyZWUuQ2FsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IHsgbWVzc2FnZTogXCJGdW5jdGlvbiAnXCIgKyBydWxlTm9kZS5uYW1lICsgXCInIGlzIHVuZGVmaW5lZFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogcnVsZU5vZGUuaW5kZXgsIGZpbGVuYW1lOiBydWxlTm9kZS5jdXJyZW50RmlsZUluZm8gJiYgcnVsZU5vZGUuY3VycmVudEZpbGVJbmZvLmZpbGVuYW1lfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydWxlTm9kZS50eXBlICYmICFydWxlTm9kZS5hbGxvd1Jvb3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB7IG1lc3NhZ2U6IHJ1bGVOb2RlLnR5cGUgKyBcIiBub2RlIHJldHVybmVkIGJ5IGEgZnVuY3Rpb24gaXMgbm90IHZhbGlkIGhlcmVcIixcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHJ1bGVOb2RlLmluZGV4LCBmaWxlbmFtZTogcnVsZU5vZGUuY3VycmVudEZpbGVJbmZvICYmIHJ1bGVOb2RlLmN1cnJlbnRGaWxlSW5mby5maWxlbmFtZX07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmlzaXRSdWxlc2V0OiBmdW5jdGlvbiAocnVsZXNldE5vZGUsIHZpc2l0QXJncykge1xuICAgICAgICAvL2F0IHRoaXMgcG9pbnQgcnVsZXNldHMgYXJlIG5lc3RlZCBpbnRvIGVhY2ggb3RoZXJcbiAgICAgICAgdmFyIHJ1bGUsIHJ1bGVzZXRzID0gW107XG5cbiAgICAgICAgdGhpcy5jaGVja1ZhbGlkTm9kZXMocnVsZXNldE5vZGUucnVsZXMsIHJ1bGVzZXROb2RlLmZpcnN0Um9vdCk7XG5cbiAgICAgICAgaWYgKCEgcnVsZXNldE5vZGUucm9vdCkge1xuICAgICAgICAgICAgLy9yZW1vdmUgaW52aXNpYmxlIHBhdGhzXG4gICAgICAgICAgICB0aGlzLl9jb21waWxlUnVsZXNldFBhdGhzKHJ1bGVzZXROb2RlKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHJ1bGVzZXRzIGZyb20gdGhpcyBydWxlc2V0IGJvZHkgYW5kIGNvbXBpbGUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgICAgICB2YXIgbm9kZVJ1bGVzID0gcnVsZXNldE5vZGUucnVsZXMsIG5vZGVSdWxlQ250ID0gbm9kZVJ1bGVzID8gbm9kZVJ1bGVzLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVSdWxlQ250OyApIHtcbiAgICAgICAgICAgICAgICBydWxlID0gbm9kZVJ1bGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChydWxlICYmIHJ1bGUucnVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmlzaXQgYmVjYXVzZSB3ZSBhcmUgbW92aW5nIHRoZW0gb3V0IGZyb20gYmVpbmcgYSBjaGlsZFxuICAgICAgICAgICAgICAgICAgICBydWxlc2V0cy5wdXNoKHRoaXMuX3Zpc2l0b3IudmlzaXQocnVsZSkpO1xuICAgICAgICAgICAgICAgICAgICBub2RlUnVsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBub2RlUnVsZUNudC0tO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWNjZXB0IHRoZSB2aXNpdG9yIHRvIHJlbW92ZSBydWxlcyBhbmQgcmVmYWN0b3IgaXRzZWxmXG4gICAgICAgICAgICAvLyB0aGVuIHdlIGNhbiBkZWNpZGUgbm9ndyB3aGV0aGVyIHdlIHdhbnQgaXQgb3Igbm90XG4gICAgICAgICAgICAvLyBjb21waWxlIGJvZHlcbiAgICAgICAgICAgIGlmIChub2RlUnVsZUNudCA+IDApIHtcbiAgICAgICAgICAgICAgICBydWxlc2V0Tm9kZS5hY2NlcHQodGhpcy5fdmlzaXRvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJ1bGVzZXROb2RlLnJ1bGVzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vaWYgKCEgcnVsZXNldE5vZGUucm9vdCkge1xuICAgICAgICAgICAgcnVsZXNldE5vZGUuYWNjZXB0KHRoaXMuX3Zpc2l0b3IpO1xuICAgICAgICAgICAgdmlzaXRBcmdzLnZpc2l0RGVlcGVyID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocnVsZXNldE5vZGUucnVsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX21lcmdlUnVsZXMocnVsZXNldE5vZGUucnVsZXMpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlRHVwbGljYXRlUnVsZXMocnVsZXNldE5vZGUucnVsZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9ub3cgZGVjaWRlIHdoZXRoZXIgd2Uga2VlcCB0aGUgcnVsZXNldFxuICAgICAgICBpZiAodGhpcy51dGlscy5pc1Zpc2libGVSdWxlc2V0KHJ1bGVzZXROb2RlKSkge1xuICAgICAgICAgICAgcnVsZXNldE5vZGUuZW5zdXJlVmlzaWJpbGl0eSgpO1xuICAgICAgICAgICAgcnVsZXNldHMuc3BsaWNlKDAsIDAsIHJ1bGVzZXROb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChydWxlc2V0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBydWxlc2V0c1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZXNldHM7XG4gICAgfSxcblxuICAgIF9jb21waWxlUnVsZXNldFBhdGhzOiBmdW5jdGlvbihydWxlc2V0Tm9kZSkge1xuICAgICAgICBpZiAocnVsZXNldE5vZGUucGF0aHMpIHtcbiAgICAgICAgICAgIHJ1bGVzZXROb2RlLnBhdGhzID0gcnVsZXNldE5vZGUucGF0aHNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwWzBdLmVsZW1lbnRzWzBdLmNvbWJpbmF0b3IudmFsdWUgPT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcFswXS5lbGVtZW50c1swXS5jb21iaW5hdG9yID0gbmV3KHRyZWUuQ29tYmluYXRvcikoJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocFtpXS5pc1Zpc2libGUoKSAmJiBwW2ldLmdldElzT3V0cHV0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3JlbW92ZUR1cGxpY2F0ZVJ1bGVzOiBmdW5jdGlvbihydWxlcykge1xuICAgICAgICBpZiAoIXJ1bGVzKSB7IHJldHVybjsgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBkdXBsaWNhdGVzXG4gICAgICAgIHZhciBydWxlQ2FjaGUgPSB7fSxcbiAgICAgICAgICAgIHJ1bGVMaXN0LCBydWxlLCBpO1xuXG4gICAgICAgIGZvciAoaSA9IHJ1bGVzLmxlbmd0aCAtIDE7IGkgPj0gMCA7IGktLSkge1xuICAgICAgICAgICAgcnVsZSA9IHJ1bGVzW2ldO1xuICAgICAgICAgICAgaWYgKHJ1bGUgaW5zdGFuY2VvZiB0cmVlLlJ1bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bGVDYWNoZVtydWxlLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVDYWNoZVtydWxlLm5hbWVdID0gcnVsZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBydWxlTGlzdCA9IHJ1bGVDYWNoZVtydWxlLm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZUxpc3QgaW5zdGFuY2VvZiB0cmVlLlJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVMaXN0ID0gcnVsZUNhY2hlW3J1bGUubmFtZV0gPSBbcnVsZUNhY2hlW3J1bGUubmFtZV0udG9DU1ModGhpcy5fY29udGV4dCldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBydWxlQ1NTID0gcnVsZS50b0NTUyh0aGlzLl9jb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVMaXN0LmluZGV4T2YocnVsZUNTUykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlTGlzdC5wdXNoKHJ1bGVDU1MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9tZXJnZVJ1bGVzOiBmdW5jdGlvbiAocnVsZXMpIHtcbiAgICAgICAgaWYgKCFydWxlcykgeyByZXR1cm47IH1cblxuICAgICAgICB2YXIgZ3JvdXBzID0ge30sXG4gICAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICAgIHJ1bGUsXG4gICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcnVsZSA9IHJ1bGVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoKHJ1bGUgaW5zdGFuY2VvZiB0cmVlLlJ1bGUpICYmIHJ1bGUubWVyZ2UpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBbcnVsZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBydWxlLmltcG9ydGFudCA/IFwiIVwiIDogXCJcIl0uam9pbihcIixcIik7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWdyb3Vwc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwc1trZXldID0gW107XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZXMuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZ3JvdXBzW2tleV0ucHVzaChydWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKGdyb3VwcykubWFwKGZ1bmN0aW9uIChrKSB7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRvRXhwcmVzc2lvbih2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLkV4cHJlc3Npb24pKHZhbHVlcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAudmFsdWU7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB0b1ZhbHVlKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuVmFsdWUpKHZhbHVlcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJ0cyA9IGdyb3Vwc1trXTtcblxuICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBydWxlID0gcGFydHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIHNwYWNlZEdyb3VwcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0U3BhY2VkR3JvdXAgPSBbXTtcbiAgICAgICAgICAgICAgICBwYXJ0cy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAubWVyZ2UgPT09IFwiK1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFNwYWNlZEdyb3VwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFjZWRHcm91cHMucHVzaCh0b0V4cHJlc3Npb24obGFzdFNwYWNlZEdyb3VwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0U3BhY2VkR3JvdXAgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0U3BhY2VkR3JvdXAucHVzaChwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzcGFjZWRHcm91cHMucHVzaCh0b0V4cHJlc3Npb24obGFzdFNwYWNlZEdyb3VwKSk7XG4gICAgICAgICAgICAgICAgcnVsZS52YWx1ZSA9IHRvVmFsdWUoc3BhY2VkR3JvdXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHZpc2l0QW5vbnltb3VzOiBmdW5jdGlvbihhbm9ueW1vdXNOb2RlLCB2aXNpdEFyZ3MpIHtcbiAgICAgICAgaWYgKGFub255bW91c05vZGUuYmxvY2tzVmlzaWJpbGl0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gO1xuICAgICAgICB9XG4gICAgICAgIGFub255bW91c05vZGUuYWNjZXB0KHRoaXMuX3Zpc2l0b3IpO1xuICAgICAgICByZXR1cm4gYW5vbnltb3VzTm9kZTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRvQ1NTVmlzaXRvcjtcblxufSx7XCIuLi90cmVlXCI6NjIsXCIuL3Zpc2l0b3JcIjo5MX1dLDkxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB0cmVlID0gcmVxdWlyZShcIi4uL3RyZWVcIik7XG5cbnZhciBfdmlzaXRBcmdzID0geyB2aXNpdERlZXBlcjogdHJ1ZSB9LFxuICAgIF9oYXNJbmRleGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIF9ub29wKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gaW5kZXhOb2RlVHlwZXMocGFyZW50LCB0aWNrZXIpIHtcbiAgICAvLyBhZGQgLnR5cGVJbmRleCB0byB0cmVlIG5vZGUgdHlwZXMgZm9yIGxvb2t1cCB0YWJsZVxuICAgIHZhciBrZXksIGNoaWxkO1xuICAgIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGNoaWxkID0gcGFyZW50W2tleV07XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjaGlsZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgYm91bmQgZnVuY3Rpb25zIGRpcmVjdGx5IG9uIHRyZWUgd2hpY2ggZG8gbm90IGhhdmUgYSBwcm90b3R5cGVcbiAgICAgICAgICAgICAgICAgICAgLy8gb3IgYXJlbid0IG5vZGVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5wcm90b3R5cGUgJiYgY2hpbGQucHJvdG90eXBlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnByb3RvdHlwZS50eXBlSW5kZXggPSB0aWNrZXIrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgICAgIHRpY2tlciA9IGluZGV4Tm9kZVR5cGVzKGNoaWxkLCB0aWNrZXIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGlja2VyO1xufVxuXG52YXIgVmlzaXRvciA9IGZ1bmN0aW9uKGltcGxlbWVudGF0aW9uKSB7XG4gICAgdGhpcy5faW1wbGVtZW50YXRpb24gPSBpbXBsZW1lbnRhdGlvbjtcbiAgICB0aGlzLl92aXNpdEZuQ2FjaGUgPSBbXTtcblxuICAgIGlmICghX2hhc0luZGV4ZWQpIHtcbiAgICAgICAgaW5kZXhOb2RlVHlwZXModHJlZSwgMSk7XG4gICAgICAgIF9oYXNJbmRleGVkID0gdHJ1ZTtcbiAgICB9XG59O1xuXG5WaXNpdG9yLnByb3RvdHlwZSA9IHtcbiAgICB2aXNpdDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGVUeXBlSW5kZXggPSBub2RlLnR5cGVJbmRleDtcbiAgICAgICAgaWYgKCFub2RlVHlwZUluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2aXNpdEZuQ2FjaGUgPSB0aGlzLl92aXNpdEZuQ2FjaGUsXG4gICAgICAgICAgICBpbXBsID0gdGhpcy5faW1wbGVtZW50YXRpb24sXG4gICAgICAgICAgICBhcnlJbmR4ID0gbm9kZVR5cGVJbmRleCA8PCAxLFxuICAgICAgICAgICAgb3V0QXJ5SW5kZXggPSBhcnlJbmR4IHwgMSxcbiAgICAgICAgICAgIGZ1bmMgPSB2aXNpdEZuQ2FjaGVbYXJ5SW5keF0sXG4gICAgICAgICAgICBmdW5jT3V0ID0gdmlzaXRGbkNhY2hlW291dEFyeUluZGV4XSxcbiAgICAgICAgICAgIHZpc2l0QXJncyA9IF92aXNpdEFyZ3MsXG4gICAgICAgICAgICBmbk5hbWU7XG5cbiAgICAgICAgdmlzaXRBcmdzLnZpc2l0RGVlcGVyID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IFwidmlzaXRcIiArIG5vZGUudHlwZTtcbiAgICAgICAgICAgIGZ1bmMgPSBpbXBsW2ZuTmFtZV0gfHwgX25vb3A7XG4gICAgICAgICAgICBmdW5jT3V0ID0gaW1wbFtmbk5hbWUgKyBcIk91dFwiXSB8fCBfbm9vcDtcbiAgICAgICAgICAgIHZpc2l0Rm5DYWNoZVthcnlJbmR4XSA9IGZ1bmM7XG4gICAgICAgICAgICB2aXNpdEZuQ2FjaGVbb3V0QXJ5SW5kZXhdID0gZnVuY091dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmdW5jICE9PSBfbm9vcCkge1xuICAgICAgICAgICAgdmFyIG5ld05vZGUgPSBmdW5jLmNhbGwoaW1wbCwgbm9kZSwgdmlzaXRBcmdzKTtcbiAgICAgICAgICAgIGlmIChpbXBsLmlzUmVwbGFjaW5nKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5ld05vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmlzaXRBcmdzLnZpc2l0RGVlcGVyICYmIG5vZGUgJiYgbm9kZS5hY2NlcHQpIHtcbiAgICAgICAgICAgIG5vZGUuYWNjZXB0KHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZ1bmNPdXQgIT0gX25vb3ApIHtcbiAgICAgICAgICAgIGZ1bmNPdXQuY2FsbChpbXBsLCBub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgdmlzaXRBcnJheTogZnVuY3Rpb24obm9kZXMsIG5vblJlcGxhY2luZykge1xuICAgICAgICBpZiAoIW5vZGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY250ID0gbm9kZXMubGVuZ3RoLCBpO1xuXG4gICAgICAgIC8vIE5vbi1yZXBsYWNpbmdcbiAgICAgICAgaWYgKG5vblJlcGxhY2luZyB8fCAhdGhpcy5faW1wbGVtZW50YXRpb24uaXNSZXBsYWNpbmcpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzaXQobm9kZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVwbGFjaW5nXG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXZhbGQgPSB0aGlzLnZpc2l0KG5vZGVzW2ldKTtcbiAgICAgICAgICAgIGlmIChldmFsZCA9PT0gdW5kZWZpbmVkKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICBpZiAoIWV2YWxkLnNwbGljZSkge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKGV2YWxkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZhbGQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbGF0dGVuKGV2YWxkLCBvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfSxcbiAgICBmbGF0dGVuOiBmdW5jdGlvbihhcnIsIG91dCkge1xuICAgICAgICBpZiAoIW91dCkge1xuICAgICAgICAgICAgb3V0ID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY250LCBpLCBpdGVtLFxuICAgICAgICAgICAgbmVzdGVkQ250LCBqLCBuZXN0ZWRJdGVtO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGNudCA9IGFyci5sZW5ndGg7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGFycltpXTtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXRlbS5zcGxpY2UpIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChqID0gMCwgbmVzdGVkQ250ID0gaXRlbS5sZW5ndGg7IGogPCBuZXN0ZWRDbnQ7IGorKykge1xuICAgICAgICAgICAgICAgIG5lc3RlZEl0ZW0gPSBpdGVtW2pdO1xuICAgICAgICAgICAgICAgIGlmIChuZXN0ZWRJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbmVzdGVkSXRlbS5zcGxpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2gobmVzdGVkSXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXN0ZWRJdGVtLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsYXR0ZW4obmVzdGVkSXRlbSwgb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IFZpc2l0b3I7XG5cbn0se1wiLi4vdHJlZVwiOjYyfV0sOTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIHJhd0FzYXAgcHJvdmlkZXMgZXZlcnl0aGluZyB3ZSBuZWVkIGV4Y2VwdCBleGNlcHRpb24gbWFuYWdlbWVudC5cbnZhciByYXdBc2FwID0gcmVxdWlyZShcIi4vcmF3XCIpO1xuLy8gUmF3VGFza3MgYXJlIHJlY3ljbGVkIHRvIHJlZHVjZSBHQyBjaHVybi5cbnZhciBmcmVlVGFza3MgPSBbXTtcbi8vIFdlIHF1ZXVlIGVycm9ycyB0byBlbnN1cmUgdGhleSBhcmUgdGhyb3duIGluIHJpZ2h0IG9yZGVyIChGSUZPKS5cbi8vIEFycmF5LWFzLXF1ZXVlIGlzIGdvb2QgZW5vdWdoIGhlcmUsIHNpbmNlIHdlIGFyZSBqdXN0IGRlYWxpbmcgd2l0aCBleGNlcHRpb25zLlxudmFyIHBlbmRpbmdFcnJvcnMgPSBbXTtcbnZhciByZXF1ZXN0RXJyb3JUaHJvdyA9IHJhd0FzYXAubWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKHRocm93Rmlyc3RFcnJvcik7XG5cbmZ1bmN0aW9uIHRocm93Rmlyc3RFcnJvcigpIHtcbiAgICBpZiAocGVuZGluZ0Vycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgcGVuZGluZ0Vycm9ycy5zaGlmdCgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDYWxscyBhIHRhc2sgYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciByZXR1cm5pbmcsIGluIGl0cyBvd24gZXZlbnQsIHdpdGggcHJpb3JpdHlcbiAqIG92ZXIgb3RoZXIgZXZlbnRzIGxpa2UgYW5pbWF0aW9uLCByZWZsb3csIGFuZCByZXBhaW50LiBBbiBlcnJvciB0aHJvd24gZnJvbSBhblxuICogZXZlbnQgd2lsbCBub3QgaW50ZXJydXB0LCBub3IgZXZlbiBzdWJzdGFudGlhbGx5IHNsb3cgZG93biB0aGUgcHJvY2Vzc2luZyBvZlxuICogb3RoZXIgZXZlbnRzLCBidXQgd2lsbCBiZSByYXRoZXIgcG9zdHBvbmVkIHRvIGEgbG93ZXIgcHJpb3JpdHkgZXZlbnQuXG4gKiBAcGFyYW0ge3tjYWxsfX0gdGFzayBBIGNhbGxhYmxlIG9iamVjdCwgdHlwaWNhbGx5IGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBub1xuICogYXJndW1lbnRzLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGFzYXA7XG5mdW5jdGlvbiBhc2FwKHRhc2spIHtcbiAgICB2YXIgcmF3VGFzaztcbiAgICBpZiAoZnJlZVRhc2tzLmxlbmd0aCkge1xuICAgICAgICByYXdUYXNrID0gZnJlZVRhc2tzLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJhd1Rhc2sgPSBuZXcgUmF3VGFzaygpO1xuICAgIH1cbiAgICByYXdUYXNrLnRhc2sgPSB0YXNrO1xuICAgIHJhd0FzYXAocmF3VGFzayk7XG59XG5cbi8vIFdlIHdyYXAgdGFza3Mgd2l0aCByZWN5Y2xhYmxlIHRhc2sgb2JqZWN0cy4gIEEgdGFzayBvYmplY3QgaW1wbGVtZW50c1xuLy8gYGNhbGxgLCBqdXN0IGxpa2UgYSBmdW5jdGlvbi5cbmZ1bmN0aW9uIFJhd1Rhc2soKSB7XG4gICAgdGhpcy50YXNrID0gbnVsbDtcbn1cblxuLy8gVGhlIHNvbGUgcHVycG9zZSBvZiB3cmFwcGluZyB0aGUgdGFzayBpcyB0byBjYXRjaCB0aGUgZXhjZXB0aW9uIGFuZCByZWN5Y2xlXG4vLyB0aGUgdGFzayBvYmplY3QgYWZ0ZXIgaXRzIHNpbmdsZSB1c2UuXG5SYXdUYXNrLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHRoaXMudGFzay5jYWxsKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGFzYXAub25lcnJvcikge1xuICAgICAgICAgICAgLy8gVGhpcyBob29rIGV4aXN0cyBwdXJlbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gICAgICAgICAgICAvLyBJdHMgbmFtZSB3aWxsIGJlIHBlcmlvZGljYWxseSByYW5kb21pemVkIHRvIGJyZWFrIGFueSBjb2RlIHRoYXRcbiAgICAgICAgICAgIC8vIGRlcGVuZHMgb24gaXRzIGV4aXN0ZW5jZS5cbiAgICAgICAgICAgIGFzYXAub25lcnJvcihlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJbiBhIHdlYiBicm93c2VyLCBleGNlcHRpb25zIGFyZSBub3QgZmF0YWwuIEhvd2V2ZXIsIHRvIGF2b2lkXG4gICAgICAgICAgICAvLyBzbG93aW5nIGRvd24gdGhlIHF1ZXVlIG9mIHBlbmRpbmcgdGFza3MsIHdlIHJldGhyb3cgdGhlIGVycm9yIGluIGFcbiAgICAgICAgICAgIC8vIGxvd2VyIHByaW9yaXR5IHR1cm4uXG4gICAgICAgICAgICBwZW5kaW5nRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgcmVxdWVzdEVycm9yVGhyb3coKTtcbiAgICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgIGZyZWVUYXNrc1tmcmVlVGFza3MubGVuZ3RoXSA9IHRoaXM7XG4gICAgfVxufTtcblxufSx7XCIuL3Jhd1wiOjkzfV0sOTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFVzZSB0aGUgZmFzdGVzdCBtZWFucyBwb3NzaWJsZSB0byBleGVjdXRlIGEgdGFzayBpbiBpdHMgb3duIHR1cm4sIHdpdGhcbi8vIHByaW9yaXR5IG92ZXIgb3RoZXIgZXZlbnRzIGluY2x1ZGluZyBJTywgYW5pbWF0aW9uLCByZWZsb3csIGFuZCByZWRyYXdcbi8vIGV2ZW50cyBpbiBicm93c2Vycy5cbi8vXG4vLyBBbiBleGNlcHRpb24gdGhyb3duIGJ5IGEgdGFzayB3aWxsIHBlcm1hbmVudGx5IGludGVycnVwdCB0aGUgcHJvY2Vzc2luZyBvZlxuLy8gc3Vic2VxdWVudCB0YXNrcy4gVGhlIGhpZ2hlciBsZXZlbCBgYXNhcGAgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGlmIGFuXG4vLyBleGNlcHRpb24gaXMgdGhyb3duIGJ5IGEgdGFzaywgdGhhdCB0aGUgdGFzayBxdWV1ZSB3aWxsIGNvbnRpbnVlIGZsdXNoaW5nIGFzXG4vLyBzb29uIGFzIHBvc3NpYmxlLCBidXQgaWYgeW91IHVzZSBgcmF3QXNhcGAgZGlyZWN0bHksIHlvdSBhcmUgcmVzcG9uc2libGUgdG9cbi8vIGVpdGhlciBlbnN1cmUgdGhhdCBubyBleGNlcHRpb25zIGFyZSB0aHJvd24gZnJvbSB5b3VyIHRhc2ssIG9yIHRvIG1hbnVhbGx5XG4vLyBjYWxsIGByYXdBc2FwLnJlcXVlc3RGbHVzaGAgaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93bi5cbm1vZHVsZS5leHBvcnRzID0gcmF3QXNhcDtcbmZ1bmN0aW9uIHJhd0FzYXAodGFzaykge1xuICAgIGlmICghcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHJlcXVlc3RGbHVzaCgpO1xuICAgICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgfVxuICAgIC8vIEVxdWl2YWxlbnQgdG8gcHVzaCwgYnV0IGF2b2lkcyBhIGZ1bmN0aW9uIGNhbGwuXG4gICAgcXVldWVbcXVldWUubGVuZ3RoXSA9IHRhc2s7XG59XG5cbnZhciBxdWV1ZSA9IFtdO1xuLy8gT25jZSBhIGZsdXNoIGhhcyBiZWVuIHJlcXVlc3RlZCwgbm8gZnVydGhlciBjYWxscyB0byBgcmVxdWVzdEZsdXNoYCBhcmVcbi8vIG5lY2Vzc2FyeSB1bnRpbCB0aGUgbmV4dCBgZmx1c2hgIGNvbXBsZXRlcy5cbnZhciBmbHVzaGluZyA9IGZhbHNlO1xuLy8gYHJlcXVlc3RGbHVzaGAgaXMgYW4gaW1wbGVtZW50YXRpb24tc3BlY2lmaWMgbWV0aG9kIHRoYXQgYXR0ZW1wdHMgdG8ga2lja1xuLy8gb2ZmIGEgYGZsdXNoYCBldmVudCBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLiBgZmx1c2hgIHdpbGwgYXR0ZW1wdCB0byBleGhhdXN0XG4vLyB0aGUgZXZlbnQgcXVldWUgYmVmb3JlIHlpZWxkaW5nIHRvIHRoZSBicm93c2VyJ3Mgb3duIGV2ZW50IGxvb3AuXG52YXIgcmVxdWVzdEZsdXNoO1xuLy8gVGhlIHBvc2l0aW9uIG9mIHRoZSBuZXh0IHRhc2sgdG8gZXhlY3V0ZSBpbiB0aGUgdGFzayBxdWV1ZS4gVGhpcyBpc1xuLy8gcHJlc2VydmVkIGJldHdlZW4gY2FsbHMgdG8gYGZsdXNoYCBzbyB0aGF0IGl0IGNhbiBiZSByZXN1bWVkIGlmXG4vLyBhIHRhc2sgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbnZhciBpbmRleCA9IDA7XG4vLyBJZiBhIHRhc2sgc2NoZWR1bGVzIGFkZGl0aW9uYWwgdGFza3MgcmVjdXJzaXZlbHksIHRoZSB0YXNrIHF1ZXVlIGNhbiBncm93XG4vLyB1bmJvdW5kZWQuIFRvIHByZXZlbnQgbWVtb3J5IGV4aGF1c3Rpb24sIHRoZSB0YXNrIHF1ZXVlIHdpbGwgcGVyaW9kaWNhbGx5XG4vLyB0cnVuY2F0ZSBhbHJlYWR5LWNvbXBsZXRlZCB0YXNrcy5cbnZhciBjYXBhY2l0eSA9IDEwMjQ7XG5cbi8vIFRoZSBmbHVzaCBmdW5jdGlvbiBwcm9jZXNzZXMgYWxsIHRhc2tzIHRoYXQgaGF2ZSBiZWVuIHNjaGVkdWxlZCB3aXRoXG4vLyBgcmF3QXNhcGAgdW5sZXNzIGFuZCB1bnRpbCBvbmUgb2YgdGhvc2UgdGFza3MgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbi8vIElmIGEgdGFzayB0aHJvd3MgYW4gZXhjZXB0aW9uLCBgZmx1c2hgIGVuc3VyZXMgdGhhdCBpdHMgc3RhdGUgd2lsbCByZW1haW5cbi8vIGNvbnNpc3RlbnQgYW5kIHdpbGwgcmVzdW1lIHdoZXJlIGl0IGxlZnQgb2ZmIHdoZW4gY2FsbGVkIGFnYWluLlxuLy8gSG93ZXZlciwgYGZsdXNoYCBkb2VzIG5vdCBtYWtlIGFueSBhcnJhbmdlbWVudHMgdG8gYmUgY2FsbGVkIGFnYWluIGlmIGFuXG4vLyBleGNlcHRpb24gaXMgdGhyb3duLlxuZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgd2hpbGUgKGluZGV4IDwgcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgLy8gQWR2YW5jZSB0aGUgaW5kZXggYmVmb3JlIGNhbGxpbmcgdGhlIHRhc2suIFRoaXMgZW5zdXJlcyB0aGF0IHdlIHdpbGxcbiAgICAgICAgLy8gYmVnaW4gZmx1c2hpbmcgb24gdGhlIG5leHQgdGFzayB0aGUgdGFzayB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICAgIGluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICBxdWV1ZVtjdXJyZW50SW5kZXhdLmNhbGwoKTtcbiAgICAgICAgLy8gUHJldmVudCBsZWFraW5nIG1lbW9yeSBmb3IgbG9uZyBjaGFpbnMgb2YgcmVjdXJzaXZlIGNhbGxzIHRvIGBhc2FwYC5cbiAgICAgICAgLy8gSWYgd2UgY2FsbCBgYXNhcGAgd2l0aGluIHRhc2tzIHNjaGVkdWxlZCBieSBgYXNhcGAsIHRoZSBxdWV1ZSB3aWxsXG4gICAgICAgIC8vIGdyb3csIGJ1dCB0byBhdm9pZCBhbiBPKG4pIHdhbGsgZm9yIGV2ZXJ5IHRhc2sgd2UgZXhlY3V0ZSwgd2UgZG9uJ3RcbiAgICAgICAgLy8gc2hpZnQgdGFza3Mgb2ZmIHRoZSBxdWV1ZSBhZnRlciB0aGV5IGhhdmUgYmVlbiBleGVjdXRlZC5cbiAgICAgICAgLy8gSW5zdGVhZCwgd2UgcGVyaW9kaWNhbGx5IHNoaWZ0IDEwMjQgdGFza3Mgb2ZmIHRoZSBxdWV1ZS5cbiAgICAgICAgaWYgKGluZGV4ID4gY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IHNoaWZ0IGFsbCB2YWx1ZXMgc3RhcnRpbmcgYXQgdGhlIGluZGV4IGJhY2sgdG8gdGhlXG4gICAgICAgICAgICAvLyBiZWdpbm5pbmcgb2YgdGhlIHF1ZXVlLlxuICAgICAgICAgICAgZm9yICh2YXIgc2NhbiA9IDAsIG5ld0xlbmd0aCA9IHF1ZXVlLmxlbmd0aCAtIGluZGV4OyBzY2FuIDwgbmV3TGVuZ3RoOyBzY2FuKyspIHtcbiAgICAgICAgICAgICAgICBxdWV1ZVtzY2FuXSA9IHF1ZXVlW3NjYW4gKyBpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZS5sZW5ndGggLT0gaW5kZXg7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICBpbmRleCA9IDA7XG4gICAgZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLy8gYHJlcXVlc3RGbHVzaGAgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSBzdHJhdGVneSBiYXNlZCBvbiBkYXRhIGNvbGxlY3RlZCBmcm9tXG4vLyBldmVyeSBhdmFpbGFibGUgU2F1Y2VMYWJzIFNlbGVuaXVtIHdlYiBkcml2ZXIgd29ya2VyIGF0IHRpbWUgb2Ygd3JpdGluZy5cbi8vIGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL3NwcmVhZHNoZWV0cy9kLzFtRy01VVlHdXA1cXhHZEVNV2toUDZCV0N6MDUzTlViMkUxUW9VVFUxNnVBL2VkaXQjZ2lkPTc4MzcyNDU5M1xuXG4vLyBTYWZhcmkgNiBhbmQgNi4xIGZvciBkZXNrdG9wLCBpUGFkLCBhbmQgaVBob25lIGFyZSB0aGUgb25seSBicm93c2VycyB0aGF0XG4vLyBoYXZlIFdlYktpdE11dGF0aW9uT2JzZXJ2ZXIgYnV0IG5vdCB1bi1wcmVmaXhlZCBNdXRhdGlvbk9ic2VydmVyLlxuLy8gTXVzdCB1c2UgYGdsb2JhbGAgaW5zdGVhZCBvZiBgd2luZG93YCB0byB3b3JrIGluIGJvdGggZnJhbWVzIGFuZCB3ZWJcbi8vIHdvcmtlcnMuIGBnbG9iYWxgIGlzIGEgcHJvdmlzaW9uIG9mIEJyb3dzZXJpZnksIE1yLCBNcnMsIG9yIE1vcC5cbnZhciBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuXG4vLyBNdXRhdGlvbk9ic2VydmVycyBhcmUgZGVzaXJhYmxlIGJlY2F1c2UgdGhleSBoYXZlIGhpZ2ggcHJpb3JpdHkgYW5kIHdvcmtcbi8vIHJlbGlhYmx5IGV2ZXJ5d2hlcmUgdGhleSBhcmUgaW1wbGVtZW50ZWQuXG4vLyBUaGV5IGFyZSBpbXBsZW1lbnRlZCBpbiBhbGwgbW9kZXJuIGJyb3dzZXJzLlxuLy9cbi8vIC0gQW5kcm9pZCA0LTQuM1xuLy8gLSBDaHJvbWUgMjYtMzRcbi8vIC0gRmlyZWZveCAxNC0yOVxuLy8gLSBJbnRlcm5ldCBFeHBsb3JlciAxMVxuLy8gLSBpUGFkIFNhZmFyaSA2LTcuMVxuLy8gLSBpUGhvbmUgU2FmYXJpIDctNy4xXG4vLyAtIFNhZmFyaSA2LTdcbmlmICh0eXBlb2YgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJlcXVlc3RGbHVzaCA9IG1ha2VSZXF1ZXN0Q2FsbEZyb21NdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcblxuLy8gTWVzc2FnZUNoYW5uZWxzIGFyZSBkZXNpcmFibGUgYmVjYXVzZSB0aGV5IGdpdmUgZGlyZWN0IGFjY2VzcyB0byB0aGUgSFRNTFxuLy8gdGFzayBxdWV1ZSwgYXJlIGltcGxlbWVudGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwLCBTYWZhcmkgNS4wLTEsIGFuZCBPcGVyYVxuLy8gMTEtMTIsIGFuZCBpbiB3ZWIgd29ya2VycyBpbiBtYW55IGVuZ2luZXMuXG4vLyBBbHRob3VnaCBtZXNzYWdlIGNoYW5uZWxzIHlpZWxkIHRvIGFueSBxdWV1ZWQgcmVuZGVyaW5nIGFuZCBJTyB0YXNrcywgdGhleVxuLy8gd291bGQgYmUgYmV0dGVyIHRoYW4gaW1wb3NpbmcgdGhlIDRtcyBkZWxheSBvZiB0aW1lcnMuXG4vLyBIb3dldmVyLCB0aGV5IGRvIG5vdCB3b3JrIHJlbGlhYmx5IGluIEludGVybmV0IEV4cGxvcmVyIG9yIFNhZmFyaS5cblxuLy8gSW50ZXJuZXQgRXhwbG9yZXIgMTAgaXMgdGhlIG9ubHkgYnJvd3NlciB0aGF0IGhhcyBzZXRJbW1lZGlhdGUgYnV0IGRvZXNcbi8vIG5vdCBoYXZlIE11dGF0aW9uT2JzZXJ2ZXJzLlxuLy8gQWx0aG91Z2ggc2V0SW1tZWRpYXRlIHlpZWxkcyB0byB0aGUgYnJvd3NlcidzIHJlbmRlcmVyLCBpdCB3b3VsZCBiZVxuLy8gcHJlZmVycmFibGUgdG8gZmFsbGluZyBiYWNrIHRvIHNldFRpbWVvdXQgc2luY2UgaXQgZG9lcyBub3QgaGF2ZVxuLy8gdGhlIG1pbmltdW0gNG1zIHBlbmFsdHkuXG4vLyBVbmZvcnR1bmF0ZWx5IHRoZXJlIGFwcGVhcnMgdG8gYmUgYSBidWcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAgTW9iaWxlIChhbmRcbi8vIERlc2t0b3AgdG8gYSBsZXNzZXIgZXh0ZW50KSB0aGF0IHJlbmRlcnMgYm90aCBzZXRJbW1lZGlhdGUgYW5kXG4vLyBNZXNzYWdlQ2hhbm5lbCB1c2VsZXNzIGZvciB0aGUgcHVycG9zZXMgb2YgQVNBUC5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcS9pc3N1ZXMvMzk2XG5cbi8vIFRpbWVycyBhcmUgaW1wbGVtZW50ZWQgdW5pdmVyc2FsbHkuXG4vLyBXZSBmYWxsIGJhY2sgdG8gdGltZXJzIGluIHdvcmtlcnMgaW4gbW9zdCBlbmdpbmVzLCBhbmQgaW4gZm9yZWdyb3VuZFxuLy8gY29udGV4dHMgaW4gdGhlIGZvbGxvd2luZyBicm93c2Vycy5cbi8vIEhvd2V2ZXIsIG5vdGUgdGhhdCBldmVuIHRoaXMgc2ltcGxlIGNhc2UgcmVxdWlyZXMgbnVhbmNlcyB0byBvcGVyYXRlIGluIGFcbi8vIGJyb2FkIHNwZWN0cnVtIG9mIGJyb3dzZXJzLlxuLy9cbi8vIC0gRmlyZWZveCAzLTEzXG4vLyAtIEludGVybmV0IEV4cGxvcmVyIDYtOVxuLy8gLSBpUGFkIFNhZmFyaSA0LjNcbi8vIC0gTHlueCAyLjguN1xufSBlbHNlIHtcbiAgICByZXF1ZXN0Rmx1c2ggPSBtYWtlUmVxdWVzdENhbGxGcm9tVGltZXIoZmx1c2gpO1xufVxuXG4vLyBgcmVxdWVzdEZsdXNoYCByZXF1ZXN0cyB0aGF0IHRoZSBoaWdoIHByaW9yaXR5IGV2ZW50IHF1ZXVlIGJlIGZsdXNoZWQgYXNcbi8vIHNvb24gYXMgcG9zc2libGUuXG4vLyBUaGlzIGlzIHVzZWZ1bCB0byBwcmV2ZW50IGFuIGVycm9yIHRocm93biBpbiBhIHRhc2sgZnJvbSBzdGFsbGluZyB0aGUgZXZlbnRcbi8vIHF1ZXVlIGlmIHRoZSBleGNlcHRpb24gaGFuZGxlZCBieSBOb2RlLmpz4oCZc1xuLy8gYHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiKWAgb3IgYnkgYSBkb21haW4uXG5yYXdBc2FwLnJlcXVlc3RGbHVzaCA9IHJlcXVlc3RGbHVzaDtcblxuLy8gVG8gcmVxdWVzdCBhIGhpZ2ggcHJpb3JpdHkgZXZlbnQsIHdlIGluZHVjZSBhIG11dGF0aW9uIG9ic2VydmVyIGJ5IHRvZ2dsaW5nXG4vLyB0aGUgdGV4dCBvZiBhIHRleHQgbm9kZSBiZXR3ZWVuIFwiMVwiIGFuZCBcIi0xXCIuXG5mdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjaykge1xuICAgIHZhciB0b2dnbGUgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjayk7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuICAgICAgICB0b2dnbGUgPSAtdG9nZ2xlO1xuICAgICAgICBub2RlLmRhdGEgPSB0b2dnbGU7XG4gICAgfTtcbn1cblxuLy8gVGhlIG1lc3NhZ2UgY2hhbm5lbCB0ZWNobmlxdWUgd2FzIGRpc2NvdmVyZWQgYnkgTWFsdGUgVWJsIGFuZCB3YXMgdGhlXG4vLyBvcmlnaW5hbCBmb3VuZGF0aW9uIGZvciB0aGlzIGxpYnJhcnkuXG4vLyBodHRwOi8vd3d3Lm5vbmJsb2NraW5nLmlvLzIwMTEvMDYvd2luZG93bmV4dHRpY2suaHRtbFxuXG4vLyBTYWZhcmkgNi4wLjUgKGF0IGxlYXN0KSBpbnRlcm1pdHRlbnRseSBmYWlscyB0byBjcmVhdGUgbWVzc2FnZSBwb3J0cyBvbiBhXG4vLyBwYWdlJ3MgZmlyc3QgbG9hZC4gVGhhbmtmdWxseSwgdGhpcyB2ZXJzaW9uIG9mIFNhZmFyaSBzdXBwb3J0c1xuLy8gTXV0YXRpb25PYnNlcnZlcnMsIHNvIHdlIGRvbid0IG5lZWQgdG8gZmFsbCBiYWNrIGluIHRoYXQgY2FzZS5cblxuLy8gZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbU1lc3NhZ2VDaGFubmVsKGNhbGxiYWNrKSB7XG4vLyAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbi8vICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGNhbGxiYWNrO1xuLy8gICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbi8vICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbi8vICAgICB9O1xuLy8gfVxuXG4vLyBGb3IgcmVhc29ucyBleHBsYWluZWQgYWJvdmUsIHdlIGFyZSBhbHNvIHVuYWJsZSB0byB1c2UgYHNldEltbWVkaWF0ZWBcbi8vIHVuZGVyIGFueSBjaXJjdW1zdGFuY2VzLlxuLy8gRXZlbiBpZiB3ZSB3ZXJlLCB0aGVyZSBpcyBhbm90aGVyIGJ1ZyBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMC5cbi8vIEl0IGlzIG5vdCBzdWZmaWNpZW50IHRvIGFzc2lnbiBgc2V0SW1tZWRpYXRlYCB0byBgcmVxdWVzdEZsdXNoYCBiZWNhdXNlXG4vLyBgc2V0SW1tZWRpYXRlYCBtdXN0IGJlIGNhbGxlZCAqYnkgbmFtZSogYW5kIHRoZXJlZm9yZSBtdXN0IGJlIHdyYXBwZWQgaW4gYVxuLy8gY2xvc3VyZS5cbi8vIE5ldmVyIGZvcmdldC5cblxuLy8gZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbVNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuLy8gICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbi8vICAgICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbi8vICAgICB9O1xuLy8gfVxuXG4vLyBTYWZhcmkgNi4wIGhhcyBhIHByb2JsZW0gd2hlcmUgdGltZXJzIHdpbGwgZ2V0IGxvc3Qgd2hpbGUgdGhlIHVzZXIgaXNcbi8vIHNjcm9sbGluZy4gVGhpcyBwcm9ibGVtIGRvZXMgbm90IGltcGFjdCBBU0FQIGJlY2F1c2UgU2FmYXJpIDYuMCBzdXBwb3J0c1xuLy8gbXV0YXRpb24gb2JzZXJ2ZXJzLCBzbyB0aGF0IGltcGxlbWVudGF0aW9uIGlzIHVzZWQgaW5zdGVhZC5cbi8vIEhvd2V2ZXIsIGlmIHdlIGV2ZXIgZWxlY3QgdG8gdXNlIHRpbWVycyBpbiBTYWZhcmksIHRoZSBwcmV2YWxlbnQgd29yay1hcm91bmRcbi8vIGlzIHRvIGFkZCBhIHNjcm9sbCBldmVudCBsaXN0ZW5lciB0aGF0IGNhbGxzIGZvciBhIGZsdXNoLlxuXG4vLyBgc2V0VGltZW91dGAgZG9lcyBub3QgY2FsbCB0aGUgcGFzc2VkIGNhbGxiYWNrIGlmIHRoZSBkZWxheSBpcyBsZXNzIHRoYW5cbi8vIGFwcHJveGltYXRlbHkgNyBpbiB3ZWIgd29ya2VycyBpbiBGaXJlZm94IDggdGhyb3VnaCAxOCwgYW5kIHNvbWV0aW1lcyBub3Rcbi8vIGV2ZW4gdGhlbi5cblxuZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuICAgICAgICAvLyBXZSBkaXNwYXRjaCBhIHRpbWVvdXQgd2l0aCBhIHNwZWNpZmllZCBkZWxheSBvZiAwIGZvciBlbmdpbmVzIHRoYXRcbiAgICAgICAgLy8gY2FuIHJlbGlhYmx5IGFjY29tbW9kYXRlIHRoYXQgcmVxdWVzdC4gVGhpcyB3aWxsIHVzdWFsbHkgYmUgc25hcHBlZFxuICAgICAgICAvLyB0byBhIDQgbWlsaXNlY29uZCBkZWxheSwgYnV0IG9uY2Ugd2UncmUgZmx1c2hpbmcsIHRoZXJlJ3Mgbm8gZGVsYXlcbiAgICAgICAgLy8gYmV0d2VlbiBldmVudHMuXG4gICAgICAgIHZhciB0aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dChoYW5kbGVUaW1lciwgMCk7XG4gICAgICAgIC8vIEhvd2V2ZXIsIHNpbmNlIHRoaXMgdGltZXIgZ2V0cyBmcmVxdWVudGx5IGRyb3BwZWQgaW4gRmlyZWZveFxuICAgICAgICAvLyB3b3JrZXJzLCB3ZSBlbmxpc3QgYW4gaW50ZXJ2YWwgaGFuZGxlIHRoYXQgd2lsbCB0cnkgdG8gZmlyZVxuICAgICAgICAvLyBhbiBldmVudCAyMCB0aW1lcyBwZXIgc2Vjb25kIHVudGlsIGl0IHN1Y2NlZWRzLlxuICAgICAgICB2YXIgaW50ZXJ2YWxIYW5kbGUgPSBzZXRJbnRlcnZhbChoYW5kbGVUaW1lciwgNTApO1xuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpbWVyKCkge1xuICAgICAgICAgICAgLy8gV2hpY2hldmVyIHRpbWVyIHN1Y2NlZWRzIHdpbGwgY2FuY2VsIGJvdGggdGltZXJzIGFuZFxuICAgICAgICAgICAgLy8gZXhlY3V0ZSB0aGUgY2FsbGJhY2suXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSk7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSGFuZGxlKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBUaGlzIGlzIGZvciBgYXNhcC5qc2Agb25seS5cbi8vIEl0cyBuYW1lIHdpbGwgYmUgcGVyaW9kaWNhbGx5IHJhbmRvbWl6ZWQgdG8gYnJlYWsgYW55IGNvZGUgdGhhdCBkZXBlbmRzIG9uXG4vLyBpdHMgZXhpc3RlbmNlLlxucmF3QXNhcC5tYWtlUmVxdWVzdENhbGxGcm9tVGltZXIgPSBtYWtlUmVxdWVzdENhbGxGcm9tVGltZXI7XG5cbi8vIEFTQVAgd2FzIG9yaWdpbmFsbHkgYSBuZXh0VGljayBzaGltIGluY2x1ZGVkIGluIFEuIFRoaXMgd2FzIGZhY3RvcmVkIG91dFxuLy8gaW50byB0aGlzIEFTQVAgcGFja2FnZS4gSXQgd2FzIGxhdGVyIGFkYXB0ZWQgdG8gUlNWUCB3aGljaCBtYWRlIGZ1cnRoZXJcbi8vIGFtZW5kbWVudHMuIFRoZXNlIGRlY2lzaW9ucywgcGFydGljdWxhcmx5IHRvIG1hcmdpbmFsaXplIE1lc3NhZ2VDaGFubmVsIGFuZFxuLy8gdG8gY2FwdHVyZSB0aGUgTXV0YXRpb25PYnNlcnZlciBpbXBsZW1lbnRhdGlvbiBpbiBhIGNsb3N1cmUsIHdlcmUgaW50ZWdyYXRlZFxuLy8gYmFjayBpbnRvIEFTQVAgcHJvcGVyLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RpbGRlaW8vcnN2cC5qcy9ibG9iL2NkZGY3MjMyNTQ2YTljZjg1ODUyNGI3NWNkZTZmOWVkZjcyNjIwYTcvbGliL3JzdnAvYXNhcC5qc1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se31dLDk0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGFzYXAgPSByZXF1aXJlKCdhc2FwL3JhdycpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuLy8gU3RhdGVzOlxuLy9cbi8vIDAgLSBwZW5kaW5nXG4vLyAxIC0gZnVsZmlsbGVkIHdpdGggX3ZhbHVlXG4vLyAyIC0gcmVqZWN0ZWQgd2l0aCBfdmFsdWVcbi8vIDMgLSBhZG9wdGVkIHRoZSBzdGF0ZSBvZiBhbm90aGVyIHByb21pc2UsIF92YWx1ZVxuLy9cbi8vIG9uY2UgdGhlIHN0YXRlIGlzIG5vIGxvbmdlciBwZW5kaW5nICgwKSBpdCBpcyBpbW11dGFibGVcblxuLy8gQWxsIGBfYCBwcmVmaXhlZCBwcm9wZXJ0aWVzIHdpbGwgYmUgcmVkdWNlZCB0byBgX3tyYW5kb20gbnVtYmVyfWBcbi8vIGF0IGJ1aWxkIHRpbWUgdG8gb2JmdXNjYXRlIHRoZW0gYW5kIGRpc2NvdXJhZ2UgdGhlaXIgdXNlLlxuLy8gV2UgZG9uJ3QgdXNlIHN5bWJvbHMgb3IgT2JqZWN0LmRlZmluZVByb3BlcnR5IHRvIGZ1bGx5IGhpZGUgdGhlbVxuLy8gYmVjYXVzZSB0aGUgcGVyZm9ybWFuY2UgaXNuJ3QgZ29vZCBlbm91Z2guXG5cblxuLy8gdG8gYXZvaWQgdXNpbmcgdHJ5L2NhdGNoIGluc2lkZSBjcml0aWNhbCBmdW5jdGlvbnMsIHdlXG4vLyBleHRyYWN0IHRoZW0gdG8gaGVyZS5cbnZhciBMQVNUX0VSUk9SID0gbnVsbDtcbnZhciBJU19FUlJPUiA9IHt9O1xuZnVuY3Rpb24gZ2V0VGhlbihvYmopIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gb2JqLnRoZW47XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgTEFTVF9FUlJPUiA9IGV4O1xuICAgIHJldHVybiBJU19FUlJPUjtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlDYWxsT25lKGZuLCBhKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKGEpO1xuICB9IGNhdGNoIChleCkge1xuICAgIExBU1RfRVJST1IgPSBleDtcbiAgICByZXR1cm4gSVNfRVJST1I7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyeUNhbGxUd28oZm4sIGEsIGIpIHtcbiAgdHJ5IHtcbiAgICBmbihhLCBiKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBMQVNUX0VSUk9SID0gZXg7XG4gICAgcmV0dXJuIElTX0VSUk9SO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxuZnVuY3Rpb24gUHJvbWlzZShmbikge1xuICBpZiAodHlwZW9mIHRoaXMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3Jyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdGhpcy5fNDUgPSAwO1xuICB0aGlzLl84MSA9IDA7XG4gIHRoaXMuXzY1ID0gbnVsbDtcbiAgdGhpcy5fNTQgPSBudWxsO1xuICBpZiAoZm4gPT09IG5vb3ApIHJldHVybjtcbiAgZG9SZXNvbHZlKGZuLCB0aGlzKTtcbn1cblByb21pc2UuXzEwID0gbnVsbDtcblByb21pc2UuXzk3ID0gbnVsbDtcblByb21pc2UuXzYxID0gbm9vcDtcblxuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIGlmICh0aGlzLmNvbnN0cnVjdG9yICE9PSBQcm9taXNlKSB7XG4gICAgcmV0dXJuIHNhZmVUaGVuKHRoaXMsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgfVxuICB2YXIgcmVzID0gbmV3IFByb21pc2Uobm9vcCk7XG4gIGhhbmRsZSh0aGlzLCBuZXcgSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzKSk7XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBzYWZlVGhlbihzZWxmLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICByZXR1cm4gbmV3IHNlbGYuY29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXMgPSBuZXcgUHJvbWlzZShub29wKTtcbiAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIGhhbmRsZShzZWxmLCBuZXcgSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzKSk7XG4gIH0pO1xufTtcbmZ1bmN0aW9uIGhhbmRsZShzZWxmLCBkZWZlcnJlZCkge1xuICB3aGlsZSAoc2VsZi5fODEgPT09IDMpIHtcbiAgICBzZWxmID0gc2VsZi5fNjU7XG4gIH1cbiAgaWYgKFByb21pc2UuXzEwKSB7XG4gICAgUHJvbWlzZS5fMTAoc2VsZik7XG4gIH1cbiAgaWYgKHNlbGYuXzgxID09PSAwKSB7XG4gICAgaWYgKHNlbGYuXzQ1ID09PSAwKSB7XG4gICAgICBzZWxmLl80NSA9IDE7XG4gICAgICBzZWxmLl81NCA9IGRlZmVycmVkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2VsZi5fNDUgPT09IDEpIHtcbiAgICAgIHNlbGYuXzQ1ID0gMjtcbiAgICAgIHNlbGYuXzU0ID0gW3NlbGYuXzU0LCBkZWZlcnJlZF07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuXzU0LnB1c2goZGVmZXJyZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICBoYW5kbGVSZXNvbHZlZChzZWxmLCBkZWZlcnJlZCk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVJlc29sdmVkKHNlbGYsIGRlZmVycmVkKSB7XG4gIGFzYXAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNiID0gc2VsZi5fODEgPT09IDEgPyBkZWZlcnJlZC5vbkZ1bGZpbGxlZCA6IGRlZmVycmVkLm9uUmVqZWN0ZWQ7XG4gICAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgICBpZiAoc2VsZi5fODEgPT09IDEpIHtcbiAgICAgICAgcmVzb2x2ZShkZWZlcnJlZC5wcm9taXNlLCBzZWxmLl82NSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3QoZGVmZXJyZWQucHJvbWlzZSwgc2VsZi5fNjUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gdHJ5Q2FsbE9uZShjYiwgc2VsZi5fNjUpO1xuICAgIGlmIChyZXQgPT09IElTX0VSUk9SKSB7XG4gICAgICByZWplY3QoZGVmZXJyZWQucHJvbWlzZSwgTEFTVF9FUlJPUik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUoZGVmZXJyZWQucHJvbWlzZSwgcmV0KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVzb2x2ZShzZWxmLCBuZXdWYWx1ZSkge1xuICAvLyBQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlOiBodHRwczovL2dpdGh1Yi5jb20vcHJvbWlzZXMtYXBsdXMvcHJvbWlzZXMtc3BlYyN0aGUtcHJvbWlzZS1yZXNvbHV0aW9uLXByb2NlZHVyZVxuICBpZiAobmV3VmFsdWUgPT09IHNlbGYpIHtcbiAgICByZXR1cm4gcmVqZWN0KFxuICAgICAgc2VsZixcbiAgICAgIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuJylcbiAgICApO1xuICB9XG4gIGlmIChcbiAgICBuZXdWYWx1ZSAmJlxuICAgICh0eXBlb2YgbmV3VmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgKSB7XG4gICAgdmFyIHRoZW4gPSBnZXRUaGVuKG5ld1ZhbHVlKTtcbiAgICBpZiAodGhlbiA9PT0gSVNfRVJST1IpIHtcbiAgICAgIHJldHVybiByZWplY3Qoc2VsZiwgTEFTVF9FUlJPUik7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHRoZW4gPT09IHNlbGYudGhlbiAmJlxuICAgICAgbmV3VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlXG4gICAgKSB7XG4gICAgICBzZWxmLl84MSA9IDM7XG4gICAgICBzZWxmLl82NSA9IG5ld1ZhbHVlO1xuICAgICAgZmluYWxlKHNlbGYpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRvUmVzb2x2ZSh0aGVuLmJpbmQobmV3VmFsdWUpLCBzZWxmKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgc2VsZi5fODEgPSAxO1xuICBzZWxmLl82NSA9IG5ld1ZhbHVlO1xuICBmaW5hbGUoc2VsZik7XG59XG5cbmZ1bmN0aW9uIHJlamVjdChzZWxmLCBuZXdWYWx1ZSkge1xuICBzZWxmLl84MSA9IDI7XG4gIHNlbGYuXzY1ID0gbmV3VmFsdWU7XG4gIGlmIChQcm9taXNlLl85Nykge1xuICAgIFByb21pc2UuXzk3KHNlbGYsIG5ld1ZhbHVlKTtcbiAgfVxuICBmaW5hbGUoc2VsZik7XG59XG5mdW5jdGlvbiBmaW5hbGUoc2VsZikge1xuICBpZiAoc2VsZi5fNDUgPT09IDEpIHtcbiAgICBoYW5kbGUoc2VsZiwgc2VsZi5fNTQpO1xuICAgIHNlbGYuXzU0ID0gbnVsbDtcbiAgfVxuICBpZiAoc2VsZi5fNDUgPT09IDIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuXzU0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYW5kbGUoc2VsZiwgc2VsZi5fNTRbaV0pO1xuICAgIH1cbiAgICBzZWxmLl81NCA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcHJvbWlzZSl7XG4gIHRoaXMub25GdWxmaWxsZWQgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IG51bGw7XG4gIHRoaXMub25SZWplY3RlZCA9IHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nID8gb25SZWplY3RlZCA6IG51bGw7XG4gIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG59XG5cbi8qKlxuICogVGFrZSBhIHBvdGVudGlhbGx5IG1pc2JlaGF2aW5nIHJlc29sdmVyIGZ1bmN0aW9uIGFuZCBtYWtlIHN1cmVcbiAqIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGFyZSBvbmx5IGNhbGxlZCBvbmNlLlxuICpcbiAqIE1ha2VzIG5vIGd1YXJhbnRlZXMgYWJvdXQgYXN5bmNocm9ueS5cbiAqL1xuZnVuY3Rpb24gZG9SZXNvbHZlKGZuLCBwcm9taXNlKSB7XG4gIHZhciBkb25lID0gZmFsc2U7XG4gIHZhciByZXMgPSB0cnlDYWxsVHdvKGZuLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgIGRvbmUgPSB0cnVlO1xuICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICBkb25lID0gdHJ1ZTtcbiAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgfSlcbiAgaWYgKCFkb25lICYmIHJlcyA9PT0gSVNfRVJST1IpIHtcbiAgICBkb25lID0gdHJ1ZTtcbiAgICByZWplY3QocHJvbWlzZSwgTEFTVF9FUlJPUik7XG4gIH1cbn1cblxufSx7XCJhc2FwL3Jhd1wiOjkzfV0sOTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vL1RoaXMgZmlsZSBjb250YWlucyB0aGUgRVM2IGV4dGVuc2lvbnMgdG8gdGhlIGNvcmUgUHJvbWlzZXMvQSsgQVBJXG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9jb3JlLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxuLyogU3RhdGljIEZ1bmN0aW9ucyAqL1xuXG52YXIgVFJVRSA9IHZhbHVlUHJvbWlzZSh0cnVlKTtcbnZhciBGQUxTRSA9IHZhbHVlUHJvbWlzZShmYWxzZSk7XG52YXIgTlVMTCA9IHZhbHVlUHJvbWlzZShudWxsKTtcbnZhciBVTkRFRklORUQgPSB2YWx1ZVByb21pc2UodW5kZWZpbmVkKTtcbnZhciBaRVJPID0gdmFsdWVQcm9taXNlKDApO1xudmFyIEVNUFRZU1RSSU5HID0gdmFsdWVQcm9taXNlKCcnKTtcblxuZnVuY3Rpb24gdmFsdWVQcm9taXNlKHZhbHVlKSB7XG4gIHZhciBwID0gbmV3IFByb21pc2UoUHJvbWlzZS5fNjEpO1xuICBwLl84MSA9IDE7XG4gIHAuXzY1ID0gdmFsdWU7XG4gIHJldHVybiBwO1xufVxuUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiB2YWx1ZTtcblxuICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiBOVUxMO1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFVOREVGSU5FRDtcbiAgaWYgKHZhbHVlID09PSB0cnVlKSByZXR1cm4gVFJVRTtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSkgcmV0dXJuIEZBTFNFO1xuICBpZiAodmFsdWUgPT09IDApIHJldHVybiBaRVJPO1xuICBpZiAodmFsdWUgPT09ICcnKSByZXR1cm4gRU1QVFlTVFJJTkc7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0aGVuID0gdmFsdWUudGhlbjtcbiAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UodGhlbi5iaW5kKHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlamVjdChleCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlUHJvbWlzZSh2YWx1ZSk7XG59O1xuXG5Qcm9taXNlLmFsbCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzb2x2ZShbXSk7XG4gICAgdmFyIHJlbWFpbmluZyA9IGFyZ3MubGVuZ3RoO1xuICAgIGZ1bmN0aW9uIHJlcyhpLCB2YWwpIHtcbiAgICAgIGlmICh2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBQcm9taXNlICYmIHZhbC50aGVuID09PSBQcm9taXNlLnByb3RvdHlwZS50aGVuKSB7XG4gICAgICAgICAgd2hpbGUgKHZhbC5fODEgPT09IDMpIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbC5fNjU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWwuXzgxID09PSAxKSByZXR1cm4gcmVzKGksIHZhbC5fNjUpO1xuICAgICAgICAgIGlmICh2YWwuXzgxID09PSAyKSByZWplY3QodmFsLl82NSk7XG4gICAgICAgICAgdmFsLnRoZW4oZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmVzKGksIHZhbCk7XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRoZW4gPSB2YWwudGhlbjtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBwID0gbmV3IFByb21pc2UodGhlbi5iaW5kKHZhbCkpO1xuICAgICAgICAgICAgcC50aGVuKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgcmVzKGksIHZhbCk7XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXJnc1tpXSA9IHZhbDtcbiAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICByZXNvbHZlKGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlcyhpLCBhcmdzW2ldKTtcbiAgICB9XG4gIH0pO1xufTtcblxuUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWplY3QodmFsdWUpO1xuICB9KTtcbn07XG5cblByb21pc2UucmFjZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKiBQcm90b3R5cGUgTWV0aG9kcyAqL1xuXG5Qcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG59O1xuXG59LHtcIi4vY29yZS5qc1wiOjk0fV0sOTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gc2hvdWxkIHdvcmsgaW4gYW55IGJyb3dzZXIgd2l0aG91dCBicm93c2VyaWZ5XG5cbmlmICh0eXBlb2YgUHJvbWlzZS5wcm90b3R5cGUuZG9uZSAhPT0gJ2Z1bmN0aW9uJykge1xuICBQcm9taXNlLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIHNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50aGVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0aGlzXG4gICAgc2VsZi50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH0sIDApXG4gICAgfSlcbiAgfVxufVxufSx7fV0sOTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gbm90IFwidXNlIHN0cmljdFwiIHNvIHdlIGNhbiBkZWNsYXJlIGdsb2JhbCBcIlByb21pc2VcIlxuXG52YXIgYXNhcCA9IHJlcXVpcmUoJ2FzYXAnKTtcblxuaWYgKHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJykge1xuICBQcm9taXNlID0gcmVxdWlyZSgnLi9saWIvY29yZS5qcycpXG4gIHJlcXVpcmUoJy4vbGliL2VzNi1leHRlbnNpb25zLmpzJylcbn1cblxucmVxdWlyZSgnLi9wb2x5ZmlsbC1kb25lLmpzJyk7XG5cbn0se1wiLi9saWIvY29yZS5qc1wiOjk0LFwiLi9saWIvZXM2LWV4dGVuc2lvbnMuanNcIjo5NSxcIi4vcG9seWZpbGwtZG9uZS5qc1wiOjk2LFwiYXNhcFwiOjkyfV19LHt9LFsyXSkoMilcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xlc3MvZGlzdC9sZXNzLmpzXG4vLyBtb2R1bGUgaWQgPSA1NzVcbi8vIG1vZHVsZSBjaHVua3MgPSA1IiwiaW1wb3J0IHN0b3JlIGZyb20gJy4uL3JlZHV4L3N0b3JlJ1xyXG5pbXBvcnQge1NBVkVfVE9fREFUQUJBU0UsIEhUTUxfU1VCTUlULCBDU1NfU1VCTUlULCBKU19TVUJNSVR9IGZyb20gJy4uL3JlZHV4L2FjdGlvbnMnXHJcblxyXG5pbXBvcnQgUmVzdWx0IGZyb20gJy4uL2NvbXBvbmVudHMvUmVzdWx0J1xyXG5pbXBvcnQgQ3NzIGZyb20gJy4uL2NvbXBvbmVudHMvQ3NzJztcclxuaW1wb3J0IEpzIGZyb20gJy4uL2NvbXBvbmVudHMvSlMnO1xyXG5pbXBvcnQgSHRtbCBmcm9tICcuLi9jb21wb25lbnRzL0h0bWwnO1xyXG5cclxuY2xhc3MgSW5kZXggZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAncmVzdWx0J1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfY2hhbmdlVGl0bGUodHlwZSkge1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe3R5cGV9KTtcclxuICAgIH1cclxuXHJcbiAgICBfZ2V0SW5pdGlhbENvbnRlbnRGcm9tU2VydmVyKCkge1xyXG4gICAgICAgIC8vIGdldHMgaW5pdGlhbCBjb250ZW50cyBmcm9tIHRoZSBkYXRhYmFzZSBhbmQgdGhlbiBkaXNwYXRjaGVzIGl0IHRvIHRoZSBzdG9yZVxyXG4gICAgICAgIGxldCBpbml0aWFsQ29udGVudCA9IHtcclxuICAgICAgICAgICAgaHRtbDogXCI8cD55bzwvcD5cIixcclxuICAgICAgICAgICAgY3NzOiBgcHtcXG4gIGNvbG9yOnJlZDtcXG4gfWAsXHJcbiAgICAgICAgICAgIGpzOiBgY29uc29sZS5sb2coXCJIZWxsbyBHZW50bGVtYW5cIik7YFxyXG4gICAgICAgIH1cclxuICAgICAgICBzdG9yZS5kaXNwYXRjaChIVE1MX1NVQk1JVChpbml0aWFsQ29udGVudC5odG1sKSlcclxuICAgICAgICBzdG9yZS5kaXNwYXRjaChDU1NfU1VCTUlUKGluaXRpYWxDb250ZW50LmNzcykpXHJcbiAgICAgICAgc3RvcmUuZGlzcGF0Y2goSlNfU1VCTUlUKGluaXRpYWxDb250ZW50LmpzKSlcclxuICAgICAgICAvLyBtb2NrIGluaXRpYWwgY29udGVudFxyXG5cclxuICAgICAgICBpbml0aWFsQ29udGVudDtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XHJcbiAgICAgICAgdGhpcy5fZ2V0SW5pdGlhbENvbnRlbnRGcm9tU2VydmVyKClcclxuICAgIH1cclxuXHJcbiAgICBfcmVuZGVyRWxlbWVudCgpIHtcclxuXHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAncmVzdWx0JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAoPFJlc3VsdC8+KVxyXG4gICAgICAgICAgICBjYXNlICdodG1sJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAoPEh0bWwvPilcclxuICAgICAgICAgICAgY2FzZSAnY3NzJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAoPENzcy8+KVxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICg8SnMvPilcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiB0aGlzLl9jaGFuZ2VUaXRsZSgncmVzdWx0Jyl9PlJlc3VsdDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiB0aGlzLl9jaGFuZ2VUaXRsZSgnaHRtbCcpfT5IVE1MPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHRoaXMuX2NoYW5nZVRpdGxlKCdjc3MnKX0+Q1NTPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHRoaXMuX2NoYW5nZVRpdGxlKCdqcycpfT5KYXZhU2NyaXB0PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICB7dGhpcy5fcmVuZGVyRWxlbWVudCgpfVxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPSB7ICgpID0+IHN0b3JlLmRpc3BhdGNoKFNBVkVfVE9fREFUQUJBU0UoKSl9PlxyXG4gICAgICAgICAgICAgICAgICAgIFB1Ymxpc2ggeW91ciBTbmlwcGV0IVxyXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIClcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEluZGV4XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFnZXM/ZW50cnkiLCJpbXBvcnQgY3JlYXRlU3RvcmUgZnJvbSAnLi9jcmVhdGVTdG9yZSc7XG5pbXBvcnQgY29tYmluZVJlZHVjZXJzIGZyb20gJy4vY29tYmluZVJlZHVjZXJzJztcbmltcG9ydCBiaW5kQWN0aW9uQ3JlYXRvcnMgZnJvbSAnLi9iaW5kQWN0aW9uQ3JlYXRvcnMnO1xuaW1wb3J0IGFwcGx5TWlkZGxld2FyZSBmcm9tICcuL2FwcGx5TWlkZGxld2FyZSc7XG5pbXBvcnQgY29tcG9zZSBmcm9tICcuL2NvbXBvc2UnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi91dGlscy93YXJuaW5nJztcblxuLypcbiogVGhpcyBpcyBhIGR1bW15IGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBmdW5jdGlvbiBuYW1lIGhhcyBiZWVuIGFsdGVyZWQgYnkgbWluaWZpY2F0aW9uLlxuKiBJZiB0aGUgZnVuY3Rpb24gaGFzIGJlZW4gbWluaWZpZWQgYW5kIE5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsIHdhcm4gdGhlIHVzZXIuXG4qL1xuZnVuY3Rpb24gaXNDcnVzaGVkKCkge31cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGlzQ3J1c2hlZC5uYW1lID09PSAnc3RyaW5nJyAmJiBpc0NydXNoZWQubmFtZSAhPT0gJ2lzQ3J1c2hlZCcpIHtcbiAgd2FybmluZygnWW91IGFyZSBjdXJyZW50bHkgdXNpbmcgbWluaWZpZWQgY29kZSBvdXRzaWRlIG9mIE5PREVfRU5WID09PSBcXCdwcm9kdWN0aW9uXFwnLiAnICsgJ1RoaXMgbWVhbnMgdGhhdCB5b3UgYXJlIHJ1bm5pbmcgYSBzbG93ZXIgZGV2ZWxvcG1lbnQgYnVpbGQgb2YgUmVkdXguICcgKyAnWW91IGNhbiB1c2UgbG9vc2UtZW52aWZ5IChodHRwczovL2dpdGh1Yi5jb20vemVydG9zaC9sb29zZS1lbnZpZnkpIGZvciBicm93c2VyaWZ5ICcgKyAnb3IgRGVmaW5lUGx1Z2luIGZvciB3ZWJwYWNrIChodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMwMDMwMDMxKSAnICsgJ3RvIGVuc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBjb2RlIGZvciB5b3VyIHByb2R1Y3Rpb24gYnVpbGQuJyk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVN0b3JlLCBjb21iaW5lUmVkdWNlcnMsIGJpbmRBY3Rpb25DcmVhdG9ycywgYXBwbHlNaWRkbGV3YXJlLCBjb21wb3NlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVkdXgvZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDUiLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qc1xuLy8gbW9kdWxlIGlkID0gNTc5XG4vLyBtb2R1bGUgY2h1bmtzID0gNSIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvb3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanNcbi8vIG1vZHVsZSBpZCA9IDU4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDUiLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5leHBvcnQgZGVmYXVsdCBmcmVlR2xvYmFsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19mcmVlR2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA1ODFcbi8vIG1vZHVsZSBjaHVua3MgPSA1IiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFJhd1RhZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzXG4vLyBtb2R1bGUgaWQgPSA1ODJcbi8vIG1vZHVsZSBjaHVua3MgPSA1IiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gNTgzXG4vLyBtb2R1bGUgY2h1bmtzID0gNSIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0UHJvdG90eXBlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRQcm90b3R5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDU4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDUiLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlckFyZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qc1xuLy8gbW9kdWxlIGlkID0gNTg1XG4vLyBtb2R1bGUgY2h1bmtzID0gNSIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdExpa2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3RMaWtlLmpzXG4vLyBtb2R1bGUgaWQgPSA1ODZcbi8vIG1vZHVsZSBjaHVua3MgPSA1IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9pbmRleCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDUiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcG9ueWZpbGwgPSByZXF1aXJlKCcuL3BvbnlmaWxsJyk7XG5cbnZhciBfcG9ueWZpbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9ueWZpbGwpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciByb290OyAvKiBnbG9iYWwgd2luZG93ICovXG5cblxuaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gc2VsZjtcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IG1vZHVsZTtcbn0gZWxzZSB7XG4gIHJvb3QgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xufVxuXG52YXIgcmVzdWx0ID0gKDAsIF9wb255ZmlsbDJbJ2RlZmF1bHQnXSkocm9vdCk7XG5leHBvcnRzWydkZWZhdWx0J10gPSByZXN1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1ODhcbi8vIG1vZHVsZSBjaHVua3MgPSA1IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsO1xuZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcblx0dmFyIHJlc3VsdDtcblx0dmFyIF9TeW1ib2wgPSByb290LlN5bWJvbDtcblxuXHRpZiAodHlwZW9mIF9TeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcblx0XHRpZiAoX1N5bWJvbC5vYnNlcnZhYmxlKSB7XG5cdFx0XHRyZXN1bHQgPSBfU3ltYm9sLm9ic2VydmFibGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9IF9TeW1ib2woJ29ic2VydmFibGUnKTtcblx0XHRcdF9TeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvcG9ueWZpbGwuanNcbi8vIG1vZHVsZSBpZCA9IDU4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDUiLCJpbXBvcnQgeyBBY3Rpb25UeXBlcyB9IGZyb20gJy4vY3JlYXRlU3RvcmUnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi91dGlscy93YXJuaW5nJztcblxuZnVuY3Rpb24gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2Uoa2V5LCBhY3Rpb24pIHtcbiAgdmFyIGFjdGlvblR5cGUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGU7XG4gIHZhciBhY3Rpb25OYW1lID0gYWN0aW9uVHlwZSAmJiAnXCInICsgYWN0aW9uVHlwZS50b1N0cmluZygpICsgJ1wiJyB8fCAnYW4gYWN0aW9uJztcblxuICByZXR1cm4gJ0dpdmVuIGFjdGlvbiAnICsgYWN0aW9uTmFtZSArICcsIHJlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZC4gJyArICdUbyBpZ25vcmUgYW4gYWN0aW9uLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuICcgKyAnSWYgeW91IHdhbnQgdGhpcyByZWR1Y2VyIHRvIGhvbGQgbm8gdmFsdWUsIHlvdSBjYW4gcmV0dXJuIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuJztcbn1cblxuZnVuY3Rpb24gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShpbnB1dFN0YXRlLCByZWR1Y2VycywgYWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGUpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgYXJndW1lbnROYW1lID0gYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBBY3Rpb25UeXBlcy5JTklUID8gJ3ByZWxvYWRlZFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZScgOiAncHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXInO1xuXG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ1N0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCAnICsgJ3RvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy4nO1xuICB9XG5cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuICdUaGUgJyArIGFyZ3VtZW50TmFtZSArICcgaGFzIHVuZXhwZWN0ZWQgdHlwZSBvZiBcIicgKyB7fS50b1N0cmluZy5jYWxsKGlucHV0U3RhdGUpLm1hdGNoKC9cXHMoW2EtenxBLVpdKykvKVsxXSArICdcIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyAnICsgKCdrZXlzOiBcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIicpO1xuICB9XG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgIXVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldO1xuICB9KTtcblxuICB1bmV4cGVjdGVkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XSA9IHRydWU7XG4gIH0pO1xuXG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuICdVbmV4cGVjdGVkICcgKyAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMSA/ICdrZXlzJyA6ICdrZXknKSArICcgJyArICgnXCInICsgdW5leHBlY3RlZEtleXMuam9pbignXCIsIFwiJykgKyAnXCIgZm91bmQgaW4gJyArIGFyZ3VtZW50TmFtZSArICcuICcpICsgJ0V4cGVjdGVkIHRvIGZpbmQgb25lIG9mIHRoZSBrbm93biByZWR1Y2VyIGtleXMgaW5zdGVhZDogJyArICgnXCInICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyAnXCIuIFVuZXhwZWN0ZWQga2V5cyB3aWxsIGJlIGlnbm9yZWQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNoYXBlKHJlZHVjZXJzKSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcmVkdWNlciA9IHJlZHVjZXJzW2tleV07XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHJlZHVjZXIodW5kZWZpbmVkLCB7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XG5cbiAgICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gJyArICdJZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VyIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgJyArICdleHBsaWNpdGx5IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5ICcgKyAnbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvblxcJ3Qgd2FudCB0byBzZXQgYSB2YWx1ZSBmb3IgdGhpcyByZWR1Y2VyLCAnICsgJ3lvdSBjYW4gdXNlIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSAnQEByZWR1eC9QUk9CRV9VTktOT1dOX0FDVElPTl8nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpLnNwbGl0KCcnKS5qb2luKCcuJyk7XG4gICAgaWYgKHR5cGVvZiByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiB0eXBlIH0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBwcm9iZWQgd2l0aCBhIHJhbmRvbSB0eXBlLiAnICsgKCdEb25cXCd0IHRyeSB0byBoYW5kbGUgJyArIEFjdGlvblR5cGVzLklOSVQgKyAnIG9yIG90aGVyIGFjdGlvbnMgaW4gXCJyZWR1eC8qXCIgJykgKyAnbmFtZXNwYWNlLiBUaGV5IGFyZSBjb25zaWRlcmVkIHByaXZhdGUuIEluc3RlYWQsIHlvdSBtdXN0IHJldHVybiB0aGUgJyArICdjdXJyZW50IHN0YXRlIGZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCAnICsgJ2luIHdoaWNoIGNhc2UgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLCByZWdhcmRsZXNzIG9mIHRoZSAnICsgJ2FjdGlvbiB0eXBlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZCwgYnV0IGNhbiBiZSBudWxsLicpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgZGlmZmVyZW50IHJlZHVjZXIgZnVuY3Rpb25zLCBpbnRvIGEgc2luZ2xlXG4gKiByZWR1Y2VyIGZ1bmN0aW9uLiBJdCB3aWxsIGNhbGwgZXZlcnkgY2hpbGQgcmVkdWNlciwgYW5kIGdhdGhlciB0aGVpciByZXN1bHRzXG4gKiBpbnRvIGEgc2luZ2xlIHN0YXRlIG9iamVjdCwgd2hvc2Uga2V5cyBjb3JyZXNwb25kIHRvIHRoZSBrZXlzIG9mIHRoZSBwYXNzZWRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWR1Y2VycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGNvcnJlc3BvbmQgdG8gZGlmZmVyZW50XG4gKiByZWR1Y2VyIGZ1bmN0aW9ucyB0aGF0IG5lZWQgdG8gYmUgY29tYmluZWQgaW50byBvbmUuIE9uZSBoYW5keSB3YXkgdG8gb2J0YWluXG4gKiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhcyByZWR1Y2Vyc2Agc3ludGF4LiBUaGUgcmVkdWNlcnMgbWF5IG5ldmVyIHJldHVyblxuICogdW5kZWZpbmVkIGZvciBhbnkgYWN0aW9uLiBJbnN0ZWFkLCB0aGV5IHNob3VsZCByZXR1cm4gdGhlaXIgaW5pdGlhbCBzdGF0ZVxuICogaWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGVtIHdhcyB1bmRlZmluZWQsIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBmb3IgYW55XG4gKiB1bnJlY29nbml6ZWQgYWN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSByZWR1Y2VyIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBldmVyeSByZWR1Y2VyIGluc2lkZSB0aGVcbiAqIHBhc3NlZCBvYmplY3QsIGFuZCBidWlsZHMgYSBzdGF0ZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tYmluZVJlZHVjZXJzKHJlZHVjZXJzKSB7XG4gIHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgdmFyIGZpbmFsUmVkdWNlcnMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWR1Y2VyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSByZWR1Y2VyS2V5c1tpXTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdhcm5pbmcoJ05vIHJlZHVjZXIgcHJvdmlkZWQgZm9yIGtleSBcIicgKyBrZXkgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZpbmFsUmVkdWNlcnNba2V5XSA9IHJlZHVjZXJzW2tleV07XG4gICAgfVxuICB9XG4gIHZhciBmaW5hbFJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMoZmluYWxSZWR1Y2Vycyk7XG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlDYWNoZSA9IHZvaWQgMDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB1bmV4cGVjdGVkS2V5Q2FjaGUgPSB7fTtcbiAgfVxuXG4gIHZhciBzaGFwZUFzc2VydGlvbkVycm9yID0gdm9pZCAwO1xuICB0cnkge1xuICAgIGFzc2VydFJlZHVjZXJTaGFwZShmaW5hbFJlZHVjZXJzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNoYXBlQXNzZXJ0aW9uRXJyb3IgPSBlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbWJpbmF0aW9uKCkge1xuICAgIHZhciBzdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50c1sxXTtcblxuICAgIGlmIChzaGFwZUFzc2VydGlvbkVycm9yKSB7XG4gICAgICB0aHJvdyBzaGFwZUFzc2VydGlvbkVycm9yO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgd2FybmluZ01lc3NhZ2UgPSBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKHN0YXRlLCBmaW5hbFJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSk7XG4gICAgICBpZiAod2FybmluZ01lc3NhZ2UpIHtcbiAgICAgICAgd2FybmluZyh3YXJuaW5nTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dFN0YXRlID0ge307XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2tleSA9IGZpbmFsUmVkdWNlcktleXNbX2ldO1xuICAgICAgdmFyIHJlZHVjZXIgPSBmaW5hbFJlZHVjZXJzW19rZXldO1xuICAgICAgdmFyIHByZXZpb3VzU3RhdGVGb3JLZXkgPSBzdGF0ZVtfa2V5XTtcbiAgICAgIHZhciBuZXh0U3RhdGVGb3JLZXkgPSByZWR1Y2VyKHByZXZpb3VzU3RhdGVGb3JLZXksIGFjdGlvbik7XG4gICAgICBpZiAodHlwZW9mIG5leHRTdGF0ZUZvcktleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IGdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlKF9rZXksIGFjdGlvbik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgbmV4dFN0YXRlW19rZXldID0gbmV4dFN0YXRlRm9yS2V5O1xuICAgICAgaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQgfHwgbmV4dFN0YXRlRm9yS2V5ICE9PSBwcmV2aW91c1N0YXRlRm9yS2V5O1xuICAgIH1cbiAgICByZXR1cm4gaGFzQ2hhbmdlZCA/IG5leHRTdGF0ZSA6IHN0YXRlO1xuICB9O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2NvbWJpbmVSZWR1Y2Vycy5qc1xuLy8gbW9kdWxlIGlkID0gNTkwXG4vLyBtb2R1bGUgY2h1bmtzID0gNSIsImZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb24gY3JlYXRvcnMsIGludG8gYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIGtleXMsIGJ1dCB3aXRoIGV2ZXJ5IGZ1bmN0aW9uIHdyYXBwZWQgaW50byBhIGBkaXNwYXRjaGAgY2FsbCBzbyB0aGV5XG4gKiBtYXkgYmUgaW52b2tlZCBkaXJlY3RseS4gVGhpcyBpcyBqdXN0IGEgY29udmVuaWVuY2UgbWV0aG9kLCBhcyB5b3UgY2FuIGNhbGxcbiAqIGBzdG9yZS5kaXNwYXRjaChNeUFjdGlvbkNyZWF0b3JzLmRvU29tZXRoaW5nKCkpYCB5b3Vyc2VsZiBqdXN0IGZpbmUuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgZ2V0IGEgZnVuY3Rpb24gaW4gcmV0dXJuLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBhY3Rpb25DcmVhdG9ycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb25cbiAqIGNyZWF0b3IgZnVuY3Rpb25zLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpbiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhc2BcbiAqIHN5bnRheC4gWW91IG1heSBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcGF0Y2ggVGhlIGBkaXNwYXRjaGAgZnVuY3Rpb24gYXZhaWxhYmxlIG9uIHlvdXIgUmVkdXhcbiAqIHN0b3JlLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFRoZSBvYmplY3QgbWltaWNraW5nIHRoZSBvcmlnaW5hbCBvYmplY3QsIGJ1dCB3aXRoXG4gKiBldmVyeSBhY3Rpb24gY3JlYXRvciB3cmFwcGVkIGludG8gdGhlIGBkaXNwYXRjaGAgY2FsbC4gSWYgeW91IHBhc3NlZCBhXG4gKiBmdW5jdGlvbiBhcyBgYWN0aW9uQ3JlYXRvcnNgLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYWxzbyBiZSBhIHNpbmdsZVxuICogZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyAhPT0gJ29iamVjdCcgfHwgYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBY3Rpb25DcmVhdG9ycyBleHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgaW5zdGVhZCByZWNlaXZlZCAnICsgKGFjdGlvbkNyZWF0b3JzID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGFjdGlvbkNyZWF0b3JzKSArICcuICcgKyAnRGlkIHlvdSB3cml0ZSBcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXCIgaW5zdGVhZCBvZiBcImltcG9ydCAqIGFzIEFjdGlvbkNyZWF0b3JzIGZyb21cIj8nKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWN0aW9uQ3JlYXRvcnMpO1xuICB2YXIgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICB2YXIgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2JpbmRBY3Rpb25DcmVhdG9ycy5qc1xuLy8gbW9kdWxlIGlkID0gNTkxXG4vLyBtb2R1bGUgY2h1bmtzID0gNSIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCBjb21wb3NlIGZyb20gJy4vY29tcG9zZSc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0b3JlIGVuaGFuY2VyIHRoYXQgYXBwbGllcyBtaWRkbGV3YXJlIHRvIHRoZSBkaXNwYXRjaCBtZXRob2RcbiAqIG9mIHRoZSBSZWR1eCBzdG9yZS4gVGhpcyBpcyBoYW5keSBmb3IgYSB2YXJpZXR5IG9mIHRhc2tzLCBzdWNoIGFzIGV4cHJlc3NpbmdcbiAqIGFzeW5jaHJvbm91cyBhY3Rpb25zIGluIGEgY29uY2lzZSBtYW5uZXIsIG9yIGxvZ2dpbmcgZXZlcnkgYWN0aW9uIHBheWxvYWQuXG4gKlxuICogU2VlIGByZWR1eC10aHVua2AgcGFja2FnZSBhcyBhbiBleGFtcGxlIG9mIHRoZSBSZWR1eCBtaWRkbGV3YXJlLlxuICpcbiAqIEJlY2F1c2UgbWlkZGxld2FyZSBpcyBwb3RlbnRpYWxseSBhc3luY2hyb25vdXMsIHRoaXMgc2hvdWxkIGJlIHRoZSBmaXJzdFxuICogc3RvcmUgZW5oYW5jZXIgaW4gdGhlIGNvbXBvc2l0aW9uIGNoYWluLlxuICpcbiAqIE5vdGUgdGhhdCBlYWNoIG1pZGRsZXdhcmUgd2lsbCBiZSBnaXZlbiB0aGUgYGRpc3BhdGNoYCBhbmQgYGdldFN0YXRlYCBmdW5jdGlvbnNcbiAqIGFzIG5hbWVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBtaWRkbGV3YXJlcyBUaGUgbWlkZGxld2FyZSBjaGFpbiB0byBiZSBhcHBsaWVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHN0b3JlIGVuaGFuY2VyIGFwcGx5aW5nIHRoZSBtaWRkbGV3YXJlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseU1pZGRsZXdhcmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtaWRkbGV3YXJlcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1pZGRsZXdhcmVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjcmVhdGVTdG9yZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKSB7XG4gICAgICB2YXIgc3RvcmUgPSBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpO1xuICAgICAgdmFyIF9kaXNwYXRjaCA9IHN0b3JlLmRpc3BhdGNoO1xuICAgICAgdmFyIGNoYWluID0gW107XG5cbiAgICAgIHZhciBtaWRkbGV3YXJlQVBJID0ge1xuICAgICAgICBnZXRTdGF0ZTogc3RvcmUuZ2V0U3RhdGUsXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gX2Rpc3BhdGNoKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjaGFpbiA9IG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgICAgICByZXR1cm4gbWlkZGxld2FyZShtaWRkbGV3YXJlQVBJKTtcbiAgICAgIH0pO1xuICAgICAgX2Rpc3BhdGNoID0gY29tcG9zZS5hcHBseSh1bmRlZmluZWQsIGNoYWluKShzdG9yZS5kaXNwYXRjaCk7XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RvcmUsIHtcbiAgICAgICAgZGlzcGF0Y2g6IF9kaXNwYXRjaFxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9hcHBseU1pZGRsZXdhcmUuanNcbi8vIG1vZHVsZSBpZCA9IDU5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDUiLCJjb25zdCBpbml0aWFsU3RhdGUgPSB7XHJcbiAgICBodG1sOiBgYCxcclxuICAgIGNzczogYGAsXHJcbiAgICBqczogYGBcclxufVxyXG5cclxuY29uc3QgZGF0YWJhc2VJbmplY3Rpb25BbmRQdWJsaXNoID0gKHN0YXRlKSA9PiB7XHJcbiAgICAvL0FsbCB0aGUgY29ubmVjdGlvbiB3aXRoIHRoZSBiYWNrZW5kIHdpbGwgYmUgbWFkZSBoZXJlIVxyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG59XHJcblxyXG5jb25zdCBDb2RlQ29tYmluZXIgPSAoc3RhdGUgPSBpbml0aWFsU3RhdGUsIGFjdGlvbikgPT4ge1xyXG4gICAgc3dpdGNoKGFjdGlvbi50eXBlKXtcclxuICAgICAgICBjYXNlICdIVE1MX1NVQk1JVCc6IHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge2h0bWw6IGFjdGlvbi5odG1sfSlcclxuICAgICAgICBjYXNlICdDU1NfU1VCTUlUJzogcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7Y3NzOiBhY3Rpb24uY3NzfSlcclxuICAgICAgICBjYXNlICdKU19TVUJNSVQnOiByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtqczogYWN0aW9uLmpzfSlcclxuICAgICAgICBjYXNlICdTQVZFX1RPX0RBVEFCQVNFJzogcmV0dXJuIGRhdGFiYXNlSW5qZWN0aW9uQW5kUHVibGlzaChzdGF0ZSlcclxuICAgICAgICBkZWZhdWx0OiByZXR1cm4gc3RhdGVcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29kZUNvbWJpbmVyXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVkdXgvcmVkdWNlcnMuanMiLCJpbXBvcnQgc3RvcmUgZnJvbSAnLi4vcmVkdXgvc3RvcmUnXHJcbmltcG9ydCB7U0FWRV9UT19EQVRBQkFTRSwgSFRNTF9TVUJNSVQsIENTU19TVUJNSVQsIEpTX1NVQk1JVH0gZnJvbSAnLi4vcmVkdXgvYWN0aW9ucydcclxuaW1wb3J0IGxlc3MgZnJvbSAnbGVzcydcclxuXHJcblxyXG5jbGFzcyBSZXN1bHQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHVuc3Vic2NyaWJlID0gc3RvcmUuc3Vic2NyaWJlKCgpID0+IHt9KVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgIGxldCByZW5kZXJpbmc7XHJcbiAgICAgICAgbGVzcy5yZW5kZXIoYCNyZW5kZXJTY3ske3N0b3JlLmdldFN0YXRlKCkuY3NzfX1gLCBmdW5jdGlvbiAoZSwgb3V0cHV0KSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmluZyA9IGA8c3R5bGU+JHtvdXRwdXQuY3NzfTwvc3R5bGU+JHtzdG9yZS5nZXRTdGF0ZSgpLmh0bWx9YCAgXHJcbiAgICAgICAgfSkgICAgICAgIFxyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZW5kZXJTYycpLmlubmVySFRNTCA9IHJlbmRlcmluZ1xyXG5cclxuICAgICAgICBldmFsKHN0b3JlLmdldFN0YXRlKCkuanMpXHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICAgIGlkPVwicmVuZGVyU2NcIlxyXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgIGhlaWdodDogJzkwdmgnLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6ICc1MHZ3JyxcclxuICAgICAgICAgICAgICAgIGJvcmRlcjogJ3NvbGlkIDFweCBibGFjaydcclxuICAgICAgICAgICAgfX0+PC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuUmVzdWx0LmNvbnRleHRUeXBlXHJcblxyXG5leHBvcnQgZGVmYXVsdCBSZXN1bHRcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL1Jlc3VsdC5qcyIsImltcG9ydCBzdG9yZSBmcm9tICcuLi9yZWR1eC9zdG9yZSdcclxuaW1wb3J0IHtDU1NfU1VCTUlUfSBmcm9tICcuLi9yZWR1eC9hY3Rpb25zJ1xyXG5cclxuY2xhc3MgQ3NzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IHN0b3JlLmdldFN0YXRlKCkuY3NzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnRXaWxsTW91bnQoKXtcclxuICAgICAgICBzdG9yZS5kaXNwYXRjaChDU1NfU1VCTUlUKHRoaXMuc3RhdGUuY29udGVudCkpXHJcbiAgICB9XHJcblxyXG4gICAgX3VwZGF0ZVN0YXRlKGNvbnRlbnQpeyAgICAgICAgXHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7Y29udGVudH0pXHJcbiAgICAgICAgc3RvcmUuZGlzcGF0Y2goQ1NTX1NVQk1JVCh0aGlzLnN0YXRlLmNvbnRlbnQpKSAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKXtcclxuICAgICAgICBzdG9yZS5kaXNwYXRjaChDU1NfU1VCTUlUKHRoaXMuc3RhdGUuY29udGVudCkpXHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8aDI+Q1NTPC9oMj5cclxuICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSBzdHlsZT17eyByZXNpemU6ICdub25lJ319IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KG5vZGUpPT50aGlzLl91cGRhdGVTdGF0ZShub2RlLnRhcmdldC52YWx1ZSl9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dzPXsyMH0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHM9ezEwMH1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICB7dGhpcy5zdGF0ZS5jb250ZW50fVxyXG4gICAgICAgICAgICAgICAgPC90ZXh0YXJlYT5cclxuICAgICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gc3RvcmUuZGlzcGF0Y2goQ1NTX1NVQk1JVCh0aGlzLnN0YXRlLmNvbnRlbnQpKX0+U3VibWl0IENTUzwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDc3NcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL0Nzcy5qcyIsImltcG9ydCBzdG9yZSBmcm9tICcuLi9yZWR1eC9zdG9yZSdcclxuaW1wb3J0IHtKU19TVUJNSVR9IGZyb20gJy4uL3JlZHV4L2FjdGlvbnMnXHJcblxyXG5jbGFzcyBKcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICBjb250ZW50OiBzdG9yZS5nZXRTdGF0ZSgpLmpzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnRXaWxsTW91bnQoKXtcclxuICAgICAgICBzdG9yZS5kaXNwYXRjaChKU19TVUJNSVQodGhpcy5zdGF0ZS5jb250ZW50KSlcclxuICAgIH1cclxuXHJcbiAgICBfdXBkYXRlU3RhdGUoY29udGVudCl7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7Y29udGVudH0pXHJcbiAgICAgICAgc3RvcmUuZGlzcGF0Y2goSlNfU1VCTUlUKHRoaXMuc3RhdGUuY29udGVudCkpXHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKXtcclxuICAgICAgICBzdG9yZS5kaXNwYXRjaChKU19TVUJNSVQodGhpcy5zdGF0ZS5jb250ZW50KSlcclxuICAgIH1cclxuXHJcbiAgICBcclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxoMj5KYXZhU2NyaXB0PC9oMj5cclxuICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSBzdHlsZT17eyByZXNpemU6ICdub25lJ319IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KG5vZGUpPT50aGlzLl91cGRhdGVTdGF0ZShub2RlLnRhcmdldC52YWx1ZSl9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dzPXsyMH0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHM9ezEwMH1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICB7dGhpcy5zdGF0ZS5jb250ZW50fVxyXG4gICAgICAgICAgICAgICAgPC90ZXh0YXJlYT5cclxuICAgICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gc3RvcmUuZGlzcGF0Y2goSlNfU1VCTUlUKHRoaXMuc3RhdGUuY29udGVudCkpfT5TdWJtaXQgSlM8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKVxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgSnNcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL0pTLmpzIiwiaW1wb3J0IHN0b3JlIGZyb20gJy4uL3JlZHV4L3N0b3JlJ1xyXG5pbXBvcnQge0hUTUxfU1VCTUlUfSBmcm9tICcuLi9yZWR1eC9hY3Rpb25zJ1xyXG5cclxuY2xhc3MgSHRtbCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICBjb250ZW50OiBzdG9yZS5nZXRTdGF0ZSgpLmh0bWxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpe1xyXG4gICAgICAgIHN0b3JlLmRpc3BhdGNoKEhUTUxfU1VCTUlUKHRoaXMuc3RhdGUuY29udGVudCkpXHJcbiAgICB9XHJcblxyXG4gICAgX3VwZGF0ZVN0YXRlKGNvbnRlbnQpe1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe2NvbnRlbnR9KVxyXG4gICAgICAgIHN0b3JlLmRpc3BhdGNoKEhUTUxfU1VCTUlUKHRoaXMuc3RhdGUuY29udGVudCkpXHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKXtcclxuICAgICAgICBzdG9yZS5kaXNwYXRjaChIVE1MX1NVQk1JVCh0aGlzLnN0YXRlLmNvbnRlbnQpKVxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPGgyPkhUTUw8L2gyPlxyXG4gICAgICAgICAgICAgICAgPHRleHRhcmVhIHN0eWxlPXt7IHJlc2l6ZTogJ25vbmUnfX0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsobm9kZSk9PnRoaXMuX3VwZGF0ZVN0YXRlKG5vZGUudGFyZ2V0LnZhbHVlKX0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd3M9ezIwfSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29scz17MTAwfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIHt0aGlzLnN0YXRlLmNvbnRlbnR9XHJcbiAgICAgICAgICAgICAgICA8L3RleHRhcmVhPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzdG9yZS5kaXNwYXRjaChIVE1MX1NVQk1JVCh0aGlzLnN0YXRlLmNvbnRlbnQpKX0+U3VibWl0IEhUTUw8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKVxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgSHRtbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvSHRtbC5qcyJdLCJtYXBwaW5ncyI6IjtBOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMvREE7QUFDQTs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDelhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMzQkE7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xCQTs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDeEJBOzs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0hBOzs7Ozs7O0FDQUE7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ05BOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBOzs7Ozs7O0FDRkE7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDN1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTs7Ozs7Ozs7QUNEQTs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0hBOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNKQTtBQUNBOzs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDakNBOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcEZBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNGQTtBQUNBOzs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDUkE7Ozs7OztBQ0FBOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDek9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbEJBOzs7Ozs7O0FDQUE7Ozs7Ozs7QUNBQTs7Ozs7O0FDQUE7QUFDQTtBQUNBOzs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN4QkE7Ozs7OztBQ0FBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3YyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ05BOztBQUVBO0FBRkE7QUFDQTtBQURBO0FBQ0E7QUFJQTs7QUFFQTtBQUZBO0FBQ0E7QUFEQTtBQUNBO0FBSUE7O0FBRUE7QUFGQTtBQUNBO0FBREE7QUFDQTtBQUlBOztBQUNBO0FBQUE7QUFHQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7QUNuQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN2UEE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM3REE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTEE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNwQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL2tWQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBRUE7Ozs7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUpBO0FBSUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBOzs7O0FBR0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7O0FBQUE7QUFDQTtBQURBO0FBQUE7QUFFQTtBQUFBOztBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBRUE7QUFBQTs7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUVBO0FBQUE7O0FBQUE7QUFHQTtBQUhBO0FBQUE7QUFDQTs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFBQTs7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTs7Ozs7QUEzREE7QUFDQTtBQThEQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ0hBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzVCQTs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqSUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDOUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQ0E7QUFFQTtBQUNBO0FBSEE7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBSEE7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBREE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUdBOztBQUVBO0FBQ0E7QUFBQTtBQUZBO0FBSEE7QUFRQTtBQVJBO0FBQ0E7Ozs7O0FBcEJBO0FBQ0E7QUFEQTtBQUNBO0FBNkJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JDQTtBQUNBOzs7QUFBQTtBQUNBOzs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBRUE7Ozs7O0FBR0E7QUFBQTs7OztBQUdBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQUE7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFBQTs7QUFBQTtBQUNBO0FBREE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7O0FBSEE7QUFLQTtBQUxBO0FBS0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7Ozs7O0FBbkNBO0FBQ0E7QUFzQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUVBOzs7OztBQUdBO0FBQUE7Ozs7QUFHQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUFBOzs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7O0FBQUE7QUFDQTtBQURBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUFBOztBQUhBO0FBS0E7QUFMQTtBQUtBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBOzs7OztBQXJDQTtBQUNBO0FBd0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUNBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFFQTs7Ozs7QUFHQTtBQUFBOzs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFBQTs7OztBQUdBO0FBQ0E7QUFDQTtBQUFBOztBQUFBO0FBQ0E7QUFEQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTs7QUFIQTtBQUtBO0FBTEE7QUFLQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTs7Ozs7QUFuQ0E7QUFDQTtBQXNDQTs7Ozs7O0EiLCJzb3VyY2VSb290IjoiIn0=
            return { page: comp.default }
          })
        